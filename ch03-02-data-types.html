<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Data Types - The Rust Programming Language</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="ferris.css">
                <link rel="stylesheet" href="theme/2018-edition.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html" class="active"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References and Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> The Slice Type</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> How to Write Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlling How Tests Are Run</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.inlay-hint, .inlay-hint * {
    border-radius: .4em;
}

.light .inlay-hint, .rust .inlay-hint {
    background-color: #dcc;
    color: #777;
}

.ayu .inlay-hint, .navy .inlay-hint, .coal .inlay-hint {
    background-color: #444;
    color: #999;
}

.inlay-hint {
    font-size: 0.8em;
    user-select: none;
}
.hover-holder {
    max-height: 40vh;
    overflow: auto;
}

.tippy-content {
    background-color: var(--bg);
    color: var(--fg);
}
</style>## Data Types
<p>Every value in Rust is of a certain <em>data type</em>, which tells Rust what kind of
data is being specified so it knows how to work with that data. We’ll look at
two data type subsets: scalar and compound.</p>
<p>Keep in mind that Rust is a <em>statically typed</em> language, which means that it
must know the types of all variables at compile time. The compiler can usually
infer what type we want to use based on the value and how we use it. In cases
when many types are possible, such as when we converted a <code>String</code> to a numeric
type using <code>parse</code> in the <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“Comparing the Guess to the Secret
Number”</a><!-- ignore --> section in
Chapter 2, we must add a type annotation, like this:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let <span class="ra" data-hover="1">guess</span>: <span class="ra" data-hover="2">u32</span> = "42".<span class="ra" data-hover="3">parse</span>().<span class="ra" data-hover="4">expect</span>(<span class="inlay-hint">msg: </span>"Not a number!");
<span class="boring">}
</span>
</code></pre></pre>
<p>If we don’t add the type annotation here, Rust will display the following
error, which means the compiler needs more information from us to know which
type we want to use:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^ consider giving `guess` a type

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
</code></pre>
<p>You’ll see different type annotations for other data types.</p>
<h3 id="scalar-types"><a class="header" href="#scalar-types">Scalar Types</a></h3>
<p>A <em>scalar</em> type represents a single value. Rust has four primary scalar types:
integers, floating-point numbers, Booleans, and characters. You may recognize
these from other programming languages. Let’s jump into how they work in Rust.</p>
<h4 id="integer-types"><a class="header" href="#integer-types">Integer Types</a></h4>
<p>An <em>integer</em> is a number without a fractional component. We used one integer
type in Chapter 2, the <code>u32</code> type. This type declaration indicates that the
value it’s associated with should be an unsigned integer (signed integer types
start with <code>i</code>, instead of <code>u</code>) that takes up 32 bits of space. Table 3-1 shows
the built-in integer types in Rust. Each variant in the Signed and Unsigned
columns (for example, <code>i16</code>) can be used to declare the type of an integer
value.</p>
<p><span class="caption">Table 3-1: Integer Types in Rust</span></p>
<table><thead><tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<p>Each variant can be either signed or unsigned and has an explicit size.
<em>Signed</em> and <em>unsigned</em> refer to whether it’s possible for the number to be
negative—in other words, whether the number needs to have a sign with it
(signed) or whether it will only ever be positive and can therefore be
represented without a sign (unsigned). It’s like writing numbers on paper: when
the sign matters, a number is shown with a plus sign or a minus sign; however,
when it’s safe to assume the number is positive, it’s shown with no sign.
Signed numbers are stored using <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two’s
complement</a><!-- ignore -->
representation.</p>
<p>Each signed variant can store numbers from -(2<sup>n - 1</sup>) to 2<sup>n -
1</sup> - 1 inclusive, where <em>n</em> is the number of bits that variant uses. So an
<code>i8</code> can store numbers from -(2<sup>7</sup>) to 2<sup>7</sup> - 1, which equals
-128 to 127. Unsigned variants can store numbers from 0 to 2<sup>n</sup> - 1,
so a <code>u8</code> can store numbers from 0 to 2<sup>8</sup> - 1, which equals 0 to 255.</p>
<p>Additionally, the <code>isize</code> and <code>usize</code> types depend on the kind of computer your
program is running on: 64 bits if you’re on a 64-bit architecture and 32 bits
if you’re on a 32-bit architecture.</p>
<p>You can write integer literals in any of the forms shown in Table 3-2. Note
that number literals that can be multiple numeric types allow a type suffix,
such as <code>57u8</code>, to designate the type. Number literals can also use <code>_</code> as a
visual separator to make the number easier to read, such as <code>1_000</code>, which will
have the same value as if you had specified <code>1000</code>.</p>
<p><span class="caption">Table 3-2: Integer Literals in Rust</span></p>
<table><thead><tr><th>Number literals</th><th>Example</th></tr></thead><tbody>
<tr><td>Decimal</td><td><code>98_222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o77</code></td></tr>
<tr><td>Binary</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Byte (<code>u8</code> only)</td><td><code>b'A'</code></td></tr>
</tbody></table>
<p>So how do you know which type of integer to use? If you’re unsure, Rust’s
defaults are generally good places to start: integer types default to <code>i32</code>.
The primary situation in which you’d use <code>isize</code> or <code>usize</code> is when indexing
some sort of collection.</p>
<blockquote>
<h5 id="integer-overflow"><a class="header" href="#integer-overflow">Integer Overflow</a></h5>
<p>Let’s say you have a variable of type <code>u8</code> that can hold values between 0 and 255.
If you try to change the variable to a value outside of that range, such
as 256, <em>integer overflow</em> will occur. Rust has some interesting rules
involving this behavior. When you’re compiling in debug mode, Rust includes
checks for integer overflow that cause your program to <em>panic</em> at runtime if
this behavior occurs. Rust uses the term panicking when a program exits with
an error; we’ll discuss panics in more depth in the <a href="ch09-01-unrecoverable-errors-with-panic.html">“Unrecoverable Errors
with <code>panic!</code>”</a><!-- ignore --> section in
Chapter 9.</p>
<p>When you’re compiling in release mode with the <code>--release</code> flag, Rust does
<em>not</em> include checks for integer overflow that cause panics. Instead, if
overflow occurs, Rust performs <em>two’s complement wrapping</em>. In short, values
greater than the maximum value the type can hold “wrap around” to the minimum
of the values the type can hold. In the case of a <code>u8</code>, the value 256 becomes
0, the value 257 becomes 1, and so on. The program won’t panic, but the
variable will have a value that probably isn’t what you were expecting it to
have. Relying on integer overflow’s wrapping behavior is considered an error.</p>
<p>To explicitly handle the possibility of overflow, you can use these families
of methods that the standard library provides on primitive numeric types:</p>
<ul>
<li>Wrap in all modes with the <code>wrapping_*</code> methods, such as <code>wrapping_add</code></li>
<li>Return the <code>None</code> value if there is overflow with the <code>checked_*</code> methods</li>
<li>Return the value and a boolean indicating whether there was overflow with
the <code>overflowing_*</code> methods</li>
<li>Saturate at the value’s minimum or maximum values with <code>saturating_*</code>
methods</li>
</ul>
</blockquote>
<h4 id="floating-point-types"><a class="header" href="#floating-point-types">Floating-Point Types</a></h4>
<p>Rust also has two primitive types for <em>floating-point numbers</em>, which are
numbers with decimal points. Rust’s floating-point types are <code>f32</code> and <code>f64</code>,
which are 32 bits and 64 bits in size, respectively. The default type is <code>f64</code>
because on modern CPUs it’s roughly the same speed as <code>f32</code> but is capable of
more precision.</p>
<p>Here’s an example that shows floating-point numbers in action:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn <span class="ra" data-hover="0">main</span>() {
    let <span class="ra" data-hover="5">x</span><span class="inlay-hint">: f64</span> = 2.0; // f64

    let <span class="ra" data-hover="6">y</span>: <span class="ra" data-hover="7">f32</span> = 3.0; // f32
}
<span class="boring">}
</span></code></pre></pre>
<p>Floating-point numbers are represented according to the IEEE-754 standard. The
<code>f32</code> type is a single-precision float, and <code>f64</code> has double precision.</p>
<h4 id="numeric-operations"><a class="header" href="#numeric-operations">Numeric Operations</a></h4>
<p>Rust supports the basic mathematical operations you’d expect for all of the
number types: addition, subtraction, multiplication, division, and remainder.
Integer division rounds down to the nearest integer. The following code shows
how you’d use each numeric operation in a <code>let</code> statement:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn <span class="ra" data-hover="0">main</span>() {
    // addition
    let <span class="ra" data-hover="8">sum</span><span class="inlay-hint">: i32</span> = 5 + 10;

    // subtraction
    let <span class="ra" data-hover="9">difference</span><span class="inlay-hint">: f64</span> = 95.5 - 4.3;

    // multiplication
    let <span class="ra" data-hover="10">product</span><span class="inlay-hint">: i32</span> = 4 * 30;

    // division
    let <span class="ra" data-hover="11">quotient</span><span class="inlay-hint">: f64</span> = 56.7 / 32.2;
    let <span class="ra" data-hover="12">floored</span><span class="inlay-hint">: i32</span> = 2 / 3; // Results in 0

    // remainder
    let <span class="ra" data-hover="13">remainder</span><span class="inlay-hint">: i32</span> = 43 % 5;
}
<span class="boring">}
</span></code></pre></pre>
<p>Each expression in these statements uses a mathematical operator and evaluates
to a single value, which is then bound to a variable. <a href="appendix-02-operators.html">Appendix B</a><!-- ignore --> contains a
list of all operators that Rust provides.</p>
<h4 id="the-boolean-type"><a class="header" href="#the-boolean-type">The Boolean Type</a></h4>
<p>As in most other programming languages, a Boolean type in Rust has two possible
values: <code>true</code> and <code>false</code>. Booleans are one byte in size. The Boolean type in
Rust is specified using <code>bool</code>. For example:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn <span class="ra" data-hover="0">main</span>() {
    let <span class="ra" data-hover="14">t</span><span class="inlay-hint">: bool</span> = true;

    let <span class="ra" data-hover="15">f</span>: <span class="ra" data-hover="16">bool</span> = false; // with explicit type annotation
}
<span class="boring">}
</span></code></pre></pre>
<p>The main way to use Boolean values is through conditionals, such as an <code>if</code>
expression. We’ll cover how <code>if</code> expressions work in Rust in the <a href="ch03-05-control-flow.html#control-flow">“Control
Flow”</a><!-- ignore --> section.</p>
<h4 id="the-character-type"><a class="header" href="#the-character-type">The Character Type</a></h4>
<p>So far we’ve worked only with numbers, but Rust supports letters too. Rust’s
<code>char</code> type is the language’s most primitive alphabetic type, and the following
code shows one way to use it. (Note that <code>char</code> literals are specified with
single quotes, as opposed to string literals, which use double quotes.)</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn <span class="ra" data-hover="0">main</span>() {
    let <span class="ra" data-hover="17">c</span><span class="inlay-hint">: char</span> = 'z';
    let <span class="ra" data-hover="18">z</span><span class="inlay-hint">: char</span> = 'ℤ';
    let he<span class="ra" data-hover="19">art_eyed_cat =</span><span class="inlay-hint">: char</span> '😻';
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust’s <code>char</code> type is four bytes in size and represents a Unicode Scalar Value,
which means it can represent a lot more than just ASCII. Accented letters;
Chinese, Japanese, and Korean characters; emoji; and zero-width spaces are all
valid <code>char</code> values in Rust. Unicode Scalar Values range from <code>U+0000</code> to
<code>U+D7FF</code> and <code>U+E000</code> to <code>U+10FFFF</code> inclusive. However, a “character” isn’t
really a concept in Unicode, so your human intuition for what a “character” is
may not match up with what a <code>char</code> is in Rust. We’ll discuss this topic in
detail in <a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">“Storing UTF-8 Encoded Text with Strings”</a><!-- ignore -->
in Chapter 8.</p>
<h3 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h3>
<p><em>Compound types</em> can group multiple values into one type. Rust has two
primitive compound types: tuples and arrays.</p>
<h4 id="the-tuple-type"><a class="header" href="#the-tuple-type">The Tuple Type</a></h4>
<p>A tuple is a general way of grouping together a number of values with a variety
of types into one compound type. Tuples have a fixed length: once declared,
they cannot grow or shrink in size.</p>
<p>We create a tuple by writing a comma-separated list of values inside
parentheses. Each position in the tuple has a type, and the types of the
different values in the tuple don’t have to be the same. We’ve added optional
type annotations in this example:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn <span class="ra" data-hover="0">main</span>() {
    let <span class="ra" data-hover="20">tup</span>: (<span class="ra" data-hover="21">i32</span>, <span class="ra" data-hover="22">f64</span>, <span class="ra" data-hover="23">u8</span>) = (500, 6.4, 1);
}
<span class="boring">}
</span></code></pre></pre>
<p>The variable <code>tup</code> binds to the entire tuple, because a tuple is considered a
single compound element. To get the individual values out of a tuple, we can
use pattern matching to destructure a tuple value, like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn <span class="ra" data-hover="0">main</span>() {
    let <span class="ra" data-hover="24">tup</span><span class="inlay-hint">: (i32, f64, i32)</span> = (500, 6.4, 1);

    let (<span class="ra" data-hover="25">x</span><span class="inlay-hint">: i32</span>, <span class="ra" data-hover="26">y</span><span class="inlay-hint">: f64</span>, <span class="ra" data-hover="27">z</span><span class="inlay-hint">: i32</span>) = <span class="ra" data-hover="24">tup</span>;

    <span class="ra" data-hover="28">println</span>!("The value of y is: {}", <span class="ra" data-hover="26">y</span>);
}
<span class="boring">}
</span></code></pre></pre>
<p>This program first creates a tuple and binds it to the variable <code>tup</code>. It then
uses a pattern with <code>let</code> to take <code>tup</code> and turn it into three separate
variables, <code>x</code>, <code>y</code>, and <code>z</code>. This is called <em>destructuring</em>, because it breaks
the single tuple into three parts. Finally, the program prints the value of
<code>y</code>, which is <code>6.4</code>.</p>
<p>In addition to destructuring through pattern matching, we can access a tuple
element directly by using a period (<code>.</code>) followed by the index of the value we
want to access. For example:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn <span class="ra" data-hover="0">main</span>() {
    let <span class="ra" data-hover="29">x</span>: (<span class="ra" data-hover="21">i32</span>, <span class="ra" data-hover="22">f64</span>, <span class="ra" data-hover="23">u8</span>) = (500, 6.4, 1);

    let <span class="ra" data-hover="30">five_hundred</span><span class="inlay-hint">: i32</span> = <span class="ra" data-hover="29">x</span>.0;

    let <span class="ra" data-hover="31">six_point_four</span><span class="inlay-hint">: f64</span> = <span class="ra" data-hover="29">x</span>.1;

    let <span class="ra" data-hover="32">one</span><span class="inlay-hint">: u8</span> = <span class="ra" data-hover="29">x</span>.2;
}
<span class="boring">}
</span></code></pre></pre>
<p>This program creates a tuple, <code>x</code>, and then makes new variables for each
element by using their respective indices. As with most programming languages,
the first index in a tuple is 0.</p>
<p>The tuple without any values, <code>()</code>, is a special type that has only one value,
also written <code>()</code>. The type is called the <em>unit type</em> and the value is called
the <em>unit value</em>. Expressions implicitly return the unit value if they don’t
return any other value.</p>
<h4 id="the-array-type"><a class="header" href="#the-array-type">The Array Type</a></h4>
<p>Another way to have a collection of multiple values is with an <em>array</em>. Unlike
a tuple, every element of an array must have the same type. Arrays in Rust are
different from arrays in some other languages because arrays in Rust have a
fixed length, like tuples.</p>
<p>In Rust, the values going into an array are written as a comma-separated list
inside square brackets:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn <span class="ra" data-hover="0">main</span>() {
    let <span class="ra" data-hover="33">a</span><span class="inlay-hint">: [i32; 5]</span> = [1, 2, 3, 4, 5];
}
<span class="boring">}
</span></code></pre></pre>
<p>Arrays are useful when you want your data allocated on the stack rather than
the heap (we will discuss the stack and the heap more in Chapter 4) or when
you want to ensure you always have a fixed number of elements. An array isn’t
as flexible as the vector type, though. A vector is a similar collection type
provided by the standard library that <em>is</em> allowed to grow or shrink in size.
If you’re unsure whether to use an array or a vector, you should probably use a
vector. Chapter 8 discusses vectors in more detail.</p>
<p>An example of when you might want to use an array rather than a vector is in a
program that needs to know the names of the months of the year. It’s very
unlikely that such a program will need to add or remove months, so you can use
an array because you know it will always contain 12 elements:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let <span class="ra" data-hover="34">months</span><span class="inlay-hint">: [&amp;str; 12]</span> = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
<span class="boring">}
</span>
</code></pre></pre>
<p>You would write an array’s type by using square brackets, and within the
brackets include the type of each element, a semicolon, and then the number of
elements in the array, like so:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let <span class="ra" data-hover="33">a</span>: [<span class="ra" data-hover="21">i32</span>; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span>
</code></pre></pre>
<p>Here, <code>i32</code> is the type of each element. After the semicolon, the number <code>5</code>
indicates the array contains five elements.</p>
<p>Writing an array’s type this way looks similar to an alternative syntax for
initializing an array: if you want to create an array that contains the same
value for each element, you can specify the initial value, followed by a
semicolon, and then the length of the array in square brackets, as shown here:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let <span class="ra" data-hover="33">a</span><span class="inlay-hint">: [i32; 5]</span> = [3; 5];
<span class="boring">}
</span>
</code></pre></pre>
<p>The array named <code>a</code> will contain <code>5</code> elements that will all be set to the value
<code>3</code> initially. This is the same as writing <code>let a = [3, 3, 3, 3, 3];</code> but in a
more concise way.</p>
<h5 id="accessing-array-elements"><a class="header" href="#accessing-array-elements">Accessing Array Elements</a></h5>
<p>An array is a single chunk of memory of a known, fixed size that can be
allocated on the stack. You can access elements of an array using indexing,
like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn <span class="ra" data-hover="0">main</span>() {
    let <span class="ra" data-hover="33">a</span><span class="inlay-hint">: [i32; 5]</span> = [1, 2, 3, 4, 5];

    let <span class="ra" data-hover="35">first</span><span class="inlay-hint">: i32</span> = <span class="ra" data-hover="33">a</span>[0];
    let <span class="ra" data-hover="36">second</span><span class="inlay-hint">: i32</span> = <span class="ra" data-hover="33">a</span>[1];
}
<span class="boring">}
</span></code></pre></pre>
<p>In this example, the variable named <code>first</code> will get the value <code>1</code>, because
that is the value at index <code>[0]</code> in the array. The variable named <code>second</code> will
get the value <code>2</code> from index <code>[1]</code> in the array.</p>
<h5 id="invalid-array-element-access"><a class="header" href="#invalid-array-element-access">Invalid Array Element Access</a></h5>
<p>What happens if you try to access an element of an array that is past the end
of the array? Say you change the example to the following, which uses code
similar to the guessing game in Chapter 2 to get an array index from the user:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use <span class="ra" data-hover="37">std</span>::<span class="ra" data-hover="38">io</span>;

fn <span class="ra" data-hover="0">main</span>() {
    let <span class="ra" data-hover="33">a</span><span class="inlay-hint">: [i32; 5]</span> = [1, 2, 3, 4, 5];

    <span class="ra" data-hover="28">println</span>!("Please enter an array index.");

    let mut <span class="ra" data-hover="39">index</span> = <span class="ra" data-hover="40">String</span>::<span class="ra" data-hover="41">new</span>();

    <span class="ra" data-hover="38">io</span>::<span class="ra" data-hover="42">stdin</span>()
        .<span class="ra" data-hover="43">read_line</span>(<span class="inlay-hint">buf: </span>&amp;mut <span class="ra" data-hover="39">index</span>)
        .<span class="ra" data-hover="4">expect</span>(<span class="inlay-hint">msg: </span>"Failed to read line");

    let <span class="ra" data-hover="44">index</span>: <span class="ra" data-hover="45">usize</span> = <span class="ra" data-hover="39">index
        .<span class="ra" data-hover="46">trim</span>()
        .<span class="ra" data-hover="3">parse</span>()
        .<span class="ra" data-hover="4">expect</span>(<span class="inlay-hint">msg: </span>"Index entered was not a number");

    let <span class="ra" data-hover="47">element</span><span class="inlay-hint">: i32</span> = <span class="ra" data-hover="33">a</span>[<span class="ra" data-hover="44">index</span>];

    <span class="ra" data-hover="28">println</span>!(
        "The value of the element at index {} is: {}",
        <span class="ra" data-hover="44">index</span>, <span class="ra" data-hover="47">element
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>This code compiles successfully. If you run this code using <code>cargo run</code> and
enter 0, 1, 2, 3, or 4, the program will print out the corresponding value at
that index in the array. If you instead enter a number past the end of the
array, such as 10, you’ll see output like this:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>The program resulted in a <em>runtime</em> error at the point of using an invalid
value in the indexing operation. The program exited with an error message and
didn’t execute the final <code>println!</code> statement. When you attempt to access an
element using indexing, Rust will check that the index you’ve specified is less
than the array length. If the index is greater than or equal to the length,
Rust will panic. This check has to happen at runtime, especially in this case,
because the compiler can’t possibly know what value a user will enter when they
run the code later.</p>
<p>This is an example of Rust’s memory safety principles in action. In many
low-level languages, this kind of check is not done, and when you provide an
incorrect index, invalid memory can be accessed. Rust protects you against this
kind of error by immediately exiting instead of allowing the memory access and
continuing. Chapter 9 discusses more of Rust’s error handling.</p>
<script src="https://unpkg.com/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
<script src="https://unpkg.com/tippy.js@6.3.2/dist/tippy-bundle.umd.min.js" integrity="sha384-vApKv6LkBdPwmt/fNiQrBCVCZvuniXpG0b5UZhVrGAq1zXdZRSsPcWjGdVxkZJtX" crossorigin="anonymous"></script>
<script>
    const hoverData = ['<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn main()\n</code></pre>\n','<per><cide class="language-rust">let guess: u32\n</code></pre>\n','<per><cide class="language-rust">u32\n</code></pre>\n<hr />\n<p>The 32-bit unsigned integer type.</p>\n','<per><cide class="language-rust">core::str\n</code></pre>\n<per><cide class="language-rust">pub fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, F::Err&gt;\nwhere\n    F: FromStr,\n</code></pre>\n<hr />\n<p>Parses this string slice into another type.</p>\n<p>Because <cide>parse</code> is so general, it can cause problems with type\ninference. As such, <cide>parse</code> is one of the few times you#$%ll see\nthe syntax affectionately known as the #$%turbofish#$%: <cide>::&lt;&gt;</code>. This\nhelps the inference algorithm understand specifically which type\nyou#$%re trying to parse into.</p>\n<p><cide>parse</code> can parse into any type that implements the <a href="https://docs.rs/core/*/core/str/traits/trait.FromStr.html"><cide>FromStr</code></a> trait.</p>\n<h1 id="errors"><a class="header" href="#errors">Errors</a></h1>\n<p>Will return <a href="https://docs.rs/core/*/core/str/traits/trait.FromStr.html#associatedtype.Err"><cide>Err</code></a> if it#$%s not possible to parse this string slice into\nthe desired type.</p>\n<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>\n<p>Basic usage</p>\n<per><cide>let four: u32 = &quot;4&quot;.parse().unwrap();\n\nassert_eq!(4, four);\n</code></pre>\n<p>Using the #$%turbofish#$% instead of annotating <cide>four</code>:</p>\n<per><cide>let four = &quot;4&quot;.parse::&lt;u32&gt;();\n\nassert_eq!(Ok(4), four);\n</code></pre>\n<p>Failing to parse:</p>\n<per><cide>let nope = &quot;j&quot;.parse::&lt;u32&gt;();\n\nassert!(nope.is_err());\n</code></pre>\n','<per><cide class="language-rust">core::result::Result\n</code></pre>\n<per><cide class="language-rust">pub fn expect(self, msg: &amp;str) -&gt; T\n</code></pre>\n<hr />\n<p>Returns the contained <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Ok</code></a> value, consuming the <cide>self</code> value.</p>\n<h1 id="panics"><a class="header" href="#panics">Panics</a></h1>\n<p>Panics if the value is an <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Err</code></a>, with a panic message including the\npassed message, and the content of the <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Err</code></a>.</p>\n<h1 id="examples-1"><a class="header" href="#examples-1">Examples</a></h1>\n<p>Basic usage:</p>\n<per><cide class="language-should_panic">let x: Result&lt;u32, &amp;str&gt; = Err(&quot;emergency failure&quot;);\nx.expect(&quot;Testing expect&quot;); // panics with `Testing expect: emergency failure`\n</code></pre>\n','<per><cide class="language-rust">let x: f64\n</code></pre>\n','<per><cide class="language-rust">let y: f32\n</code></pre>\n','<per><cide class="language-rust">f32\n</code></pre>\n<hr />\n<p>A 32-bit floating point type (specifically, the &quot;binary32&quot; type defined in IEEE 754-2008).</p>\n<p>This type can represent a wide range of decimal numbers, like <cide>3.5</code>, <cide>27</code>,\n<cide>-113.75</code>, <cide>0.0078125</code>, <cide>34359738368</code>, <cide>0</code>, <cide>-1</code>. So unlike integer types\n(such as <cide>i32</code>), floating point types can represent non-integer numbers,\ntoo.</p>\n<p>However, being able to represent this wide range of numbers comes at the\ncost of precision: floats can only represent some of the real numbers and\ncalculation with floats round to a nearby representable number. For example,\n<cide>5.0</code> and <cide>1.0</code> can be exactly represented as <cide>f32</code>, but <cide>1.0 / 5.0</code> results\nin <cide>0.20000000298023223876953125</code> since <cide>0.2</code> cannot be exactly represented\nas <cide>f32</code>. Note, however, that printing floats with <cide>println</code> and friends will\noften discard insignificant digits: <cide>println!(&quot;{}&quot;, 1.0f32 / 5.0f32)</code> will\nprint <cide>0.2</code>.</p>\n<p>Additionally, <cide>f32</code> can represent some special values:</p>\n<ul>\n<li>−0.0: IEEE 754 floating point numbers have a bit that indicates their sign, so −0.0 is a\npossible value. For comparison −0.0 = +0.0, but floating point operations can carry\nthe sign bit through arithmetic operations. This means −0.0 × +0.0 produces −0.0 and\na negative number rounded to a value smaller than a float can represent also produces −0.0.</li>\n<li><a href="#associatedconstant.INFINITY">∞</a> and\n<a href="#associatedconstant.NEG_INFINITY">−∞</a>: these result from calculations\nlike <cide>1.0 / 0.0</code>.</li>\n<li><a href="#associatedconstant.NAN">NaN (not a number)</a>: this value results from\ncalculations like <cide>(-1.0).sqrt()</code>. NaN has some potentially unexpected\nbehavior: it is unequal to any float, including itself! It is also neither\nsmaller nor greater than any float, making it impossible to sort. Lastly,\nit is considered infectious as almost all calculations where one of the\noperands is NaN will also result in NaN.</li>\n</ul>\n<p>For more information on floating point numbers, see <a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">Wikipedia</a>.</p>\n<p><em><a href="crate::f32::consts">See also the <cide>std::f32::consts</code> module</a>.</em></p>\n','<per><cide class="language-rust">let sum: i32\n</code></pre>\n','<per><cide class="language-rust">let difference: f64\n</code></pre>\n','<per><cide class="language-rust">let product: i32\n</code></pre>\n','<per><cide class="language-rust">let quotient: f64\n</code></pre>\n','<per><cide class="language-rust">let floored: i32\n</code></pre>\n','<per><cide class="language-rust">let remainder: i32\n</code></pre>\n','<per><cide class="language-rust">let t: bool\n</code></pre>\n','<per><cide class="language-rust">let f: bool\n</code></pre>\n','<per><cide class="language-rust">bool\n</code></pre>\n<hr />\n<p>The boolean type.</p>\n<p>The <cide>bool</code> represents a value, which could only be either <cide>true</code> or <cide>false</code>. If you cast\na <cide>bool</code> into an integer, <cide>true</code> will be 1 and <cide>false</code> will be 0.</p>\n<h1 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h1>\n<p><cide>bool</code> implements various traits, such as <a href="ops::BitAnd"><cide>BitAnd</code></a>, <a href="ops::BitOr"><cide>BitOr</code></a>, <a href="ops::Not"><cide>Not</code></a>, etc.,\nwhich allow us to perform boolean operations using <cide>&amp;</code>, <cide>|</code> and <cide>!</code>.</p>\n<p><cide>if</code> requires a <cide>bool</code> value as its conditional. <a href="%60assert!%60"><cide>assert!</code></a>, which is an\nimportant macro in testing, checks whether an expression is <cide>true</code> and panics\nif it isn#$%t.</p>\n<per><cide>let bool_val = true &amp; false | false;\nassert!(!bool_val);\n</code></pre>\n<h1 id="examples-2"><a class="header" href="#examples-2">Examples</a></h1>\n<p>A trivial example of the usage of <cide>bool</code>:</p>\n<per><cide>let praise_the_borrow_checker = true;\n\n// using the `if` conditional\nif praise_the_borrow_checker {\n    println!(&quot;oh, yeah!&quot;);\n} else {\n    println!(&quot;what?!!&quot;);\n}\n\n// ... or, a match pattern\nmatch praise_the_borrow_checker {\n    true =&gt; println!(&quot;keep praising!&quot;),\n    false =&gt; println!(&quot;you should praise!&quot;),\n}\n</code></pre>\n<p>Also, since <cide>bool</code> implements the <a href="%60Copy%60"><cide>Copy</code></a> trait, we don#$%t\nhave to worry about the move semantics (just like the integer and float primitives).</p>\n<p>Now an example of <cide>bool</code> cast to integer type:</p>\n<per><cide>assert_eq!(true as i32, 1);\nassert_eq!(false as i32, 0);\n</code></pre>\n','<per><cide class="language-rust">let c: char\n</code></pre>\n','<per><cide class="language-rust">let z: char\n</code></pre>\n','<per><cide class="language-rust">let heart_eyed_cat: char\n</code></pre>\n','<per><cide class="language-rust">let tup: (i32, f64, u8)\n</code></pre>\n','<per><cide class="language-rust">i32\n</code></pre>\n<hr />\n<p>The 32-bit signed integer type.</p>\n','<per><cide class="language-rust">f64\n</code></pre>\n<hr />\n<p>A 64-bit floating point type (specifically, the &quot;binary64&quot; type defined in IEEE 754-2008).</p>\n<p>This type is very similar to <a href="prim@f32"><cide>f32</code></a>, but has increased\nprecision by using twice as many bits. Please see <a href="prim@f32">the documentation for\n<cide>f32</code></a> or <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">Wikipedia on double precision\nvalues</a> for more information.</p>\n<p><em><a href="crate::f64::consts">See also the <cide>std::f64::consts</code> module</a>.</em></p>\n','<per><cide class="language-rust">u8\n</code></pre>\n<hr />\n<p>The 8-bit unsigned integer type.</p>\n','<per><cide class="language-rust">let tup: (i32, f64, i32)\n</code></pre>\n','<per><cide class="language-rust">x: i32\n</code></pre>\n','<per><cide class="language-rust">y: f64\n</code></pre>\n','<per><cide class="language-rust">z: i32\n</code></pre>\n','<per><cide class="language-rust">std\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! println\n</code></pre>\n<hr />\n<p>Prints to the standard output, with a newline.</p>\n<p>On all platforms, the newline is the LINE FEED character (<cide>\n</code>/<cide>U+000A</code>) alone\n(no additional CARRIAGE RETURN (<cide>\r</code>/<cide>U+000D</code>)).</p>\n<p>Use the <a href="%60format!%60"><cide>format!</code></a> syntax to write data to the standard output.\nSee <a href="crate::fmt"><cide>std::fmt</code></a> for more information.</p>\n<p>Use <cide>println!</code> only for the primary output of your program. Use\n<a href="%60eprintln!%60"><cide>eprintln!</code></a> instead to print error and progress messages.</p>\n<h1 id="panics-1"><a class="header" href="#panics-1">Panics</a></h1>\n<p>Panics if writing to <a href="crate::io::stdout"><cide>io::stdout</code></a> fails.</p>\n<h1 id="examples-3"><a class="header" href="#examples-3">Examples</a></h1>\n<per><cide>println!(); // prints just a newline\nprintln!(&quot;hello there!&quot;);\nprintln!(&quot;format {} arguments&quot;, &quot;some&quot;);\n</code></pre>\n','<per><cide class="language-rust">let x: (i32, f64, u8)\n</code></pre>\n','<per><cide class="language-rust">let five_hundred: i32\n</code></pre>\n','<per><cide class="language-rust">let six_point_four: f64\n</code></pre>\n','<per><cide class="language-rust">let one: u8\n</code></pre>\n','<per><cide class="language-rust">let a: [i32; 5]\n</code></pre>\n','<per><cide class="language-rust">let months: [&amp;str; 12]\n</code></pre>\n','<per><cide class="language-rust">let first: i32\n</code></pre>\n','<per><cide class="language-rust">let second: i32\n</code></pre>\n','<per><cide class="language-rust">extern crate std\n</code></pre>\n<hr />\n<h1 id="the-rust-standard-library"><a class="header" href="#the-rust-standard-library">The Rust Standard Library</a></h1>\n<p>The Rust Standard Library is the foundation of portable Rust software, a\nset of minimal and battle-tested shared abstractions for the <a href="https://crates.io">broader Rust\necosystem</a>. It offers core types, like <a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a> and\n<a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>Option&lt;T&gt;</code></a>, library-defined <a href="https://docs.rs/std/*/std/index.html#primitives">operations on language\nprimitives</a>, <a href="https://docs.rs/std/*/std/index.html#macros">standard macros</a>, <a href="https://docs.rs/std/*/std/io/index.html">I/O</a> and\n<a href="https://docs.rs/std/*/std/thread/index.html">multithreading</a>, among <a href="https://docs.rs/std/*/std/index.html#what-is-in-the-standard-library-documentation">many other things</a>.</p>\n<p><cide>std</code> is available to all Rust crates by default. Therefore, the\nstandard library can be accessed in <a href="https://docs.rs/std/*/book/ch07-02-defining-modules-to-control-scope-and-privacy.html"><cide>use</code></a> statements through the path\n<cide>std</code>, as in <a href="https://docs.rs/std/*/std/env/index.html"><cide>use std::env</code></a>.</p>\n<h1 id="how-to-read-this-documentation"><a class="header" href="#how-to-read-this-documentation">How to read this documentation</a></h1>\n<p>If you already know the name of what you are looking for, the fastest way to\nfind it is to use the <!-- raw HTML omitted -->search\nbar<!-- raw HTML omitted --> at the top of the page.</p>\n<p>Otherwise, you may want to jump to one of these useful sections:</p>\n<ul>\n<li><a href="https://docs.rs/std/*/std/index.html#modules"><cide>std::*</code> modules</a></li>\n<li><a href="https://docs.rs/std/*/std/index.html#primitives">Primitive types</a></li>\n<li><a href="https://docs.rs/std/*/std/index.html#macros">Standard macros</a></li>\n<li><a href="https://docs.rs/std/*/std/prelude/index.html">The Rust Prelude</a></li>\n</ul>\n<p>If this is your first time, the documentation for the standard library is\nwritten to be casually perused. Clicking on interesting things should\ngenerally lead you to interesting places. Still, there are important bits\nyou don#$%t want to miss, so read on for a tour of the standard library and\nits documentation!</p>\n<p>Once you are familiar with the contents of the standard library you may\nbegin to find the verbosity of the prose distracting. At this stage in your\ndevelopment you may want to press the <cide>[-]</code> button near the top of the\npage to collapse it into a more skimmable view.</p>\n<p>While you are looking at that <cide>[-]</code> button also notice the <cide>[src]</code>\nbutton. Rust#$%s API documentation comes with the source code and you are\nencouraged to read it. The standard library source is generally high\nquality and a peek behind the curtains is often enlightening.</p>\n<h1 id="what-is-in-the-standard-library-documentation"><a class="header" href="#what-is-in-the-standard-library-documentation">What is in the standard library documentation?</a></h1>\n<p>First of all, The Rust Standard Library is divided into a number of focused\nmodules, <a href="https://docs.rs/std/*/std/index.html#modules">all listed further down this page</a>. These modules are\nthe bedrock upon which all of Rust is forged, and they have mighty names\nlike <a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>std::slice</code></a> and <a href="https://docs.rs/core/*/core/cmp/index.html"><cide>std::cmp</code></a>. Modules#$% documentation typically\nincludes an overview of the module along with examples, and are a smart\nplace to start familiarizing yourself with the library.</p>\n<p>Second, implicit methods on <a href="https://docs.rs/std/*/book/ch03-02-data-types.html">primitive types</a> are documented here. This can\nbe a source of confusion for two reasons:</p>\n<ol>\n<li>While primitives are implemented by the compiler, the standard library\nimplements methods directly on the primitive types (and it is the only\nlibrary that does so), which are <a href="https://docs.rs/std/*/std/index.html#primitives">documented in the section on\nprimitives</a>.</li>\n<li>The standard library exports many modules <em>with the same name as\nprimitive types</em>. These define additional items related to the primitive\ntype, but not the all-important methods.</li>\n</ol>\n<p>So for example there is a <a href="primitive::i32">page for the primitive type\n<cide>i32</code></a> that lists all the methods that can be called on\n32-bit integers (very useful), and there is a <a href="https://docs.rs/core/*/core/i32/index.html">page for the module\n<cide>std::i32</code></a> that documents the constant values <a href="https://docs.rs/core/*/core/i32/const.MIN.html"><cide>MIN</code></a> and <a href="https://docs.rs/core/*/core/i32/const.MAX.html"><cide>MAX</code></a> (rarely\nuseful).</p>\n<p>Note the documentation for the primitives <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a> and <a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>[T]</code></a> (also\ncalled #$%slice#$%). Many method calls on <a href="https://docs.rs/alloc/*/alloc/string/struct.String.html"><cide>String</code></a> and <a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a> are actually\ncalls to methods on <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a> and <a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>[T]</code></a> respectively, via <a href="https://docs.rs/std/*/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods">deref\ncoercions</a>.</p>\n<p>Third, the standard library defines <a href="https://docs.rs/std/*/std/prelude/index.html">The Rust Prelude</a>, a small collection\nof items - mostly traits - that are imported into every module of every\ncrate. The traits in the prelude are pervasive, making the prelude\ndocumentation a good entry point to learning about the library.</p>\n<p>And finally, the standard library exports a number of standard macros, and\n<a href="https://docs.rs/std/*/std/index.html#macros">lists them on this page</a> (technically, not all of the standard\nmacros are defined by the standard library - some are defined by the\ncompiler - but they are documented here the same). Like the prelude, the\nstandard macros are imported by default into all crates.</p>\n<h1 id="contributing-changes-to-the-documentation"><a class="header" href="#contributing-changes-to-the-documentation">Contributing changes to the documentation</a></h1>\n<p>Check out the rust contribution guidelines <a href="https://rustc-dev-guide.rust-lang.org/contributing.html#writing-documentation">here</a>.\nThe source for this documentation can be found on\n<a href="https://github.com/rust-lang/rust">GitHub</a>.\nTo contribute changes, make sure you read the guidelines first, then submit\npull-requests for your suggested changes.</p>\n<p>Contributions are appreciated! If you see a part of the docs that can be\nimproved, submit a PR, or chat with us first on <a href="https://discord.gg/rust-lang">Discord</a>\n#docs.</p>\n<h1 id="a-tour-of-the-rust-standard-library"><a class="header" href="#a-tour-of-the-rust-standard-library">A Tour of The Rust Standard Library</a></h1>\n<p>The rest of this crate documentation is dedicated to pointing out notable\nfeatures of The Rust Standard Library.</p>\n<h2 id="containers-and-collections"><a class="header" href="#containers-and-collections">Containers and collections</a></h2>\n<p>The <a href="https://docs.rs/core/*/core/option/index.html"><cide>option</code></a> and <a href="https://docs.rs/core/*/core/result/index.html"><cide>result</code></a> modules define optional and error-handling\ntypes, <a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>Option&lt;T&gt;</code></a> and <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Result&lt;T, E&gt;</code></a>. The <a href="https://docs.rs/core/*/core/iter/index.html"><cide>iter</code></a> module defines\nRust#$%s iterator trait, <a href="https://docs.rs/core/*/core/iter/traits/iterator/trait.Iterator.html"><cide>Iterator</code></a>, which works with the <a href="https://docs.rs/std/*/book/ch03-05-control-flow.html#looping-through-a-collection-with-for"><cide>for</code></a> loop to\naccess collections.</p>\n<p>The standard library exposes three common ways to deal with contiguous\nregions of memory:</p>\n<ul>\n<li><a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a> - A heap-allocated <em>vector</em> that is resizable at runtime.</li>\n<li><a href="https://docs.rs/core/*/core/array/index.html"><cide>[T; N]</code></a> - An inline <em>array</em> with a fixed size at compile time.</li>\n<li><a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>[T]</code></a> - A dynamically sized <em>slice</em> into any other kind of contiguous\nstorage, whether heap-allocated or not.</li>\n</ul>\n<p>Slices can only be handled through some kind of <em>pointer</em>, and as such come\nin many flavors such as:</p>\n<ul>\n<li><cide>&amp;[T]</code> - <em>shared slice</em></li>\n<li><cide>&amp;mut [T]</code> - <em>mutable slice</em></li>\n<li><a href="https://docs.rs/alloc/*/alloc/boxed/index.html"><cide>Box&lt;[T]&gt;</code></a> - <em>owned slice</em></li>\n</ul>\n<p><a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>, a UTF-8 string slice, is a primitive type, and the standard library\ndefines many methods for it. Rust <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>s are typically accessed as\nimmutable references: <cide>&amp;str</code>. Use the owned <a href="https://docs.rs/alloc/*/alloc/string/struct.String.html"><cide>String</code></a> for building and\nmutating strings.</p>\n<p>For converting to strings use the <a href="https://docs.rs/alloc/*/alloc/macro.format.html"><cide>format</code></a> macro, and for converting from\nstrings use the <a href="https://docs.rs/core/*/core/str/traits/trait.FromStr.html"><cide>FromStr</code></a> trait.</p>\n<p>Data may be shared by placing it in a reference-counted box or the <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a>\ntype, and if further contained in a <a href="https://docs.rs/core/*/core/cell/struct.Cell.html"><cide>Cell</code></a> or <a href="https://docs.rs/core/*/core/cell/struct.RefCell.html"><cide>RefCell</code></a>, may be mutated\nas well as shared. Likewise, in a concurrent setting it is common to pair an\natomically-reference-counted box, <a href="https://docs.rs/alloc/*/alloc/sync/struct.Arc.html"><cide>Arc</code></a>, with a <a href="https://docs.rs/std/*/std/sync/mutex/struct.Mutex.html"><cide>Mutex</code></a> to get the same\neffect.</p>\n<p>The <a href="https://docs.rs/std/*/std/collections/index.html"><cide>collections</code></a> module defines maps, sets, linked lists and other\ntypical collection types, including the common <a href="https://docs.rs/std/*/std/collections/hash/map/struct.HashMap.html"><cide>HashMap&lt;K, V&gt;</code></a>.</p>\n<h2 id="platform-abstractions-and-io"><a class="header" href="#platform-abstractions-and-io">Platform abstractions and I/O</a></h2>\n<p>Besides basic data types, the standard library is largely concerned with\nabstracting over differences in common platforms, most notably Windows and\nUnix derivatives.</p>\n<p>Common types of I/O, including <a href="https://docs.rs/std/*/std/fs/struct.File.html">files</a>, <a href="https://docs.rs/std/*/std/net/tcp/struct.TcpStream.html">TCP</a>, <a href="https://docs.rs/std/*/std/net/udp/struct.UdpSocket.html">UDP</a>, are defined in the\n<a href="https://docs.rs/std/*/std/io/index.html"><cide>io</code></a>, <a href="https://docs.rs/std/*/std/fs/index.html"><cide>fs</code></a>, and <a href="https://docs.rs/std/*/std/net/index.html"><cide>net</code></a> modules.</p>\n<p>The <a href="https://docs.rs/std/*/std/thread/index.html"><cide>thread</code></a> module contains Rust#$%s threading abstractions. <a href="https://docs.rs/std/*/std/sync/index.html"><cide>sync</code></a>\ncontains further primitive shared memory types, including <a href="https://docs.rs/core/*/core/sync/atomic/index.html"><cide>atomic</code></a> and\n<a href="https://docs.rs/std/*/std/sync/mpsc/index.html"><cide>mpsc</code></a>, which contains the channel types for message passing.</p>\n','<per><cide class="language-rust">std\n</code></pre>\n<per><cide class="language-rust">mod io\n</code></pre>\n<hr />\n<p>Traits, helpers, and type definitions for core I/O functionality.</p>\n<p>The <cide>std::io</code> module contains a number of common things you#$%ll need\nwhen doing input and output. The most core part of this module is\nthe <a href="https://docs.rs/std/*/std/io/trait.Read.html"><cide>Read</code></a> and <a href="https://docs.rs/std/*/std/io/trait.Write.html"><cide>Write</code></a> traits, which provide the\nmost general interface for reading and writing input and output.</p>\n<h1 id="read-and-write"><a class="header" href="#read-and-write">Read and Write</a></h1>\n<p>Because they are traits, <a href="https://docs.rs/std/*/std/io/trait.Read.html"><cide>Read</code></a> and <a href="https://docs.rs/std/*/std/io/trait.Write.html"><cide>Write</code></a> are implemented by a number\nof other types, and you can implement them for your types too. As such,\nyou#$%ll see a few different types of I/O throughout the documentation in\nthis module: <a href="https://docs.rs/std/*/std/fs/struct.File.html"><cide>File</code></a>s, <a href="https://docs.rs/std/*/std/net/tcp/struct.TcpStream.html"><cide>TcpStream</code></a>s, and sometimes even <a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a>s. For\nexample, <a href="https://docs.rs/std/*/std/io/trait.Read.html"><cide>Read</code></a> adds a <a href="https://docs.rs/std/*/std/io/trait.Read.html#tymethod.read"><cide>read</code></a> method, which we can use on\n<a href="https://docs.rs/std/*/std/fs/struct.File.html"><cide>File</code></a>s:</p>\n<per><cide class="language-no_run">use std::io;\nuse std::io::prelude::*;\nuse std::fs::File;\n\nfn main() -&gt; io::Result&lt;()&gt; {\n    let mut f = File::open(&quot;foo.txt&quot;)?;\n    let mut buffer = [0; 10];\n\n    // read up to 10 bytes\n    let n = f.read(&amp;mut buffer)?;\n\n    println!(&quot;The bytes: {:?}&quot;, &amp;buffer[..n]);\n    Ok(())\n}\n</code></pre>\n<p><a href="https://docs.rs/std/*/std/io/trait.Read.html"><cide>Read</code></a> and <a href="https://docs.rs/std/*/std/io/trait.Write.html"><cide>Write</code></a> are so important, implementors of the two traits have a\nnickname: readers and writers. So you#$%ll sometimes see #$%a reader#$% instead\nof #$%a type that implements the <a href="https://docs.rs/std/*/std/io/trait.Read.html"><cide>Read</code></a> trait#$%. Much easier!</p>\n<h2 id="seek-and-bufread"><a class="header" href="#seek-and-bufread">Seek and BufRead</a></h2>\n<p>Beyond that, there are two important traits that are provided: <a href="https://docs.rs/std/*/std/io/trait.Seek.html"><cide>Seek</code></a>\nand <a href="https://docs.rs/std/*/std/io/trait.BufRead.html"><cide>BufRead</code></a>. Both of these build on top of a reader to control\nhow the reading happens. <a href="https://docs.rs/std/*/std/io/trait.Seek.html"><cide>Seek</code></a> lets you control where the next byte is\ncoming from:</p>\n<per><cide class="language-no_run">use std::io;\nuse std::io::prelude::*;\nuse std::io::SeekFrom;\nuse std::fs::File;\n\nfn main() -&gt; io::Result&lt;()&gt; {\n    let mut f = File::open(&quot;foo.txt&quot;)?;\n    let mut buffer = [0; 10];\n\n    // skip to the last 10 bytes of the file\n    f.seek(SeekFrom::End(-10))?;\n\n    // read up to 10 bytes\n    let n = f.read(&amp;mut buffer)?;\n\n    println!(&quot;The bytes: {:?}&quot;, &amp;buffer[..n]);\n    Ok(())\n}\n</code></pre>\n<p><a href="https://docs.rs/std/*/std/io/trait.BufRead.html"><cide>BufRead</code></a> uses an internal buffer to provide a number of other ways to read, but\nto show it off, we#$%ll need to talk about buffers in general. Keep reading!</p>\n<h2 id="bufreader-and-bufwriter"><a class="header" href="#bufreader-and-bufwriter">BufReader and BufWriter</a></h2>\n<p>Byte-based interfaces are unwieldy and can be inefficient, as we#$%d need to be\nmaking near-constant calls to the operating system. To help with this,\n<cide>std::io</code> comes with two structs, <a href="https://docs.rs/std/*/std/io/buffered/bufreader/struct.BufReader.html"><cide>BufReader</code></a> and <a href="https://docs.rs/std/*/std/io/buffered/bufwriter/struct.BufWriter.html"><cide>BufWriter</code></a>, which wrap\nreaders and writers. The wrapper uses a buffer, reducing the number of\ncalls and providing nicer methods for accessing exactly what you want.</p>\n<p>For example, <a href="https://docs.rs/std/*/std/io/buffered/bufreader/struct.BufReader.html"><cide>BufReader</code></a> works with the <a href="https://docs.rs/std/*/std/io/trait.BufRead.html"><cide>BufRead</code></a> trait to add extra\nmethods to any reader:</p>\n<per><cide class="language-no_run">use std::io;\nuse std::io::prelude::*;\nuse std::io::BufReader;\nuse std::fs::File;\n\nfn main() -&gt; io::Result&lt;()&gt; {\n    let f = File::open(&quot;foo.txt&quot;)?;\n    let mut reader = BufReader::new(f);\n    let mut buffer = String::new();\n\n    // read a line into buffer\n    reader.read_line(&amp;mut buffer)?;\n\n    println!(&quot;{}&quot;, buffer);\n    Ok(())\n}\n</code></pre>\n<p><a href="https://docs.rs/std/*/std/io/buffered/bufwriter/struct.BufWriter.html"><cide>BufWriter</code></a> doesn#$%t add any new ways of writing; it just buffers every call\nto <a href="https://docs.rs/std/*/std/io/trait.Write.html#tymethod.write"><cide>write</code></a>:</p>\n<per><cide class="language-no_run">use std::io;\nuse std::io::prelude::*;\nuse std::io::BufWriter;\nuse std::fs::File;\n\nfn main() -&gt; io::Result&lt;()&gt; {\n    let f = File::create(&quot;foo.txt&quot;)?;\n    {\n        let mut writer = BufWriter::new(f);\n\n        // write a byte to the buffer\n        writer.write(&amp;[42])?;\n\n    } // the buffer is flushed once writer goes out of scope\n\n    Ok(())\n}\n</code></pre>\n<h2 id="standard-input-and-output"><a class="header" href="#standard-input-and-output">Standard input and output</a></h2>\n<p>A very common source of input is standard input:</p>\n<per><cide class="language-no_run">use std::io;\n\nfn main() -&gt; io::Result&lt;()&gt; {\n    let mut input = String::new();\n\n    io::stdin().read_line(&amp;mut input)?;\n\n    println!(&quot;You typed: {}&quot;, input.trim());\n    Ok(())\n}\n</code></pre>\n<p>Note that you cannot use the <a href="https://docs.rs/std/*/book/appendix-02-operators.html"><cide>?</code> operator</a> in functions that do not return\na <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Result&lt;T, E&gt;</code></a>. Instead, you can call <a href="crate::result::Result::unwrap"><cide>.unwrap()</code></a>\nor <cide>match</code> on the return value to catch any possible errors:</p>\n<per><cide class="language-no_run">use std::io;\n\nlet mut input = String::new();\n\nio::stdin().read_line(&amp;mut input).unwrap();\n</code></pre>\n<p>And a very common source of output is standard output:</p>\n<per><cide class="language-no_run">use std::io;\nuse std::io::prelude::*;\n\nfn main() -&gt; io::Result&lt;()&gt; {\n    io::stdout().write(&amp;[42])?;\n    Ok(())\n}\n</code></pre>\n<p>Of course, using <a href="https://docs.rs/std/*/std/io/stdio/fn.stdout.html"><cide>io::stdout</code></a> directly is less common than something like\n<a href="https://docs.rs/std/*/std/macro.println.html"><cide>println</code></a>.</p>\n<h2 id="iterator-types"><a class="header" href="#iterator-types">Iterator types</a></h2>\n<p>A large number of the structures provided by <cide>std::io</code> are for various\nways of iterating over I/O. For example, <a href="https://docs.rs/std/*/std/io/struct.Lines.html"><cide>Lines</code></a> is used to split over\nlines:</p>\n<per><cide class="language-no_run">use std::io;\nuse std::io::prelude::*;\nuse std::io::BufReader;\nuse std::fs::File;\n\nfn main() -&gt; io::Result&lt;()&gt; {\n    let f = File::open(&quot;foo.txt&quot;)?;\n    let reader = BufReader::new(f);\n\n    for line in reader.lines() {\n        println!(&quot;{}&quot;, line?);\n    }\n    Ok(())\n}\n</code></pre>\n<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>\n<p>There are a number of <a href="https://docs.rs/std/*/std/io/index.html#functions-1">functions</a> that offer access to various\nfeatures. For example, we can use three of these functions to copy everything\nfrom standard input to standard output:</p>\n<per><cide class="language-no_run">use std::io;\n\nfn main() -&gt; io::Result&lt;()&gt; {\n    io::copy(&amp;mut io::stdin(), &amp;mut io::stdout())?;\n    Ok(())\n}\n</code></pre>\n<h2 id="ioresult"><a class="header" href="#ioresult">io::Result</a></h2>\n<p>Last, but certainly not least, is <a href="https://docs.rs/std/*/std/io/error/type.Result.html"><cide>io::Result</code></a>. This type is used\nas the return type of many <cide>std::io</code> functions that can cause an error, and\ncan be returned from your own functions as well. Many of the examples in this\nmodule use the <a href="https://docs.rs/std/*/book/appendix-02-operators.html"><cide>?</code> operator</a>:</p>\n<per><cide>use std::io;\n\nfn read_input() -&gt; io::Result&lt;()&gt; {\n    let mut input = String::new();\n\n    io::stdin().read_line(&amp;mut input)?;\n\n    println!(&quot;You typed: {}&quot;, input.trim());\n\n    Ok(())\n}\n</code></pre>\n<p>The return type of <cide>read_input()</code>, <a href="https://docs.rs/std/*/std/io/error/type.Result.html"><cide>io::Result&lt;()&gt;</code></a>, is a very\ncommon type for functions which don#$%t have a #$%real#$% return value, but do want to\nreturn errors if they happen. In this case, the only purpose of this function is\nto read the line and print it, so we use <cide>()</code>.</p>\n<h2 id="platform-specific-behavior"><a class="header" href="#platform-specific-behavior">Platform-specific behavior</a></h2>\n<p>Many I/O functions throughout the standard library are documented to indicate\nwhat various library or syscalls they are delegated to. This is done to help\napplications both understand what#$%s happening under the hood as well as investigate\nany possibly unclear semantics. Note, however, that this is informative, not a binding\ncontract. The implementation of many of these functions are subject to change over\ntime and may call fewer or more syscalls/library functions.</p>\n','<per><cide class="language-rust">let mut index: String\n</code></pre>\n','<per><cide class="language-rust">alloc::string\n</code></pre>\n<per><cide class="language-rust">pub struct String\n</code></pre>\n<hr />\n<p>A UTF-8–encoded, growable string.</p>\n<p>The <cide>String</code> type is the most common string type that has ownership over the\ncontents of the string. It has a close relationship with its borrowed\ncounterpart, the primitive <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>.</p>\n<h1 id="examples-4"><a class="header" href="#examples-4">Examples</a></h1>\n<p>You can create a <cide>String</code> from <a href="https://docs.rs/alloc/*/alloc/str/index.html">a literal string</a> with <a href="https://docs.rs/core/*/core/convert/trait.From.html#tymethod.from"><cide>String::from</code></a>:</p>\n<per><cide>let hello = String::from(&quot;Hello, world!&quot;);\n</code></pre>\n<p>You can append a <a href="%60char%60"><cide>char</code></a> to a <cide>String</code> with the <a href="String::push"><cide>push</code></a> method, and\nappend a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a> with the <a href="String::push_str"><cide>push_str</code></a> method:</p>\n<per><cide>let mut hello = String::from(&quot;Hello, &quot;);\n\nhello.push(#$%w#$%);\nhello.push_str(&quot;orld!&quot;);\n</code></pre>\n<p>If you have a vector of UTF-8 bytes, you can create a <cide>String</code> from it with\nthe <a href="String::from_utf8"><cide>from_utf8</code></a> method:</p>\n<per><cide>// some bytes, in a vector\nlet sparkle_heart = vec![240, 159, 146, 150];\n\n// We know these bytes are valid, so we#$%ll use `unwrap()`.\nlet sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n\nassert_eq!(&quot;💖&quot;, sparkle_heart);\n</code></pre>\n<h1 id="utf-8"><a class="header" href="#utf-8">UTF-8</a></h1>\n<p><cide>String</code>s are always valid UTF-8. This has a few implications, the first of\nwhich is that if you need a non-UTF-8 string, consider <a href="https://docs.rs/alloc/*/std/ffi/struct.OsString.html"><cide>OsString</code></a>. It is\nsimilar, but without the UTF-8 constraint. The second implication is that\nyou cannot index into a <cide>String</code>:</p>\n<per><cide class="language-compile_fail,E0277">let s = &quot;hello&quot;;\n\nprintln!(&quot;The first letter of s is {}&quot;, s[0]); // ERROR!!!\n</code></pre>\n<p>Indexing is intended to be a constant-time operation, but UTF-8 encoding\ndoes not allow us to do this. Furthermore, it#$%s not clear what sort of\nthing the index should return: a byte, a codepoint, or a grapheme cluster.\nThe <a href="str::bytes"><cide>bytes</code></a> and <a href="str::chars"><cide>chars</code></a> methods return iterators over the first\ntwo, respectively.</p>\n<h1 id="deref"><a class="header" href="#deref">Deref</a></h1>\n<p><cide>String</code>s implement <a href="https://docs.rs/core/*/core/ops/deref/trait.Deref.html"><cide>Deref</code></a><cide>&lt;Target=str&gt;</code>, and so inherit all of <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>#$%s\nmethods. In addition, this means that you can pass a <cide>String</code> to a\nfunction which takes a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a> by using an ampersand (<cide>&amp;</code>):</p>\n<per><cide>fn takes_str(s: &amp;str) { }\n\nlet s = String::from(&quot;Hello&quot;);\n\ntakes_str(&amp;s);\n</code></pre>\n<p>This will create a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a> from the <cide>String</code> and pass it in. This\nconversion is very inexpensive, and so generally, functions will accept\n<a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a>s as arguments unless they need a <cide>String</code> for some specific\nreason.</p>\n<p>In certain cases Rust doesn#$%t have enough information to make this\nconversion, known as <a href="https://docs.rs/core/*/core/ops/deref/trait.Deref.html"><cide>Deref</code></a> coercion. In the following example a string\nslice <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;#$%a str</code></a> implements the trait <cide>TraitExample</code>, and the function\n<cide>example_func</code> takes anything that implements the trait. In this case Rust\nwould need to make two implicit conversions, which Rust doesn#$%t have the\nmeans to do. For that reason, the following example will not compile.</p>\n<per><cide class="language-compile_fail,E0277">trait TraitExample {}\n\nimpl&lt;#$%a&gt; TraitExample for &amp;#$%a str {}\n\nfn example_func&lt;A: TraitExample&gt;(example_arg: A) {}\n\nlet example_string = String::from(&quot;example_string&quot;);\nexample_func(&amp;example_string);\n</code></pre>\n<p>There are two options that would work instead. The first would be to\nchange the line <cide>example_func(&amp;example_string);</code> to\n<cide>example_func(example_string.as_str());</code>, using the method <a href="String::as_str"><cide>as_str()</code></a>\nto explicitly extract the string slice containing the string. The second\nway changes <cide>example_func(&amp;example_string);</code> to\n<cide>example_func(&amp;*example_string);</code>. In this case we are dereferencing a\n<cide>String</code> to a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>, then referencing the <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a> back to\n<a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a>. The second way is more idiomatic, however both work to do the\nconversion explicitly rather than relying on the implicit conversion.</p>\n<h1 id="representation"><a class="header" href="#representation">Representation</a></h1>\n<p>A <cide>String</code> is made up of three components: a pointer to some bytes, a\nlength, and a capacity. The pointer points to an internal buffer <cide>String</code>\nuses to store its data. The length is the number of bytes currently stored\nin the buffer, and the capacity is the size of the buffer in bytes. As such,\nthe length will always be less than or equal to the capacity.</p>\n<p>This buffer is always stored on the heap.</p>\n<p>You can look at these with the <a href="str::as_ptr"><cide>as_ptr</code></a>, <a href="String::len"><cide>len</code></a>, and <a href="String::capacity"><cide>capacity</code></a>\nmethods:</p>\n<per><cide>use std::mem;\n\nlet story = String::from(&quot;Once upon a time...&quot;);\n\n// Prevent automatically dropping the String#$%s data\nlet mut story = mem::ManuallyDrop::new(story);\n\nlet ptr = story.as_mut_ptr();\nlet len = story.len();\nlet capacity = story.capacity();\n\n// story has nineteen bytes\nassert_eq!(19, len);\n\n// We can re-build a String out of ptr, len, and capacity. This is all\n// unsafe because we are responsible for making sure the components are\n// valid:\nlet s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;\n\nassert_eq!(String::from(&quot;Once upon a time...&quot;), s);\n</code></pre>\n<p>If a <cide>String</code> has enough capacity, adding elements to it will not\nre-allocate. For example, consider this program:</p>\n<per><cide>let mut s = String::new();\n\nprintln!(&quot;{}&quot;, s.capacity());\n\nfor _ in 0..5 {\n    s.push_str(&quot;hello&quot;);\n    println!(&quot;{}&quot;, s.capacity());\n}\n</code></pre>\n<p>This will output the following:</p>\n<per><cide class="language-text">0\n5\n10\n20\n20\n40\n</code></pre>\n<p>At first, we have no memory allocated at all, but as we append to the\nstring, it increases its capacity appropriately. If we instead use the\n<a href="String::with_capacity"><cide>with_capacity</code></a> method to allocate the correct capacity initially:</p>\n<per><cide>let mut s = String::with_capacity(25);\n\nprintln!(&quot;{}&quot;, s.capacity());\n\nfor _ in 0..5 {\n    s.push_str(&quot;hello&quot;);\n    println!(&quot;{}&quot;, s.capacity());\n}\n</code></pre>\n<p>We end up with a different output:</p>\n<per><cide class="language-text">25\n25\n25\n25\n25\n25\n</code></pre>\n<p>Here, there#$%s no need to allocate more memory inside the loop.</p>\n','<per><cide class="language-rust">alloc::string::String\n</code></pre>\n<per><cide class="language-rust">pub const fn new() -&gt; String\n</code></pre>\n<hr />\n<p>Creates a new empty <cide>String</code>.</p>\n<p>Given that the <cide>String</code> is empty, this will not allocate any initial\nbuffer. While that means that this initial operation is very\ninexpensive, it may cause excessive allocation later when you add\ndata. If you have an idea of how much data the <cide>String</code> will hold,\nconsider the <a href="String::with_capacity"><cide>with_capacity</code></a> method to prevent excessive\nre-allocation.</p>\n<h1 id="examples-5"><a class="header" href="#examples-5">Examples</a></h1>\n<p>Basic usage:</p>\n<per><cide>let s = String::new();\n</code></pre>\n','<per><cide class="language-rust">std::io::stdio\n</code></pre>\n<per><cide class="language-rust">pub fn stdin() -&gt; Stdin\n</code></pre>\n<hr />\n<p>Constructs a new handle to the standard input of the current process.</p>\n<p>Each handle returned is a reference to a shared global buffer whose access\nis synchronized via a mutex. If you need more explicit control over\nlocking, see the <a href="%60Stdin::lock%60"><cide>Stdin::lock</code></a> method.</p>\n<h3 id="note-windows-portability-consideration"><a class="header" href="#note-windows-portability-consideration">Note: Windows Portability Consideration</a></h3>\n<p>When operating in a console, the Windows implementation of this stream does not support\nnon-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\nan error.</p>\n<h1 id="examples-6"><a class="header" href="#examples-6">Examples</a></h1>\n<p>Using implicit synchronization:</p>\n<per><cide class="language-no_run">use std::io::{self, Read};\n\nfn main() -&gt; io::Result&lt;()&gt; {\n    let mut buffer = String::new();\n    io::stdin().read_to_string(&amp;mut buffer)?;\n    Ok(())\n}\n</code></pre>\n<p>Using explicit synchronization:</p>\n<per><cide class="language-no_run">use std::io::{self, Read};\n\nfn main() -&gt; io::Result&lt;()&gt; {\n    let mut buffer = String::new();\n    let stdin = io::stdin();\n    let mut handle = stdin.lock();\n\n    handle.read_to_string(&amp;mut buffer)?;\n    Ok(())\n}\n</code></pre>\n','<per><cide class="language-rust">std::io::stdio::Stdin\n</code></pre>\n<per><cide class="language-rust">pub fn read_line(&amp;self, buf: &amp;mut String) -&gt; io::Result&lt;usize&gt;\n</code></pre>\n<hr />\n<p>Locks this handle and reads a line of input, appending it to the specified buffer.</p>\n<p>For detailed semantics of this method, see the documentation on\n<a href="https://docs.rs/std/*/std/io/trait.BufRead.html#method.read_line"><cide>BufRead::read_line</code></a>.</p>\n<h1 id="examples-7"><a class="header" href="#examples-7">Examples</a></h1>\n<per><cide class="language-no_run">use std::io;\n\nlet mut input = String::new();\nmatch io::stdin().read_line(&amp;mut input) {\n    Ok(n) =&gt; {\n        println!(&quot;{} bytes read&quot;, n);\n        println!(&quot;{}&quot;, input);\n    }\n    Err(error) =&gt; println!(&quot;error: {}&quot;, error),\n}\n</code></pre>\n<p>You can run the example one of two ways:</p>\n<ul>\n<li>Pipe some text to it, e.g., <cide>printf foo | path/to/executable</code></li>\n<li>Give it text interactively by running the executable directly,\nin which case it will wait for the Enter key to be pressed before\ncontinuing</li>\n</ul>\n','<per><cide class="language-rust">let index: usize\n</code></pre>\n','<per><cide class="language-rust">usize\n</code></pre>\n<hr />\n<p>The pointer-sized unsigned integer type.</p>\n<p>The size of this primitive is how many bytes it takes to reference any\nlocation in memory. For example, on a 32 bit target, this is 4 bytes\nand on a 64 bit target, this is 8 bytes.</p>\n','<per><cide class="language-rust">core::str\n</code></pre>\n<per><cide class="language-rust">pub fn trim(&amp;self) -&gt; &amp;str\n</code></pre>\n<hr />\n<p>Returns a string slice with leading and trailing whitespace removed.</p>\n<p>#$%Whitespace#$% is defined according to the terms of the Unicode Derived\nCore Property <cide>White_Space</code>.</p>\n<h1 id="examples-8"><a class="header" href="#examples-8">Examples</a></h1>\n<p>Basic usage:</p>\n<per><cide>let s = &quot; Hello\tworld\t&quot;;\n\nassert_eq!(&quot;Hello\tworld&quot;, s.trim());\n</code></pre>\n','<per><cide class="language-rust">let element: i32\n</code></pre>\n',].map((x)=>x.replaceAll('#$%', "'").replaceAll('<per', '<pre').replaceAll('<cide', '<code'));
    window.onload = () => {
        console.log("hello");
        tippy('.ra', {
            content: (x) => {
                const div = document.createElement('div');
                div.innerHTML = hoverData[x.dataset.hover];
                div.className = 'hover-holder';
                div.querySelectorAll('code').forEach((y) => y.innerHTML = hljs.highlight('rust', y.innerText).value);
                return div;
            },
            allowHTML: true,
            delay: [200, 0],
            interactive: true,
            maxWidth: '80vw',
            appendTo: document.querySelector('.content'),
        });
    };
</script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="ch03-01-variables-and-mutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="ch03-03-how-functions-work.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="ch03-01-variables-and-mutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="ch03-03-how-functions-work.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="ferris.js"></script>
        
        
    </body>
</html>
