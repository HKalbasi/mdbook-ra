<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Defining and Instantiating Structs - The Rust Programming Language</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="ferris.css">
                <link rel="stylesheet" href="theme/2018-edition.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References and Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> The Slice Type</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html" class="active"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> How to Write Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlling How Tests Are Run</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.inlay-hint, .inlay-hint * {
    border-radius: .4em;
}

.light .inlay-hint, .rust .inlay-hint {
    background-color: #dcc;
    color: #777;
}

.ayu .inlay-hint, .navy .inlay-hint, .coal .inlay-hint {
    background-color: #444;
    color: #999;
}

.inlay-hint {
    font-size: 0.8em;
    user-select: none;
}
.hover-holder {
    max-height: 40vh;
    overflow: auto;
}

.tippy-content {
    background-color: var(--bg);
    color: var(--fg);
}
</style>## Defining and Instantiating Structs
<p>Structs are similar to tuples, which were discussed in <a href="ch03-02-data-types.html#the-tuple-type">“The Tuple
Type”</a><!-- ignore --> section. Like tuples, the pieces of a struct can
be different types. Unlike with tuples, you’ll name each piece of data so it’s
clear what the values mean. As a result of these names, structs are more
flexible than tuples: you don’t have to rely on the order of the data to
specify or access the values of an instance.</p>
<p>To define a struct, we enter the keyword <code>struct</code> and name the entire struct. A
struct’s name should describe the significance of the pieces of data being
grouped together. Then, inside curly brackets, we define the names and types of
the pieces of data, which we call <em>fields</em>. For example, Listing 5-1 shows a
struct that stores information about a user account.</p>
<pre><pre class="playground"><code class="language-rust hljs">struct <span class="ra" data-hover="0">User</span> {
    <span class="ra" data-hover="1">active</span>: <span class="ra" data-hover="2">bool</span>,
    <span class="ra" data-hover="3">username</span>: <span class="ra" data-hover="4">String</span>,
    <span class="ra" data-hover="5">email</span>: <span class="ra" data-hover="4">String</span>,
    <span class="ra" data-hover="6">sign_in_count</span>: <span class="ra" data-hover="7">u64</span>,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span>
</code></pre></pre>
<p><span class="caption">Listing 5-1: A <code>User</code> struct definition</span></p>
<p>To use a struct after we’ve defined it, we create an <em>instance</em> of that struct
by specifying concrete values for each of the fields. We create an instance by
stating the name of the struct and then add curly brackets containing <code>key: value</code> pairs, where the keys are the names of the fields and the values are the
data we want to store in those fields. We don’t have to specify the fields in
the same order in which we declared them in the struct. In other words, the
struct definition is like a general template for the type, and instances fill
in that template with particular data to create values of the type. For
example, we can declare a particular user as shown in Listing 5-2.</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let <span class="ra" data-hover="9">user1</span><span class="inlay-hint">: User</span> = <span class="ra" data-hover="0">User</span> {
        <span class="ra" data-hover="5">email</span>: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="10">from</span>("someone@example.com"),
        <span class="ra" data-hover="3">username</span>: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="10">from</span>("someusername123"),
        <span class="ra" data-hover="1">active</span>: true,
        <span class="ra" data-hover="6">sign_in_count</span>: 1,
    };
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 5-2: Creating an instance of the <code>User</code>
struct</span></p>
<p>To get a specific value from a struct, we can use dot notation. If we wanted
just this user’s email address, we could use <code>user1.email</code> wherever we wanted
to use this value. If the instance is mutable, we can change a value by using
the dot notation and assigning into a particular field. Listing 5-3 shows how
to change the value in the <code>email</code> field of a mutable <code>User</code> instance.</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let mut <span class="ra" data-hover="11">user1</span><span class="inlay-hint">: User</span> = <span class="ra" data-hover="0">User</span> {
        <span class="ra" data-hover="5">email</span>: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="10">from</span>("someone@example.com"),
        <span class="ra" data-hover="3">username</span>: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="10">from</span>("someusername123"),
        <span class="ra" data-hover="1">active</span>: true,
        <span class="ra" data-hover="6">sign_in_count</span>: 1,
    };

    <span class="ra" data-hover="11">user1</span>.<span class="ra" data-hover="5">email</span> = <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="10">from</span>("anotheremail@example.com");
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 5-3: Changing the value in the <code>email</code> field of a
<code>User</code> instance</span></p>
<p>Note that the entire instance must be mutable; Rust doesn’t allow us to mark
only certain fields as mutable. As with any expression, we can construct a new
instance of the struct as the last expression in the function body to
implicitly return that new instance.</p>
<p>Listing 5-4 shows a <code>build_user</code> function that returns a <code>User</code> instance with
the given email and username. The <code>active</code> field gets the value of <code>true</code>, and
the <code>sign_in_count</code> gets a value of <code>1</code>.</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn <span class="ra" data-hover="12">build_user</span>(<span class="ra" data-hover="13">email</span>: <span class="ra" data-hover="4">String</span>, <span class="ra" data-hover="14">username</span>: <span class="ra" data-hover="4">String</span>) -&gt; <span class="ra" data-hover="0">User</span> {
    <span class="ra" data-hover="0">User</span> {
        <span class="ra" data-hover="5">email</span>: <span class="ra" data-hover="13">email</span>,
        <span class="ra" data-hover="3">username</span>: <span class="ra" data-hover="14">username</span>,
        <span class="ra" data-hover="1">active</span>: true,
        <span class="ra" data-hover="6">sign_in_count</span>: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 5-4: A <code>build_user</code> function that takes an email
and username and returns a <code>User</code> instance</span></p>
<p>It makes sense to name the function parameters with the same name as the struct
fields, but having to repeat the <code>email</code> and <code>username</code> field names and
variables is a bit tedious. If the struct had more fields, repeating each name
would get even more annoying. Luckily, there’s a convenient shorthand!</p>
<h3 id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name"><a class="header" href="#using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name">Using the Field Init Shorthand when Variables and Fields Have the Same Name</a></h3>
<p>Because the parameter names and the struct field names are exactly the same in
Listing 5-4, we can use the <em>field init shorthand</em> syntax to rewrite
<code>build_user</code> so that it behaves exactly the same but doesn’t have the
repetition of <code>email</code> and <code>username</code>, as shown in Listing 5-5.</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span>fn <span class="ra" data-hover="12">build_user</span>(<span class="ra" data-hover="13">email</span>: <span class="ra" data-hover="4">String</span>, <span class="ra" data-hover="14">username</span>: <span class="ra" data-hover="4">String</span>) -&gt; <span class="ra" data-hover="0">User</span> {
    <span class="ra" data-hover="0">User</span> {
        email,
        username,
        <span class="ra" data-hover="1">active</span>: true,
        <span class="ra" data-hover="6">sign_in_count</span>: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from("someone@example.com"),
</span><span class="boring">        String::from("someusername123"),
</span><span class="boring">    );
</span><span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 5-5: A <code>build_user</code> function that uses field init
shorthand because the <code>email</code> and <code>username</code> parameters have the same name as
struct fields</span></p>
<p>Here, we’re creating a new instance of the <code>User</code> struct, which has a field
named <code>email</code>. We want to set the <code>email</code> field’s value to the value in the
<code>email</code> parameter of the <code>build_user</code> function. Because the <code>email</code> field and
the <code>email</code> parameter have the same name, we only need to write <code>email</code> rather
than <code>email: email</code>.</p>
<h3 id="creating-instances-from-other-instances-with-struct-update-syntax"><a class="header" href="#creating-instances-from-other-instances-with-struct-update-syntax">Creating Instances From Other Instances With Struct Update Syntax</a></h3>
<p>It’s often useful to create a new instance of a struct that uses most of an old
instance’s values but changes some. You can do this using <em>struct update
syntax</em>.</p>
<p>First, Listing 5-6 shows how we create a new <code>User</code> instance in <code>user2</code> without
the update syntax. We set a new value for <code>email</code> but otherwise use the same
values from <code>user1</code> that we created in Listing 5-2.</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let <span class="ra" data-hover="15">user2</span><span class="inlay-hint">: User</span> = <span class="ra" data-hover="0">User</span> {
        <span class="ra" data-hover="1">active</span>: <span class="ra" data-hover="9">user1</span>.<span class="ra" data-hover="1">active</span>,
        <span class="ra" data-hover="3">username</span>: <span class="ra" data-hover="9">user1</span>.<span class="ra" data-hover="3">username</span>,
        <span class="ra" data-hover="5">email</span>: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="10">from</span>("another@example.com"),
        <span class="ra" data-hover="6">sign_in_count</span>: <span class="ra" data-hover="9">user1</span>.<span class="ra" data-hover="6">sign_in_count</span>,
    };
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 5-6: Creating a new <code>User</code> instance using one of
the values from <code>user1</code></span></p>
<p>Using struct update syntax, we can achieve the same effect with less code, as
shown in Listing 5-7. The syntax <code>..</code> specifies that the remaining fields not
explicitly set should have the same value as the fields in the given instance.</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">struct User {
</span><span class="boring">    active: bool,
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from("someone@example.com"),
</span><span class="boring">        username: String::from("someusername123"),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let <span class="ra" data-hover="15">user2</span><span class="inlay-hint">: User</span> = <span class="ra" data-hover="0">User</span> {
        <span class="ra" data-hover="5">email</span>: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="10">from</span>("another@example.com"),
        ..<span class="ra" data-hover="9">user1
    };
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 5-7: Using struct update syntax to set a new
<code>email</code> value for a <code>User</code> instance but use the rest of the values from
<code>user1</code></span></p>
<p>The code in Listing 5-7 also creates an instance in <code>user2</code> that has a
different value for <code>email</code> but has the same values for the <code>username</code>,
<code>active</code>, and <code>sign_in_count</code> fields from <code>user1</code>. The <code>..user1</code> must come last
to specify that any remaining fields should get their values from the
corresponding fields in <code>user1</code>, but we can choose to specify values for as
many fields as we want in any order, regardless of the order of the fields in
the struct’s definition.</p>
<p>Note that the struct update syntax is like assignment with <code>=</code> because it moves
the data, just as we saw in the <a href="ch04-01-what-is-ownership.html#ways-variables-and-data-interact-move">“Ways Variables and Data Interact: Move”
section</a><!-- ignore -->. In this example, we can no longer use <code>user1</code>
after creating <code>user2</code> because the <code>String</code> in the <code>username</code> field of <code>user1</code>
was moved into <code>user2</code>. If we had given <code>user2</code> new <code>String</code> values for both
<code>email</code> and <code>username</code>, and thus only used the <code>active</code> and <code>sign_in_count</code>
values from <code>user1</code>, then <code>user1</code> would still be valid after creating <code>user2</code>.
The types of <code>active</code> and <code>sign_in_count</code> are types that implement the <code>Copy</code>
trait, so the behavior we discussed in the <a href="ch04-01-what-is-ownership.html#stack-only-data-copy">“Stack-Only Data: Copy”
section</a><!-- ignore --> would apply.</p>
<h3 id="using-tuple-structs-without-named-fields-to-create-different-types"><a class="header" href="#using-tuple-structs-without-named-fields-to-create-different-types">Using Tuple Structs without Named Fields to Create Different Types</a></h3>
<p>You can also define structs that look similar to tuples, called <em>tuple
structs</em>. Tuple structs have the added meaning the struct name provides but
don’t have names associated with their fields; rather, they just have the types
of the fields. Tuple structs are useful when you want to give the whole tuple a
name and make the tuple be a different type from other tuples, and naming each
field as in a regular struct would be verbose or redundant.</p>
<p>To define a tuple struct, start with the <code>struct</code> keyword and the struct name
followed by the types in the tuple. For example, here are definitions and
usages of two tuple structs named <code>Color</code> and <code>Point</code>:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">fn main() {
</span>    struct <span class="ra" data-hover="16">Color</span>(<span class="ra" data-hover="17">i32</span>, <span class="ra" data-hover="17">i32</span>, <span class="ra" data-hover="17">i32</span>);
    struct <span class="ra" data-hover="18">Point</span>(<span class="ra" data-hover="17">i32</span>, <span class="ra" data-hover="17">i32</span>, <span class="ra" data-hover="17">i32</span>);

    let <span class="ra" data-hover="19">black</span> = <span class="ra" data-hover="16">Color</span>(0, 0, 0);
    let <span class="ra" data-hover="20">origin</span> = <span class="ra" data-hover="18">Point</span>(0, 0, 0);
<span class="boring">}
</span>
</code></pre></pre>
<p>Note that the <code>black</code> and <code>origin</code> values are different types, because they’re
instances of different tuple structs. Each struct you define is its own type,
even though the fields within the struct have the same types. For example, a
function that takes a parameter of type <code>Color</code> cannot take a <code>Point</code> as an
argument, even though both types are made up of three <code>i32</code> values. Otherwise,
tuple struct instances behave like tuples: you can destructure them into their
individual pieces, you can use a <code>.</code> followed by the index to access an
individual value, and so on.</p>
<h3 id="unit-like-structs-without-any-fields"><a class="header" href="#unit-like-structs-without-any-fields">Unit-Like Structs Without Any Fields</a></h3>
<p>You can also define structs that don’t have any fields! These are called
<em>unit-like structs</em> because they behave similarly to <code>()</code>, the unit type that
we mentioned in <a href="ch03-02-data-types.html#the-tuple-type">“The Tuple Type”</a><!-- ignore --> section. Unit-like
structs can be useful in situations in which you need to implement a trait on
some type but don’t have any data that you want to store in the type itself.
We’ll discuss traits in Chapter 10. Here’s an example of declaring and
instantiating a unit struct named <code>AlwaysEqual</code>:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">fn main() {
</span>    struct <span class="ra" data-hover="21">AlwaysEqual</span>;

    let <span class="ra" data-hover="22">subject</span><span class="inlay-hint">: AlwaysEqual</span> = <span class="ra" data-hover="21">AlwaysEqual</span>;
<span class="boring">}
</span>
</code></pre></pre>
<p>To define <code>AlwaysEqual</code>, we use the <code>struct</code> keyword, the name we want, then a
semicolon. No need for curly brackets or parentheses! Then we can get an
instance of <code>AlwaysEqual</code> in the <code>subject</code> variable in a similar way: using the
name we defined, without any curly brackets or parentheses. Imagine we’ll be
implementing behavior for this type that every instance is always equal to
every instance of every other type, perhaps to have a known result for testing
purposes. We wouldn’t need any data to implement that behavior! You’ll see in
Chapter 10 how to define traits and implement them on any type, including
unit-like structs.</p>
<blockquote>
<h3 id="ownership-of-struct-data"><a class="header" href="#ownership-of-struct-data">Ownership of Struct Data</a></h3>
<p>In the <code>User</code> struct definition in Listing 5-1, we used the owned <code>String</code>
type rather than the <code>&amp;str</code> string slice type. This is a deliberate choice
because we want instances of this struct to own all of its data and for that
data to be valid for as long as the entire struct is valid.</p>
<p>It’s possible for structs to store references to data owned by something else,
but to do so requires the use of <em>lifetimes</em>, a Rust feature that we’ll
discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct
is valid for as long as the struct is. Let’s say you try to store a reference
in a struct without specifying lifetimes, like this, which won’t work:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&gt; struct <span class="ra" data-hover="0">User</span> {
</blockquote>
<p>&gt;     <span class="ra" data-hover="23">username</span>: &amp;<span class="ra" data-hover="24">str</span>,
&gt;     <span class="ra" data-hover="25">email</span>: &amp;<span class="ra" data-hover="24">str</span>,
&gt;     <span class="ra" data-hover="6">sign_in_count</span>: <span class="ra" data-hover="7">u64</span>,
&gt;     <span class="ra" data-hover="1">active</span>: <span class="ra" data-hover="2">bool</span>,
&gt; }
&gt;
&gt; fn <span class="ra" data-hover="8">main</span>() {
&gt;     let <span class="ra" data-hover="9">user1</span><span class="inlay-hint">: User</span> = <span class="ra" data-hover="0">User</span> {
&gt;         <span class="ra" data-hover="25">email</span>: &quot;someone@example.com&quot;,
&gt;         <span class="ra" data-hover="23">username</span>: &quot;someusername123&quot;,
&gt;         <span class="ra" data-hover="1">active</span>: true,
&gt;         <span class="ra" data-hover="6">sign_in_count</span>: 1,
&gt;     };
&gt; }
&gt; 
<span class="boring">}
</span></code></pre></pre>
&gt;</p>
<blockquote>
<p>The compiler will complain that it needs lifetime specifiers:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:2:15
  |
2 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 | struct User&lt;'a&gt; {
2 |     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:12
  |
3 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 | struct User&lt;'a&gt; {
2 |     username: &amp;str,
3 |     email: &amp;'a str,
  |

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs`

To learn more, run the command again with --verbose.
</code></pre>
<p>In Chapter 10, we’ll discuss how to fix these errors so you can store
references in structs, but for now, we’ll fix errors like these using owned
types like <code>String</code> instead of references like <code>&amp;str</code>.</p>
</blockquote>
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->
<script src="https://unpkg.com/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
<script src="https://unpkg.com/tippy.js@6.3.2/dist/tippy-bundle.umd.min.js" integrity="sha384-vApKv6LkBdPwmt/fNiQrBCVCZvuniXpG0b5UZhVrGAq1zXdZRSsPcWjGdVxkZJtX" crossorigin="anonymous"></script>
<script>
    const hoverData = ['<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">struct User\n</code></pre>\n','<per><cide class="language-rust">playcrate::User\n</code></pre>\n<per><cide class="language-rust">active: bool\n</code></pre>\n','<per><cide class="language-rust">bool\n</code></pre>\n<hr />\n<p>The boolean type.</p>\n<p>The <cide>bool</code> represents a value, which could only be either <cide>true</code> or <cide>false</code>. If you cast\na <cide>bool</code> into an integer, <cide>true</code> will be 1 and <cide>false</code> will be 0.</p>\n<h1 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h1>\n<p><cide>bool</code> implements various traits, such as <a href="ops::BitAnd"><cide>BitAnd</code></a>, <a href="ops::BitOr"><cide>BitOr</code></a>, <a href="ops::Not"><cide>Not</code></a>, etc.,\nwhich allow us to perform boolean operations using <cide>&amp;</code>, <cide>|</code> and <cide>!</code>.</p>\n<p><cide>if</code> requires a <cide>bool</code> value as its conditional. <a href="%60assert!%60"><cide>assert!</code></a>, which is an\nimportant macro in testing, checks whether an expression is <cide>true</code> and panics\nif it isn#$%t.</p>\n<per><cide>let bool_val = true &amp; false | false;\nassert!(!bool_val);\n</code></pre>\n<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>\n<p>A trivial example of the usage of <cide>bool</code>:</p>\n<per><cide>let praise_the_borrow_checker = true;\n\n// using the `if` conditional\nif praise_the_borrow_checker {\n    println!(&quot;oh, yeah!&quot;);\n} else {\n    println!(&quot;what?!!&quot;);\n}\n\n// ... or, a match pattern\nmatch praise_the_borrow_checker {\n    true =&gt; println!(&quot;keep praising!&quot;),\n    false =&gt; println!(&quot;you should praise!&quot;),\n}\n</code></pre>\n<p>Also, since <cide>bool</code> implements the <a href="%60Copy%60"><cide>Copy</code></a> trait, we don#$%t\nhave to worry about the move semantics (just like the integer and float primitives).</p>\n<p>Now an example of <cide>bool</code> cast to integer type:</p>\n<per><cide>assert_eq!(true as i32, 1);\nassert_eq!(false as i32, 0);\n</code></pre>\n','<per><cide class="language-rust">playcrate::User\n</code></pre>\n<per><cide class="language-rust">username: String\n</code></pre>\n','<per><cide class="language-rust">alloc::string\n</code></pre>\n<per><cide class="language-rust">pub struct String\n</code></pre>\n<hr />\n<p>A UTF-8–encoded, growable string.</p>\n<p>The <cide>String</code> type is the most common string type that has ownership over the\ncontents of the string. It has a close relationship with its borrowed\ncounterpart, the primitive <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>.</p>\n<h1 id="examples-1"><a class="header" href="#examples-1">Examples</a></h1>\n<p>You can create a <cide>String</code> from <a href="https://docs.rs/alloc/*/alloc/str/index.html">a literal string</a> with <a href="https://docs.rs/core/*/core/convert/trait.From.html#tymethod.from"><cide>String::from</code></a>:</p>\n<per><cide>let hello = String::from(&quot;Hello, world!&quot;);\n</code></pre>\n<p>You can append a <a href="%60char%60"><cide>char</code></a> to a <cide>String</code> with the <a href="String::push"><cide>push</code></a> method, and\nappend a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a> with the <a href="String::push_str"><cide>push_str</code></a> method:</p>\n<per><cide>let mut hello = String::from(&quot;Hello, &quot;);\n\nhello.push(#$%w#$%);\nhello.push_str(&quot;orld!&quot;);\n</code></pre>\n<p>If you have a vector of UTF-8 bytes, you can create a <cide>String</code> from it with\nthe <a href="String::from_utf8"><cide>from_utf8</code></a> method:</p>\n<per><cide>// some bytes, in a vector\nlet sparkle_heart = vec![240, 159, 146, 150];\n\n// We know these bytes are valid, so we#$%ll use `unwrap()`.\nlet sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n\nassert_eq!(&quot;💖&quot;, sparkle_heart);\n</code></pre>\n<h1 id="utf-8"><a class="header" href="#utf-8">UTF-8</a></h1>\n<p><cide>String</code>s are always valid UTF-8. This has a few implications, the first of\nwhich is that if you need a non-UTF-8 string, consider <a href="https://docs.rs/alloc/*/std/ffi/struct.OsString.html"><cide>OsString</code></a>. It is\nsimilar, but without the UTF-8 constraint. The second implication is that\nyou cannot index into a <cide>String</code>:</p>\n<per><cide class="language-compile_fail,E0277">let s = &quot;hello&quot;;\n\nprintln!(&quot;The first letter of s is {}&quot;, s[0]); // ERROR!!!\n</code></pre>\n<p>Indexing is intended to be a constant-time operation, but UTF-8 encoding\ndoes not allow us to do this. Furthermore, it#$%s not clear what sort of\nthing the index should return: a byte, a codepoint, or a grapheme cluster.\nThe <a href="str::bytes"><cide>bytes</code></a> and <a href="str::chars"><cide>chars</code></a> methods return iterators over the first\ntwo, respectively.</p>\n<h1 id="deref"><a class="header" href="#deref">Deref</a></h1>\n<p><cide>String</code>s implement <a href="https://docs.rs/core/*/core/ops/deref/trait.Deref.html"><cide>Deref</code></a><cide>&lt;Target=str&gt;</code>, and so inherit all of <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>#$%s\nmethods. In addition, this means that you can pass a <cide>String</code> to a\nfunction which takes a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a> by using an ampersand (<cide>&amp;</code>):</p>\n<per><cide>fn takes_str(s: &amp;str) { }\n\nlet s = String::from(&quot;Hello&quot;);\n\ntakes_str(&amp;s);\n</code></pre>\n<p>This will create a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a> from the <cide>String</code> and pass it in. This\nconversion is very inexpensive, and so generally, functions will accept\n<a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a>s as arguments unless they need a <cide>String</code> for some specific\nreason.</p>\n<p>In certain cases Rust doesn#$%t have enough information to make this\nconversion, known as <a href="https://docs.rs/core/*/core/ops/deref/trait.Deref.html"><cide>Deref</code></a> coercion. In the following example a string\nslice <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;#$%a str</code></a> implements the trait <cide>TraitExample</code>, and the function\n<cide>example_func</code> takes anything that implements the trait. In this case Rust\nwould need to make two implicit conversions, which Rust doesn#$%t have the\nmeans to do. For that reason, the following example will not compile.</p>\n<per><cide class="language-compile_fail,E0277">trait TraitExample {}\n\nimpl&lt;#$%a&gt; TraitExample for &amp;#$%a str {}\n\nfn example_func&lt;A: TraitExample&gt;(example_arg: A) {}\n\nlet example_string = String::from(&quot;example_string&quot;);\nexample_func(&amp;example_string);\n</code></pre>\n<p>There are two options that would work instead. The first would be to\nchange the line <cide>example_func(&amp;example_string);</code> to\n<cide>example_func(example_string.as_str());</code>, using the method <a href="String::as_str"><cide>as_str()</code></a>\nto explicitly extract the string slice containing the string. The second\nway changes <cide>example_func(&amp;example_string);</code> to\n<cide>example_func(&amp;*example_string);</code>. In this case we are dereferencing a\n<cide>String</code> to a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>, then referencing the <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a> back to\n<a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a>. The second way is more idiomatic, however both work to do the\nconversion explicitly rather than relying on the implicit conversion.</p>\n<h1 id="representation"><a class="header" href="#representation">Representation</a></h1>\n<p>A <cide>String</code> is made up of three components: a pointer to some bytes, a\nlength, and a capacity. The pointer points to an internal buffer <cide>String</code>\nuses to store its data. The length is the number of bytes currently stored\nin the buffer, and the capacity is the size of the buffer in bytes. As such,\nthe length will always be less than or equal to the capacity.</p>\n<p>This buffer is always stored on the heap.</p>\n<p>You can look at these with the <a href="str::as_ptr"><cide>as_ptr</code></a>, <a href="String::len"><cide>len</code></a>, and <a href="String::capacity"><cide>capacity</code></a>\nmethods:</p>\n<per><cide>use std::mem;\n\nlet story = String::from(&quot;Once upon a time...&quot;);\n\n// Prevent automatically dropping the String#$%s data\nlet mut story = mem::ManuallyDrop::new(story);\n\nlet ptr = story.as_mut_ptr();\nlet len = story.len();\nlet capacity = story.capacity();\n\n// story has nineteen bytes\nassert_eq!(19, len);\n\n// We can re-build a String out of ptr, len, and capacity. This is all\n// unsafe because we are responsible for making sure the components are\n// valid:\nlet s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;\n\nassert_eq!(String::from(&quot;Once upon a time...&quot;), s);\n</code></pre>\n<p>If a <cide>String</code> has enough capacity, adding elements to it will not\nre-allocate. For example, consider this program:</p>\n<per><cide>let mut s = String::new();\n\nprintln!(&quot;{}&quot;, s.capacity());\n\nfor _ in 0..5 {\n    s.push_str(&quot;hello&quot;);\n    println!(&quot;{}&quot;, s.capacity());\n}\n</code></pre>\n<p>This will output the following:</p>\n<per><cide class="language-text">0\n5\n10\n20\n20\n40\n</code></pre>\n<p>At first, we have no memory allocated at all, but as we append to the\nstring, it increases its capacity appropriately. If we instead use the\n<a href="String::with_capacity"><cide>with_capacity</code></a> method to allocate the correct capacity initially:</p>\n<per><cide>let mut s = String::with_capacity(25);\n\nprintln!(&quot;{}&quot;, s.capacity());\n\nfor _ in 0..5 {\n    s.push_str(&quot;hello&quot;);\n    println!(&quot;{}&quot;, s.capacity());\n}\n</code></pre>\n<p>We end up with a different output:</p>\n<per><cide class="language-text">25\n25\n25\n25\n25\n25\n</code></pre>\n<p>Here, there#$%s no need to allocate more memory inside the loop.</p>\n','<per><cide class="language-rust">playcrate::User\n</code></pre>\n<per><cide class="language-rust">email: String\n</code></pre>\n','<per><cide class="language-rust">playcrate::User\n</code></pre>\n<per><cide class="language-rust">sign_in_count: u64\n</code></pre>\n','<per><cide class="language-rust">u64\n</code></pre>\n<hr />\n<p>The 64-bit unsigned integer type.</p>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn main()\n</code></pre>\n','<per><cide class="language-rust">let user1: User\n</code></pre>\n','<per><cide class="language-rust">core::convert::From\n</code></pre>\n<per><cide class="language-rust">pub fn from(_: T) -&gt; Self\n</code></pre>\n<hr />\n<p>Performs the conversion.</p>\n','<per><cide class="language-rust">let mut user1: User\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn build_user(email: String, username: String) -&gt; User\n</code></pre>\n','<per><cide class="language-rust">email: String\n</code></pre>\n','<per><cide class="language-rust">username: String\n</code></pre>\n','<per><cide class="language-rust">let user2: User\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">struct Color\n</code></pre>\n','<per><cide class="language-rust">i32\n</code></pre>\n<hr />\n<p>The 32-bit signed integer type.</p>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">struct Point\n</code></pre>\n','<per><cide class="language-rust">let black: Color\n</code></pre>\n','<per><cide class="language-rust">let origin: Point\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">struct AlwaysEqual\n</code></pre>\n','<per><cide class="language-rust">let subject: AlwaysEqual\n</code></pre>\n','<per><cide class="language-rust">playcrate::User\n</code></pre>\n<per><cide class="language-rust">username: &amp;str\n</code></pre>\n','<per><cide class="language-rust">str\n</code></pre>\n<hr />\n<p>String slices.</p>\n<p><em><a href="crate::str">See also the <cide>std::str</code> module</a>.</em></p>\n<p>The <cide>str</code> type, also called a #$%string slice#$%, is the most primitive string\ntype. It is usually seen in its borrowed form, <cide>&amp;str</code>. It is also the type\nof string literals, <cide>&amp;#$%static str</code>.</p>\n<p>String slices are always valid UTF-8.</p>\n<h1 id="examples-2"><a class="header" href="#examples-2">Examples</a></h1>\n<p>String literals are string slices:</p>\n<per><cide>let hello = &quot;Hello, world!&quot;;\n\n// with an explicit type annotation\nlet hello: &amp;#$%static str = &quot;Hello, world!&quot;;\n</code></pre>\n<p>They are <cide>#$%static</code> because they#$%re stored directly in the final binary, and\nso will be valid for the <cide>#$%static</code> duration.</p>\n<h1 id="representation-1"><a class="header" href="#representation-1">Representation</a></h1>\n<p>A <cide>&amp;str</code> is made up of two components: a pointer to some bytes, and a\nlength. You can look at these with the <a href="str::as_ptr"><cide>as_ptr</code></a> and <a href="str::len"><cide>len</code></a> methods:</p>\n<per><cide>use std::slice;\nuse std::str;\n\nlet story = &quot;Once upon a time...&quot;;\n\nlet ptr = story.as_ptr();\nlet len = story.len();\n\n// story has nineteen bytes\nassert_eq!(19, len);\n\n// We can re-build a str out of ptr and len. This is all unsafe because\n// we are responsible for making sure the two components are valid:\nlet s = unsafe {\n    // First, we build a &amp;[u8]...\n    let slice = slice::from_raw_parts(ptr, len);\n\n    // ... and then convert that slice into a string slice\n    str::from_utf8(slice)\n};\n\nassert_eq!(s, Ok(story));\n</code></pre>\n<p>Note: This example shows the internals of <cide>&amp;str</code>. <cide>unsafe</code> should not be\nused to get a string slice under normal circumstances. Use <cide>as_str</code>\ninstead.</p>\n','<per><cide class="language-rust">playcrate::User\n</code></pre>\n<per><cide class="language-rust">email: &amp;str\n</code></pre>\n',].map((x)=>x.replaceAll('#$%', "'").replaceAll('<per', '<pre').replaceAll('<cide', '<code'));
    window.onload = () => {
        console.log("hello");
        tippy('.ra', {
            content: (x) => {
                const div = document.createElement('div');
                div.innerHTML = hoverData[x.dataset.hover];
                div.className = 'hover-holder';
                div.querySelectorAll('code').forEach((y) => y.innerHTML = hljs.highlight('rust', y.innerText).value);
                return div;
            },
            allowHTML: true,
            delay: [200, 0],
            interactive: true,
            maxWidth: '80vw',
            appendTo: document.querySelector('.content'),
        });
    };
</script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="ch05-00-structs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="ch05-02-example-structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="ch05-00-structs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="ch05-02-example-structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="ferris.js"></script>
        
        
    </body>
</html>
