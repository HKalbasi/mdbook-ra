<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>How to Write Tests - The Rust Programming Language</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="ferris.css">
                <link rel="stylesheet" href="theme/2018-edition.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References and Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> The Slice Type</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html" class="active"><strong aria-hidden="true">11.1.</strong> How to Write Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlling How Tests Are Run</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.inlay-hint, .inlay-hint * {
    border-radius: .4em;
}

.light .inlay-hint, .rust .inlay-hint {
    background-color: #dcc;
    color: #777;
}

.ayu .inlay-hint, .navy .inlay-hint, .coal .inlay-hint {
    background-color: #444;
    color: #999;
}

.inlay-hint {
    font-size: 0.8em;
    user-select: none;
}
.hover-holder {
    max-height: 40vh;
    overflow: auto;
}

.tippy-content {
    background-color: var(--bg);
    color: var(--fg);
}
</style>## How to Write Tests
<p>Tests are Rust functions that verify that the non-test code is functioning in
the expected manner. The bodies of test functions typically perform these three
actions:</p>
<ol>
<li>Set up any needed data or state.</li>
<li>Run the code you want to test.</li>
<li>Assert the results are what you expect.</li>
</ol>
<p>Let’s look at the features Rust provides specifically for writing tests that
take these actions, which include the <code>test</code> attribute, a few macros, and the
<code>should_panic</code> attribute.</p>
<h3 id="the-anatomy-of-a-test-function"><a class="header" href="#the-anatomy-of-a-test-function">The Anatomy of a Test Function</a></h3>
<p>At its simplest, a test in Rust is a function that’s annotated with the <code>test</code>
attribute. Attributes are metadata about pieces of Rust code; one example is
the <code>derive</code> attribute we used with structs in Chapter 5. To change a function
into a test function, add <code>#[test]</code> on the line before <code>fn</code>. When you run your
tests with the <code>cargo test</code> command, Rust builds a test runner binary that runs
the functions annotated with the <code>test</code> attribute and reports on whether each
test function passes or fails.</p>
<p>When we make a new library project with Cargo, a test module with a test
function in it is automatically generated for us. This module helps you start
writing your tests so you don’t have to look up the exact structure and syntax
of test functions every time you start a new project. You can add as many
additional test functions and as many test modules as you want!</p>
<p>We’ll explore some aspects of how tests work by experimenting with the template
test generated for us without actually testing any code. Then we’ll write some
real-world tests that call some code that we’ve written and assert that its
behavior is correct.</p>
<p>Let’s create a new library project called <code>adder</code>:</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>The contents of the <em>src/lib.rs</em> file in your <code>adder</code> library should look like
Listing 11-1.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[<span class="ra" data-hover="1">test</span>]
    fn <span class="ra" data-hover="2">it_works</span>() {
        <span class="ra" data-hover="3">assert_eq</span>!(2 + 2, 4);
    }
}
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 11-1: The test module and function generated
automatically by <code>cargo new</code></span></p>
<p>For now, let’s ignore the top two lines and focus on the function to see how it
works. Note the <code>#[test]</code> annotation before the <code>fn</code> line: this attribute
indicates this is a test function, so the test runner knows to treat this
function as a test. We could also have non-test functions in the <code>tests</code> module
to help set up common scenarios or perform common operations, so we need to
indicate which functions are tests by using the <code>#[test]</code> attribute.</p>
<p>The function body uses the <code>assert_eq!</code> macro to assert that 2 + 2 equals 4.
This assertion serves as an example of the format for a typical test. Let’s run
it to see that this test passes.</p>
<p>The <code>cargo test</code> command runs all tests in our project, as shown in Listing
11-2.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p><span class="caption">Listing 11-2: The output from running the automatically
generated test</span></p>
<p>Cargo compiled and ran the test. After the <code>Compiling</code>, <code>Finished</code>, and
<code>Running</code> lines is the line <code>running 1 test</code>. The next line shows the name
of the generated test function, called <code>it_works</code>, and the result of running
that test, <code>ok</code>. The overall summary of running the tests appears next. The
text <code>test result: ok.</code> means that all the tests passed, and the portion that
reads <code>1 passed; 0 failed</code> totals the number of tests that passed or failed.</p>
<p>Because we don’t have any tests we’ve marked as ignored, the summary shows <code>0 ignored</code>. We also haven’t filtered the tests being run, so the end of the
summary shows <code>0 filtered out</code>. We’ll talk about ignoring and filtering out
tests in the next section, <a href="ch11-02-running-tests.html#controlling-how-tests-are-run">“Controlling How Tests Are
Run.”</a><!-- ignore --></p>
<p>The <code>0 measured</code> statistic is for benchmark tests that measure performance.
Benchmark tests are, as of this writing, only available in nightly Rust. See
<a href="../unstable-book/library-features/test.html">the documentation about benchmark tests</a> to learn more.</p>
<p>The next part of the test output, which starts with <code>Doc-tests adder</code>, is for
the results of any documentation tests. We don’t have any documentation tests
yet, but Rust can compile any code examples that appear in our API
documentation. This feature helps us keep our docs and our code in sync! We’ll
discuss how to write documentation tests in the <a href="ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests">“Documentation Comments as
Tests”</a><!-- ignore --> section of Chapter 14. For now, we’ll
ignore the <code>Doc-tests</code> output.</p>
<p>Let’s change the name of our test to see how that changes the test output.
Change the <code>it_works</code> function to a different name, such as <code>exploration</code>, like
so:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[<span class="ra" data-hover="1">test</span>]
    fn <span class="ra" data-hover="4">exploration</span>() {
        <span class="ra" data-hover="3">assert_eq</span>!(2 + 2, 4);
    }
}
<span class="boring">}
</span>
</code></pre></pre>
<p>Then run <code>cargo test</code> again. The output now shows <code>exploration</code> instead of
<code>it_works</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Let’s add another test, but this time we’ll make a test that fails! Tests fail
when something in the test function panics. Each test is run in a new thread,
and when the main thread sees that a test thread has died, the test is marked
as failed. We talked about the simplest way to cause a panic in Chapter 9,
which is to call the <code>panic!</code> macro. Enter the new test, <code>another</code>, so your
<em>src/lib.rs</em> file looks like Listing 11-3.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[<span class="ra" data-hover="1">test</span>]
    fn <span class="ra" data-hover="4">exploration</span>() {
        <span class="ra" data-hover="3">assert_eq</span>!(2 + 2, 4);
    }

    #[<span class="ra" data-hover="1">test</span>]
    fn <span class="ra" data-hover="5">another</span>() {
        <span class="ra" data-hover="6">panic</span>!("Make this test fail");
    }
}
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 11-3: Adding a second test that will fail because
we call the <code>panic!</code> macro</span></p>
<p>Run the tests again using <code>cargo test</code>. The output should look like Listing
11-4, which shows that our <code>exploration</code> test passed and <code>another</code> failed.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'main' panicked at 'Make this test fail', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p><span class="caption">Listing 11-4: Test results when one test passes and one
test fails</span></p>
<p>Instead of <code>ok</code>, the line <code>test tests::another</code> shows <code>FAILED</code>. Two new
sections appear between the individual results and the summary: the first
section displays the detailed reason for each test failure. In this case,
<code>another</code> failed because it <code>panicked at 'Make this test fail'</code>, which happened
on line 10 in the <em>src/lib.rs</em> file. The next section lists just the names of
all the failing tests, which is useful when there are lots of tests and lots of
detailed failing test output. We can use the name of a failing test to run just
that test to more easily debug it; we’ll talk more about ways to run tests in
the <a href="ch11-02-running-tests.html#controlling-how-tests-are-run">“Controlling How Tests Are Run”</a><!-- ignore
--> section.</p>
<p>The summary line displays at the end: overall, our test result is <code>FAILED</code>.
We had one test pass and one test fail.</p>
<p>Now that you’ve seen what the test results look like in different scenarios,
let’s look at some macros other than <code>panic!</code> that are useful in tests.</p>
<h3 id="checking-results-with-the-assert-macro"><a class="header" href="#checking-results-with-the-assert-macro">Checking Results with the <code>assert!</code> Macro</a></h3>
<p>The <code>assert!</code> macro, provided by the standard library, is useful when you want
to ensure that some condition in a test evaluates to <code>true</code>. We give the
<code>assert!</code> macro an argument that evaluates to a Boolean. If the value is
<code>true</code>, <code>assert!</code> does nothing and the test passes. If the value is <code>false</code>,
the <code>assert!</code> macro calls the <code>panic!</code> macro, which causes the test to fail.
Using the <code>assert!</code> macro helps us check that our code is functioning in the
way we intend.</p>
<p>In Chapter 5, Listing 5-15, we used a <code>Rectangle</code> struct and a <code>can_hold</code>
method, which are repeated here in Listing 11-5. Let’s put this code in the
<em>src/lib.rs</em> file and write some tests for it using the <code>assert!</code> macro.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[<span class="ra" data-hover="7">derive</span>(<span class="ra" data-hover="8">Debug</span>)]
struct <span class="ra" data-hover="9">Rectangle</span> {
    <span class="ra" data-hover="10">width</span>: <span class="ra" data-hover="11">u32</span>,
    <span class="ra" data-hover="12">height</span>: <span class="ra" data-hover="11">u32</span>,
}

impl <span class="ra" data-hover="9">Rectangle</span> {
    fn <span class="ra" data-hover="13">can_hold</span>(&amp;<span class="ra" data-hover="14">self</span>, <span class="ra" data-hover="15">other</span>: &amp;<span class="ra" data-hover="9">Rectangle</span>) -&gt; <span class="ra" data-hover="16">bool</span> {
        <span class="ra" data-hover="14">self</span>.<span class="ra" data-hover="10">width</span> &gt; <span class="ra" data-hover="15">other</span>.<span class="ra" data-hover="10">width</span> &amp;&amp; <span class="ra" data-hover="14">self</span>.<span class="ra" data-hover="12">height</span> &gt; <span class="ra" data-hover="15">other</span>.<span class="ra" data-hover="12">height
    }
}
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 11-5: Using the <code>Rectangle</code> struct and its
<code>can_hold</code> method from Chapter 5</span></p>
<p>The <code>can_hold</code> method returns a Boolean, which means it’s a perfect use case
for the <code>assert!</code> macro. In Listing 11-6, we write a test that exercises the
<code>can_hold</code> method by creating a <code>Rectangle</code> instance that has a width of 8 and
a height of 7 and asserting that it can hold another <code>Rectangle</code> instance that
has a width of 5 and a height of 1.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&self, other: &Rectangle) -> bool {
</span><span class="boring">        self.width > other.width && self.height > other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[<span class="ra" data-hover="1">test</span>]
    fn <span class="ra" data-hover="17">larger_can_hold_smaller</span>() {
        let <span class="ra" data-hover="18">larger</span><span class="inlay-hint">: Rectangle</span> = <span class="ra" data-hover="9">Rectangle</span> {
            <span class="ra" data-hover="10">width</span>: 8,
            <span class="ra" data-hover="12">height</span>: 7,
        };
        let <span class="ra" data-hover="19">smaller</span><span class="inlay-hint">: Rectangle</span> = <span class="ra" data-hover="9">Rectangle</span> {
            <span class="ra" data-hover="10">width</span>: 5,
            <span class="ra" data-hover="12">height</span>: 1,
        };

        <span class="ra" data-hover="20">assert</span>!(<span class="ra" data-hover="18">larger</span>.can_hold(&amp;<span class="ra" data-hover="19">smaller</span>));
    }
}
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 11-6: A test for <code>can_hold</code> that checks whether a
larger rectangle can indeed hold a smaller rectangle</span></p>
<p>Note that we’ve added a new line inside the <code>tests</code> module: <code>use super::*;</code>.
The <code>tests</code> module is a regular module that follows the usual visibility rules
we covered in Chapter 7 in the <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths for Referring to an Item in the Module
Tree”</a><!-- ignore -->
section. Because the <code>tests</code> module is an inner module, we need to bring the
code under test in the outer module into the scope of the inner module. We use
a glob here so anything we define in the outer module is available to this
<code>tests</code> module.</p>
<p>We’ve named our test <code>larger_can_hold_smaller</code>, and we’ve created the two
<code>Rectangle</code> instances that we need. Then we called the <code>assert!</code> macro and
passed it the result of calling <code>larger.can_hold(&amp;smaller)</code>. This expression
is supposed to return <code>true</code>, so our test should pass. Let’s find out!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>It does pass! Let’s add another test, this time asserting that a smaller
rectangle cannot hold a larger rectangle:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&self, other: &Rectangle) -> bool {
</span><span class="boring">        self.width > other.width && self.height > other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[<span class="ra" data-hover="1">test</span>]
    fn <span class="ra" data-hover="17">larger_can_hold_smaller</span>() {
        // --snip--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&smaller));
</span>    }

    #[<span class="ra" data-hover="1">test</span>]
    fn <span class="ra" data-hover="21">smaller_cannot_hold_larger</span>() {
        let <span class="ra" data-hover="18">larger</span><span class="inlay-hint">: Rectangle</span> = <span class="ra" data-hover="9">Rectangle</span> {
            <span class="ra" data-hover="10">width</span>: 8,
            <span class="ra" data-hover="12">height</span>: 7,
        };
        let <span class="ra" data-hover="19">smaller</span><span class="inlay-hint">: Rectangle</span> = <span class="ra" data-hover="9">Rectangle</span> {
            <span class="ra" data-hover="10">width</span>: 5,
            <span class="ra" data-hover="12">height</span>: 1,
        };

        <span class="ra" data-hover="20">assert</span>!(!<span class="ra" data-hover="19">smaller</span>.can_hold(&amp;<span class="ra" data-hover="18">larger</span>));
    }
}
<span class="boring">}
</span>
</code></pre></pre>
<p>Because the correct result of the <code>can_hold</code> function in this case is <code>false</code>,
we need to negate that result before we pass it to the <code>assert!</code> macro. As a
result, our test will pass if <code>can_hold</code> returns <code>false</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Two tests that pass! Now let’s see what happens to our test results when we
introduce a bug in our code. Let’s change the implementation of the <code>can_hold</code>
method by replacing the greater than sign with a less than sign when it
compares the widths:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl <span class="ra" data-hover="9">Rectangle</span> {
    fn <span class="ra" data-hover="13">can_hold</span>(&amp;<span class="ra" data-hover="14">self</span>, <span class="ra" data-hover="15">other</span>: &amp;<span class="ra" data-hover="9">Rectangle</span>) -&gt; <span class="ra" data-hover="16">bool</span> {
        <span class="ra" data-hover="14">self</span>.<span class="ra" data-hover="10">width</span> &lt; <span class="ra" data-hover="15">other</span>.<span class="ra" data-hover="10">width</span> &amp;&amp; <span class="ra" data-hover="14">self</span>.<span class="ra" data-hover="12">height</span> &gt; <span class="ra" data-hover="15">other</span>.<span class="ra" data-hover="12">height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&larger));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span>
</code></pre></pre>
<p>Running the tests now produces the following:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'main' panicked at 'assertion failed: larger.can_hold(&amp;smaller)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Our tests caught the bug! Because <code>larger.width</code> is 8 and <code>smaller.width</code> is
5, the comparison of the widths in <code>can_hold</code> now returns <code>false</code>: 8 is not
less than 5.</p>
<h3 id="testing-equality-with-the-assert_eq-and-assert_ne-macros"><a class="header" href="#testing-equality-with-the-assert_eq-and-assert_ne-macros">Testing Equality with the <code>assert_eq!</code> and <code>assert_ne!</code> Macros</a></h3>
<p>A common way to test functionality is to compare the result of the code under
test to the value you expect the code to return to make sure they’re equal. You
could do this using the <code>assert!</code> macro and passing it an expression using the
<code>==</code> operator. However, this is such a common test that the standard library
provides a pair of macros—<code>assert_eq!</code> and <code>assert_ne!</code>—to perform this test
more conveniently. These macros compare two arguments for equality or
inequality, respectively. They’ll also print the two values if the assertion
fails, which makes it easier to see <em>why</em> the test failed; conversely, the
<code>assert!</code> macro only indicates that it got a <code>false</code> value for the <code>==</code>
expression, not the values that led to the <code>false</code> value.</p>
<p>In Listing 11-7, we write a function named <code>add_two</code> that adds <code>2</code> to its
parameter and returns the result. Then we test this function using the
<code>assert_eq!</code> macro.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn <span class="ra" data-hover="22">add_two</span>(<span class="ra" data-hover="23">a</span>: <span class="ra" data-hover="24">i32</span>) -&gt; <span class="ra" data-hover="24">i32</span> {
    <span class="ra" data-hover="23">a</span> + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[<span class="ra" data-hover="1">test</span>]
    fn <span class="ra" data-hover="25">it_adds_two</span>() {
        <span class="ra" data-hover="3">assert_eq</span>!(4, <span class="ra" data-hover="22">add_two</span>(2));
    }
}
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 11-7: Testing the function <code>add_two</code> using the
<code>assert_eq!</code> macro</span></p>
<p>Let’s check that it passes!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>The first argument we gave to the <code>assert_eq!</code> macro, <code>4</code>, is equal to the
result of calling <code>add_two(2)</code>. The line for this test is <code>test tests::it_adds_two ... ok</code>, and the <code>ok</code> text indicates that our test passed!</p>
<p>Let’s introduce a bug into our code to see what it looks like when a test that
uses <code>assert_eq!</code> fails. Change the implementation of the <code>add_two</code> function to
instead add <code>3</code>:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn <span class="ra" data-hover="22">add_two</span>(<span class="ra" data-hover="23">a</span>: <span class="ra" data-hover="24">i32</span>) -&gt; <span class="ra" data-hover="24">i32</span> {
    <span class="ra" data-hover="23">a</span> + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        assert_eq!(4, add_two(2));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span>
</code></pre></pre>
<p>Run the tests again:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Our test caught the bug! The <code>it_adds_two</code> test failed, displaying the message
<code>assertion failed: `(left == right)`</code> and showing that <code>left</code> was <code>4</code> and
<code>right</code> was <code>5</code>. This message is useful and helps us start debugging: it means
the <code>left</code> argument to <code>assert_eq!</code> was <code>4</code> but the <code>right</code> argument, where we
had <code>add_two(2)</code>, was <code>5</code>.</p>
<p>Note that in some languages and test frameworks, the parameters to the
functions that assert two values are equal are called <code>expected</code> and <code>actual</code>,
and the order in which we specify the arguments matters. However, in Rust,
they’re called <code>left</code> and <code>right</code>, and the order in which we specify the value
we expect and the value that the code under test produces doesn’t matter. We
could write the assertion in this test as <code>assert_eq!(add_two(2), 4)</code>, which
would result in a failure message that displays <code>assertion failed: `(left == right)`</code> and that <code>left</code> was <code>5</code> and <code>right</code> was <code>4</code>.</p>
<p>The <code>assert_ne!</code> macro will pass if the two values we give it are not equal and
fail if they’re equal. This macro is most useful for cases when we’re not sure
what a value <em>will</em> be, but we know what the value definitely <em>won’t</em> be if our
code is functioning as we intend. For example, if we’re testing a function that
is guaranteed to change its input in some way, but the way in which the input
is changed depends on the day of the week that we run our tests, the best thing
to assert might be that the output of the function is not equal to the input.</p>
<p>Under the surface, the <code>assert_eq!</code> and <code>assert_ne!</code> macros use the operators
<code>==</code> and <code>!=</code>, respectively. When the assertions fail, these macros print their
arguments using debug formatting, which means the values being compared must
implement the <code>PartialEq</code> and <code>Debug</code> traits. All the primitive types and most
of the standard library types implement these traits. For structs and enums
that you define, you’ll need to implement <code>PartialEq</code> to assert that values of
those types are equal or not equal. You’ll need to implement <code>Debug</code> to print
the values when the assertion fails. Because both traits are derivable traits,
as mentioned in Listing 5-12 in Chapter 5, this is usually as straightforward
as adding the <code>#[derive(PartialEq, Debug)]</code> annotation to your struct or enum
definition. See Appendix C, <a href="appendix-03-derivable-traits.html">“Derivable Traits,”</a><!-- ignore
--> for more details about these and other derivable traits.</p>
<h3 id="adding-custom-failure-messages"><a class="header" href="#adding-custom-failure-messages">Adding Custom Failure Messages</a></h3>
<p>You can also add a custom message to be printed with the failure message as
optional arguments to the <code>assert!</code>, <code>assert_eq!</code>, and <code>assert_ne!</code> macros. Any
arguments specified after the one required argument to <code>assert!</code> or the two
required arguments to <code>assert_eq!</code> and <code>assert_ne!</code> are passed along to the
<code>format!</code> macro (discussed in Chapter 8 in the <a href="ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro">“Concatenation with the <code>+</code>
Operator or the <code>format!</code>
Macro”</a><!-- ignore -->
section), so you can pass a format string that contains <code>{}</code> placeholders and
values to go in those placeholders. Custom messages are useful to document
what an assertion means; when a test fails, you’ll have a better idea of what
the problem is with the code.</p>
<p>For example, let’s say we have a function that greets people by name and we
want to test that the name we pass into the function appears in the output:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn <span class="ra" data-hover="26">greeting</span>(<span class="ra" data-hover="27">name</span>: &amp;<span class="ra" data-hover="28">str</span>) -&gt; <span class="ra" data-hover="29">String</span> {
    <span class="ra" data-hover="30">format</span>!("Hello {}!", <span class="ra" data-hover="27">name</span>)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[<span class="ra" data-hover="1">test</span>]
    fn <span class="ra" data-hover="31">greeting_contains_name</span>() {
        let <span class="ra" data-hover="32">result</span><span class="inlay-hint">: String</span> = <span class="ra" data-hover="26">greeting</span>(<span class="inlay-hint">name: </span>"Carol");
        <span class="ra" data-hover="20">assert</span>!(<span class="ra" data-hover="32">result</span>.<span class="ra" data-hover="33">contains</span>("Carol"));
    }
}
<span class="boring">}
</span>
</code></pre></pre>
<p>The requirements for this program haven’t been agreed upon yet, and we’re
pretty sure the <code>Hello</code> text at the beginning of the greeting will change. We
decided we don’t want to have to update the test when the requirements change,
so instead of checking for exact equality to the value returned from the
<code>greeting</code> function, we’ll just assert that the output contains the text of the
input parameter.</p>
<p>Let’s introduce a bug into this code by changing <code>greeting</code> to not include
<code>name</code> to see what this test failure looks like:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn <span class="ra" data-hover="26">greeting</span>(<span class="ra" data-hover="27">name</span>: &amp;<span class="ra" data-hover="28">str</span>) -&gt; <span class="ra" data-hover="29">String</span> {
    <span class="ra" data-hover="29">String</span>::<span class="ra" data-hover="34">from</span>("Hello!")
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting("Carol");
</span><span class="boring">        assert!(result.contains("Carol"));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span>
</code></pre></pre>
<p>Running this test produces the following:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'assertion failed: result.contains(\&quot;Carol\&quot;)', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>This result just indicates that the assertion failed and which line the
assertion is on. A more useful failure message in this case would print the
value we got from the <code>greeting</code> function. Let’s change the test function,
giving it a custom failure message made from a format string with a placeholder
filled in with the actual value we got from the <code>greeting</code> function:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub fn greeting(name: &str) -> String {
</span><span class="boring">    String::from("Hello!")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[<span class="ra" data-hover="1">test</span>]
    fn <span class="ra" data-hover="31">greeting_contains_name</span>() {
        let <span class="ra" data-hover="32">result</span><span class="inlay-hint">: String</span> = <span class="ra" data-hover="26">greeting</span>(<span class="inlay-hint">name: </span>"Carol");
        <span class="ra" data-hover="20">assert</span>!(
            <span class="ra" data-hover="32">result</span>.<span class="ra" data-hover="33">contains</span>("Carol"),
            "Greeting did not contain name, value was `{}`",
            <span class="ra" data-hover="32">result
        );
    }
<span class="boring">}
</span><span class="boring">}
</span>
</code></pre></pre>
<p>Now when we run the test, we’ll get a more informative error message:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'Greeting did not contain name, value was `Hello!`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>We can see the value we actually got in the test output, which would help us
debug what happened instead of what we were expecting to happen.</p>
<h3 id="checking-for-panics-with-should_panic"><a class="header" href="#checking-for-panics-with-should_panic">Checking for Panics with <code>should_panic</code></a></h3>
<p>In addition to checking that our code returns the correct values we expect,
it’s also important to check that our code handles error conditions as we
expect. For example, consider the <code>Guess</code> type that we created in Chapter 9,
Listing 9-10. Other code that uses <code>Guess</code> depends on the guarantee that <code>Guess</code>
instances will contain only values between 1 and 100. We can write a test that
ensures that attempting to create a <code>Guess</code> instance with a value outside that
range panics.</p>
<p>We do this by adding another attribute, <code>should_panic</code>, to our test function.
This attribute makes a test pass if the code inside the function panics; the
test will fail if the code inside the function doesn’t panic.</p>
<p>Listing 11-8 shows a test that checks that the error conditions of <code>Guess::new</code>
happen when we expect them to.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct <span class="ra" data-hover="35">Guess</span> {
    <span class="ra" data-hover="36">value</span>: <span class="ra" data-hover="24">i32</span>,
}

impl <span class="ra" data-hover="35">Guess</span> {
    pub fn <span class="ra" data-hover="37">new</span>(<span class="ra" data-hover="38">value</span>: <span class="ra" data-hover="24">i32</span>) -&gt; <span class="ra" data-hover="35">Guess</span> {
        if <span class="ra" data-hover="38">value</span> &lt; 1 || <span class="ra" data-hover="38">value</span> &gt; 100 {
            <span class="ra" data-hover="6">panic</span>!("Guess value must be between 1 and 100, got {}.", <span class="ra" data-hover="38">value</span>);
        }

        <span class="ra" data-hover="35">Guess</span> { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[<span class="ra" data-hover="1">test</span>]
    #[should_panic]
    fn <span class="ra" data-hover="39">greater_than_100</span>() {
        <span class="ra" data-hover="35">Guess</span>::new(200);
    }
}
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 11-8: Testing that a condition will cause a
<code>panic!</code></span></p>
<p>We place the <code>#[should_panic]</code> attribute after the <code>#[test]</code> attribute and
before the test function it applies to. Let’s look at the result when this test
passes:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Looks good! Now let’s introduce a bug in our code by removing the condition
that the <code>new</code> function will panic if the value is greater than 100:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl <span class="ra" data-hover="35">Guess</span> {
    pub fn <span class="ra" data-hover="37">new</span>(<span class="ra" data-hover="38">value</span>: <span class="ra" data-hover="24">i32</span>) -&gt; <span class="ra" data-hover="35">Guess</span> {
        if <span class="ra" data-hover="38">value</span> &lt; 1 {
            <span class="ra" data-hover="6">panic</span>!("Guess value must be between 1 and 100, got {}.", <span class="ra" data-hover="38">value</span>);
        }

        <span class="ra" data-hover="35">Guess</span> { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span>
</code></pre></pre>
<p>When we run the test in Listing 11-8, it will fail:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>We don’t get a very helpful message in this case, but when we look at the test
function, we see that it’s annotated with <code>#[should_panic]</code>. The failure we got
means that the code in the test function did not cause a panic.</p>
<p>Tests that use <code>should_panic</code> can be imprecise because they only indicate that
the code has caused some panic. A <code>should_panic</code> test would pass even if the
test panics for a different reason from the one we were expecting to happen. To
make <code>should_panic</code> tests more precise, we can add an optional <code>expected</code>
parameter to the <code>should_panic</code> attribute. The test harness will make sure that
the failure message contains the provided text. For example, consider the
modified code for <code>Guess</code> in Listing 11-9 where the <code>new</code> function panics with
different messages depending on whether the value is too small or too large.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl <span class="ra" data-hover="35">Guess</span> {
    pub fn <span class="ra" data-hover="37">new</span>(<span class="ra" data-hover="38">value</span>: <span class="ra" data-hover="24">i32</span>) -&gt; <span class="ra" data-hover="35">Guess</span> {
        if <span class="ra" data-hover="38">value</span> &lt; 1 {
            <span class="ra" data-hover="6">panic</span>!(
                "Guess value must be greater than or equal to 1, got {}.",
                <span class="ra" data-hover="38">value
            );
        } else if <span class="ra" data-hover="38">value</span> &gt; 100 {
            <span class="ra" data-hover="6">panic</span>!(
                "Guess value must be less than or equal to 100, got {}.",
                <span class="ra" data-hover="38">value
            );
        }

        <span class="ra" data-hover="35">Guess</span> { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[<span class="ra" data-hover="1">test</span>]
    #[should_panic(expected = "Guess value must be less than or equal to 100")]
    fn <span class="ra" data-hover="39">greater_than_100</span>() {
        <span class="ra" data-hover="35">Guess</span>::new(200);
    }
}
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 11-9: Testing that a condition will cause a
<code>panic!</code> with a particular panic message</span></p>
<p>This test will pass because the value we put in the <code>should_panic</code> attribute’s
<code>expected</code> parameter is a substring of the message that the <code>Guess::new</code>
function panics with. We could have specified the entire panic message that we
expect, which in this case would be <code>Guess value must be less than or equal to 100, got 200.</code> What you choose to specify in the expected parameter for
<code>should_panic</code> depends on how much of the panic message is unique or dynamic
and how precise you want your test to be. In this case, a substring of the
panic message is enough to ensure that the code in the test function executes
the <code>else if value &gt; 100</code> case.</p>
<p>To see what happens when a <code>should_panic</code> test with an <code>expected</code> message
fails, let’s again introduce a bug into our code by swapping the bodies of the
<code>if value &lt; 1</code> and the <code>else if value &gt; 100</code> blocks:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -> Guess {
</span>        if <span class="ra" data-hover="38">value</span> &lt; 1 {
            <span class="ra" data-hover="6">panic</span>!(
                "Guess value must be less than or equal to 100, got {}.",
                <span class="ra" data-hover="38">value
            );
        } else if <span class="ra" data-hover="38">value</span> &gt; 100 {
            <span class="ra" data-hover="6">panic</span>!(
                "Guess value must be greater than or equal to 1, got {}.",
                <span class="ra" data-hover="38">value
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = "Guess value must be less than or equal to 100")]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span>
</code></pre></pre>
<p>This time when we run the <code>should_panic</code> test, it will fail:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests (target/debug/deps/guessing_game-57d70c3acb738f4d)

running 1 test
test tests::greater_than_100 - should panic ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'main' panicked at 'Guess value must be greater than or equal to 1, got 200.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
note: panic did not contain expected string
      panic message: `&quot;Guess value must be greater than or equal to 1, got 200.&quot;`,
 expected substring: `&quot;Guess value must be less than or equal to 100&quot;`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>The failure message indicates that this test did indeed panic as we expected,
but the panic message did not include the expected string <code>'Guess value must be less than or equal to 100'</code>. The panic message that we did get in this case was
<code>Guess value must be greater than or equal to 1, got 200.</code> Now we can start
figuring out where our bug is!</p>
<h3 id="using-resultt-e-in-tests"><a class="header" href="#using-resultt-e-in-tests">Using <code>Result&lt;T, E&gt;</code> in Tests</a></h3>
<p>So far, we’ve written tests that panic when they fail. We can also write tests
that use <code>Result&lt;T, E&gt;</code>! Here’s the test from Listing 11-1, rewritten to use
<code>Result&lt;T, E&gt;</code> and return an <code>Err</code> instead of panicking:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[<span class="ra" data-hover="1">test</span>]
    fn <span class="ra" data-hover="40">it_works</span>() -&gt; <span class="ra" data-hover="41">Result</span>&lt;(), <span class="ra" data-hover="29">String</span>&gt; {
        if 2 + 2 == 4 {
            <span class="ra" data-hover="42">Ok</span>(())
        } else {
            <span class="ra" data-hover="43">Err</span>(<span class="ra" data-hover="29">String</span>::<span class="ra" data-hover="34">from</span>("two plus two does not equal four"))
        }
    }
}
<span class="boring">}
</span>
</code></pre></pre>
<p>The <code>it_works</code> function now has a return type, <code>Result&lt;(), String&gt;</code>. In the
body of the function, rather than calling the <code>assert_eq!</code> macro, we return
<code>Ok(())</code> when the test passes and an <code>Err</code> with a <code>String</code> inside when the test
fails.</p>
<p>Writing tests so they return a <code>Result&lt;T, E&gt;</code> enables you to use the question
mark operator in the body of tests, which can be a convenient way to write
tests that should fail if any operation within them returns an <code>Err</code> variant.</p>
<p>You can’t use the <code>#[should_panic]</code> annotation on tests that use <code>Result&lt;T, E&gt;</code>. Instead, you should return an <code>Err</code> value directly when the test should
fail.</p>
<p>Now that you know several ways to write tests, let’s look at what is happening
when we run our tests and explore the different options we can use with <code>cargo test</code>.</p>
<script src="https://unpkg.com/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
<script src="https://unpkg.com/tippy.js@6.3.2/dist/tippy-bundle.umd.min.js" integrity="sha384-vApKv6LkBdPwmt/fNiQrBCVCZvuniXpG0b5UZhVrGAq1zXdZRSsPcWjGdVxkZJtX" crossorigin="anonymous"></script>
<script>
    const hoverData = ['<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn main()\n</code></pre>\n','<per><cide class="language-rust">core\n</code></pre>\n<per><cide class="language-rust">pub macro test\n</code></pre>\n<hr />\n<p>Attribute macro applied to a function to turn it into a unit test.</p>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn it_works()\n</code></pre>\n','<per><cide class="language-rust">core\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! assert_eq\n</code></pre>\n<hr />\n<p>Asserts that two expressions are equal to each other (using <a href="%60PartialEq%60"><cide>PartialEq</code></a>).</p>\n<p>On panic, this macro will print the values of the expressions with their\ndebug representations.</p>\n<p>Like <a href="%60assert!%60"><cide>assert!</code></a>, this macro has a second form, where a custom\npanic message can be provided.</p>\n<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>\n<per><cide>let a = 3;\nlet b = 1 + 2;\nassert_eq!(a, b);\n\nassert_eq!(a, b, &quot;we are testing addition with {} and {}&quot;, a, b);\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn exploration()\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn another()\n</code></pre>\n','<per><cide class="language-rust">std\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! panic\n</code></pre>\n','<per><cide class="language-rust">core\n</code></pre>\n<per><cide class="language-rust">pub macro derive\n</code></pre>\n<hr />\n<p>Attribute macro used to apply derive macros.</p>\n','<per><cide class="language-rust">core\n</code></pre>\n<per><cide class="language-rust">pub macro Debug\n</code></pre>\n<hr />\n<p>Derive macro generating an impl of the trait <cide>Debug</code>.</p>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">struct Rectangle\n</code></pre>\n','<per><cide class="language-rust">playcrate::Rectangle\n</code></pre>\n<per><cide class="language-rust">width: u32\n</code></pre>\n','<per><cide class="language-rust">u32\n</code></pre>\n<hr />\n<p>The 32-bit unsigned integer type.</p>\n','<per><cide class="language-rust">playcrate::Rectangle\n</code></pre>\n<per><cide class="language-rust">height: u32\n</code></pre>\n','<per><cide class="language-rust">playcrate::Rectangle\n</code></pre>\n<per><cide class="language-rust">fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool\n</code></pre>\n','<per><cide class="language-rust">self: &amp;Rectangle\n</code></pre>\n','<per><cide class="language-rust">other: &amp;Rectangle\n</code></pre>\n','<per><cide class="language-rust">bool\n</code></pre>\n<hr />\n<p>The boolean type.</p>\n<p>The <cide>bool</code> represents a value, which could only be either <cide>true</code> or <cide>false</code>. If you cast\na <cide>bool</code> into an integer, <cide>true</code> will be 1 and <cide>false</code> will be 0.</p>\n<h1 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h1>\n<p><cide>bool</code> implements various traits, such as <a href="ops::BitAnd"><cide>BitAnd</code></a>, <a href="ops::BitOr"><cide>BitOr</code></a>, <a href="ops::Not"><cide>Not</code></a>, etc.,\nwhich allow us to perform boolean operations using <cide>&amp;</code>, <cide>|</code> and <cide>!</code>.</p>\n<p><cide>if</code> requires a <cide>bool</code> value as its conditional. <a href="%60assert!%60"><cide>assert!</code></a>, which is an\nimportant macro in testing, checks whether an expression is <cide>true</code> and panics\nif it isn#$%t.</p>\n<per><cide>let bool_val = true &amp; false | false;\nassert!(!bool_val);\n</code></pre>\n<h1 id="examples-1"><a class="header" href="#examples-1">Examples</a></h1>\n<p>A trivial example of the usage of <cide>bool</code>:</p>\n<per><cide>let praise_the_borrow_checker = true;\n\n// using the `if` conditional\nif praise_the_borrow_checker {\n    println!(&quot;oh, yeah!&quot;);\n} else {\n    println!(&quot;what?!!&quot;);\n}\n\n// ... or, a match pattern\nmatch praise_the_borrow_checker {\n    true =&gt; println!(&quot;keep praising!&quot;),\n    false =&gt; println!(&quot;you should praise!&quot;),\n}\n</code></pre>\n<p>Also, since <cide>bool</code> implements the <a href="%60Copy%60"><cide>Copy</code></a> trait, we don#$%t\nhave to worry about the move semantics (just like the integer and float primitives).</p>\n<p>Now an example of <cide>bool</code> cast to integer type:</p>\n<per><cide>assert_eq!(true as i32, 1);\nassert_eq!(false as i32, 0);\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn larger_can_hold_smaller()\n</code></pre>\n','<per><cide class="language-rust">let larger: Rectangle\n</code></pre>\n','<per><cide class="language-rust">let smaller: Rectangle\n</code></pre>\n','<per><cide class="language-rust">core\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! assert\n</code></pre>\n<hr />\n<p>Asserts that a boolean expression is <cide>true</code> at runtime.</p>\n<p>This will invoke the <a href="%60panic!%60"><cide>panic!</code></a> macro if the provided expression cannot be\nevaluated to <cide>true</code> at runtime.</p>\n<h1 id="uses"><a class="header" href="#uses">Uses</a></h1>\n<p>Assertions are always checked in both debug and release builds, and cannot\nbe disabled. See <a href="%60debug_assert!%60"><cide>debug_assert!</code></a> for assertions that are not enabled in\nrelease builds by default.</p>\n<p>Unsafe code may rely on <cide>assert!</code> to enforce run-time invariants that, if\nviolated could lead to unsafety.</p>\n<p>Other use-cases of <cide>assert!</code> include testing and enforcing run-time\ninvariants in safe code (whose violation cannot result in unsafety).</p>\n<h1 id="custom-messages"><a class="header" href="#custom-messages">Custom Messages</a></h1>\n<p>This macro has a second form, where a custom panic message can\nbe provided with or without arguments for formatting. See <a href="../std/fmt/index.html"><cide>std::fmt</code></a>\nfor syntax for this form. Expressions used as format arguments will only\nbe evaluated if the assertion fails.</p>\n<h1 id="examples-2"><a class="header" href="#examples-2">Examples</a></h1>\n<per><cide>// the panic message for these assertions is the stringified value of the\n// expression given.\nassert!(true);\n\nfn some_computation() -&gt; bool { true } // a very simple function\n\nassert!(some_computation());\n\n// assert with a custom message\nlet x = true;\nassert!(x, &quot;x wasn#$%t true!&quot;);\n\nlet a = 3; let b = 27;\nassert!(a + b == 30, &quot;a = {}, b = {}&quot;, a, b);\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn smaller_cannot_hold_larger()\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">pub fn add_two(a: i32) -&gt; i32\n</code></pre>\n','<per><cide class="language-rust">a: i32\n</code></pre>\n','<per><cide class="language-rust">i32\n</code></pre>\n<hr />\n<p>The 32-bit signed integer type.</p>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn it_adds_two()\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">pub fn greeting(name: &amp;str) -&gt; String\n</code></pre>\n','<per><cide class="language-rust">name: &amp;str\n</code></pre>\n','<per><cide class="language-rust">str\n</code></pre>\n<hr />\n<p>String slices.</p>\n<p><em><a href="crate::str">See also the <cide>std::str</code> module</a>.</em></p>\n<p>The <cide>str</code> type, also called a #$%string slice#$%, is the most primitive string\ntype. It is usually seen in its borrowed form, <cide>&amp;str</code>. It is also the type\nof string literals, <cide>&amp;#$%static str</code>.</p>\n<p>String slices are always valid UTF-8.</p>\n<h1 id="examples-3"><a class="header" href="#examples-3">Examples</a></h1>\n<p>String literals are string slices:</p>\n<per><cide>let hello = &quot;Hello, world!&quot;;\n\n// with an explicit type annotation\nlet hello: &amp;#$%static str = &quot;Hello, world!&quot;;\n</code></pre>\n<p>They are <cide>#$%static</code> because they#$%re stored directly in the final binary, and\nso will be valid for the <cide>#$%static</code> duration.</p>\n<h1 id="representation"><a class="header" href="#representation">Representation</a></h1>\n<p>A <cide>&amp;str</code> is made up of two components: a pointer to some bytes, and a\nlength. You can look at these with the <a href="str::as_ptr"><cide>as_ptr</code></a> and <a href="str::len"><cide>len</code></a> methods:</p>\n<per><cide>use std::slice;\nuse std::str;\n\nlet story = &quot;Once upon a time...&quot;;\n\nlet ptr = story.as_ptr();\nlet len = story.len();\n\n// story has nineteen bytes\nassert_eq!(19, len);\n\n// We can re-build a str out of ptr and len. This is all unsafe because\n// we are responsible for making sure the two components are valid:\nlet s = unsafe {\n    // First, we build a &amp;[u8]...\n    let slice = slice::from_raw_parts(ptr, len);\n\n    // ... and then convert that slice into a string slice\n    str::from_utf8(slice)\n};\n\nassert_eq!(s, Ok(story));\n</code></pre>\n<p>Note: This example shows the internals of <cide>&amp;str</code>. <cide>unsafe</code> should not be\nused to get a string slice under normal circumstances. Use <cide>as_str</code>\ninstead.</p>\n','<per><cide class="language-rust">alloc::string\n</code></pre>\n<per><cide class="language-rust">pub struct String\n</code></pre>\n<hr />\n<p>A UTF-8–encoded, growable string.</p>\n<p>The <cide>String</code> type is the most common string type that has ownership over the\ncontents of the string. It has a close relationship with its borrowed\ncounterpart, the primitive <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>.</p>\n<h1 id="examples-4"><a class="header" href="#examples-4">Examples</a></h1>\n<p>You can create a <cide>String</code> from <a href="https://docs.rs/alloc/*/alloc/str/index.html">a literal string</a> with <a href="https://docs.rs/core/*/core/convert/trait.From.html#tymethod.from"><cide>String::from</code></a>:</p>\n<per><cide>let hello = String::from(&quot;Hello, world!&quot;);\n</code></pre>\n<p>You can append a <a href="%60char%60"><cide>char</code></a> to a <cide>String</code> with the <a href="String::push"><cide>push</code></a> method, and\nappend a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a> with the <a href="String::push_str"><cide>push_str</code></a> method:</p>\n<per><cide>let mut hello = String::from(&quot;Hello, &quot;);\n\nhello.push(#$%w#$%);\nhello.push_str(&quot;orld!&quot;);\n</code></pre>\n<p>If you have a vector of UTF-8 bytes, you can create a <cide>String</code> from it with\nthe <a href="String::from_utf8"><cide>from_utf8</code></a> method:</p>\n<per><cide>// some bytes, in a vector\nlet sparkle_heart = vec![240, 159, 146, 150];\n\n// We know these bytes are valid, so we#$%ll use `unwrap()`.\nlet sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n\nassert_eq!(&quot;💖&quot;, sparkle_heart);\n</code></pre>\n<h1 id="utf-8"><a class="header" href="#utf-8">UTF-8</a></h1>\n<p><cide>String</code>s are always valid UTF-8. This has a few implications, the first of\nwhich is that if you need a non-UTF-8 string, consider <a href="https://docs.rs/alloc/*/std/ffi/struct.OsString.html"><cide>OsString</code></a>. It is\nsimilar, but without the UTF-8 constraint. The second implication is that\nyou cannot index into a <cide>String</code>:</p>\n<per><cide class="language-compile_fail,E0277">let s = &quot;hello&quot;;\n\nprintln!(&quot;The first letter of s is {}&quot;, s[0]); // ERROR!!!\n</code></pre>\n<p>Indexing is intended to be a constant-time operation, but UTF-8 encoding\ndoes not allow us to do this. Furthermore, it#$%s not clear what sort of\nthing the index should return: a byte, a codepoint, or a grapheme cluster.\nThe <a href="str::bytes"><cide>bytes</code></a> and <a href="str::chars"><cide>chars</code></a> methods return iterators over the first\ntwo, respectively.</p>\n<h1 id="deref"><a class="header" href="#deref">Deref</a></h1>\n<p><cide>String</code>s implement <a href="https://docs.rs/core/*/core/ops/deref/trait.Deref.html"><cide>Deref</code></a><cide>&lt;Target=str&gt;</code>, and so inherit all of <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>#$%s\nmethods. In addition, this means that you can pass a <cide>String</code> to a\nfunction which takes a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a> by using an ampersand (<cide>&amp;</code>):</p>\n<per><cide>fn takes_str(s: &amp;str) { }\n\nlet s = String::from(&quot;Hello&quot;);\n\ntakes_str(&amp;s);\n</code></pre>\n<p>This will create a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a> from the <cide>String</code> and pass it in. This\nconversion is very inexpensive, and so generally, functions will accept\n<a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a>s as arguments unless they need a <cide>String</code> for some specific\nreason.</p>\n<p>In certain cases Rust doesn#$%t have enough information to make this\nconversion, known as <a href="https://docs.rs/core/*/core/ops/deref/trait.Deref.html"><cide>Deref</code></a> coercion. In the following example a string\nslice <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;#$%a str</code></a> implements the trait <cide>TraitExample</code>, and the function\n<cide>example_func</code> takes anything that implements the trait. In this case Rust\nwould need to make two implicit conversions, which Rust doesn#$%t have the\nmeans to do. For that reason, the following example will not compile.</p>\n<per><cide class="language-compile_fail,E0277">trait TraitExample {}\n\nimpl&lt;#$%a&gt; TraitExample for &amp;#$%a str {}\n\nfn example_func&lt;A: TraitExample&gt;(example_arg: A) {}\n\nlet example_string = String::from(&quot;example_string&quot;);\nexample_func(&amp;example_string);\n</code></pre>\n<p>There are two options that would work instead. The first would be to\nchange the line <cide>example_func(&amp;example_string);</code> to\n<cide>example_func(example_string.as_str());</code>, using the method <a href="String::as_str"><cide>as_str()</code></a>\nto explicitly extract the string slice containing the string. The second\nway changes <cide>example_func(&amp;example_string);</code> to\n<cide>example_func(&amp;*example_string);</code>. In this case we are dereferencing a\n<cide>String</code> to a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>, then referencing the <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a> back to\n<a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a>. The second way is more idiomatic, however both work to do the\nconversion explicitly rather than relying on the implicit conversion.</p>\n<h1 id="representation-1"><a class="header" href="#representation-1">Representation</a></h1>\n<p>A <cide>String</code> is made up of three components: a pointer to some bytes, a\nlength, and a capacity. The pointer points to an internal buffer <cide>String</code>\nuses to store its data. The length is the number of bytes currently stored\nin the buffer, and the capacity is the size of the buffer in bytes. As such,\nthe length will always be less than or equal to the capacity.</p>\n<p>This buffer is always stored on the heap.</p>\n<p>You can look at these with the <a href="str::as_ptr"><cide>as_ptr</code></a>, <a href="String::len"><cide>len</code></a>, and <a href="String::capacity"><cide>capacity</code></a>\nmethods:</p>\n<per><cide>use std::mem;\n\nlet story = String::from(&quot;Once upon a time...&quot;);\n\n// Prevent automatically dropping the String#$%s data\nlet mut story = mem::ManuallyDrop::new(story);\n\nlet ptr = story.as_mut_ptr();\nlet len = story.len();\nlet capacity = story.capacity();\n\n// story has nineteen bytes\nassert_eq!(19, len);\n\n// We can re-build a String out of ptr, len, and capacity. This is all\n// unsafe because we are responsible for making sure the components are\n// valid:\nlet s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;\n\nassert_eq!(String::from(&quot;Once upon a time...&quot;), s);\n</code></pre>\n<p>If a <cide>String</code> has enough capacity, adding elements to it will not\nre-allocate. For example, consider this program:</p>\n<per><cide>let mut s = String::new();\n\nprintln!(&quot;{}&quot;, s.capacity());\n\nfor _ in 0..5 {\n    s.push_str(&quot;hello&quot;);\n    println!(&quot;{}&quot;, s.capacity());\n}\n</code></pre>\n<p>This will output the following:</p>\n<per><cide class="language-text">0\n5\n10\n20\n20\n40\n</code></pre>\n<p>At first, we have no memory allocated at all, but as we append to the\nstring, it increases its capacity appropriately. If we instead use the\n<a href="String::with_capacity"><cide>with_capacity</code></a> method to allocate the correct capacity initially:</p>\n<per><cide>let mut s = String::with_capacity(25);\n\nprintln!(&quot;{}&quot;, s.capacity());\n\nfor _ in 0..5 {\n    s.push_str(&quot;hello&quot;);\n    println!(&quot;{}&quot;, s.capacity());\n}\n</code></pre>\n<p>We end up with a different output:</p>\n<per><cide class="language-text">25\n25\n25\n25\n25\n25\n</code></pre>\n<p>Here, there#$%s no need to allocate more memory inside the loop.</p>\n','<per><cide class="language-rust">alloc\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! format\n</code></pre>\n<hr />\n<p>Creates a <cide>String</code> using interpolation of runtime expressions.</p>\n<p>The first argument <cide>format!</code> receives is a format string. This must be a string\nliteral. The power of the formatting string is in the <cide>{}</code>s contained.</p>\n<p>Additional parameters passed to <cide>format!</code> replace the <cide>{}</code>s within the\nformatting string in the order given unless named or positional parameters\nare used; see <a href="../std/fmt/index.html"><cide>std::fmt</code></a> for more information.</p>\n<p>A common use for <cide>format!</code> is concatenation and interpolation of strings.\nThe same convention is used with <a href="../std/macro.print.html"><cide>print!</code></a> and <a href="core::write"><cide>write!</code></a> macros,\ndepending on the intended destination of the string.</p>\n<p>To convert a single value to a string, use the <a href="crate::string::ToString"><cide>to_string</code></a> method. This\nwill use the <a href="core::fmt::Display"><cide>Display</code></a> formatting trait.</p>\n<h1 id="panics"><a class="header" href="#panics">Panics</a></h1>\n<p><cide>format!</code> panics if a formatting trait implementation returns an error.\nThis indicates an incorrect implementation\nsince <cide>fmt::Write for String</code> never returns an error itself.</p>\n<h1 id="examples-5"><a class="header" href="#examples-5">Examples</a></h1>\n<per><cide>format!(&quot;test&quot;);\nformat!(&quot;hello {}&quot;, &quot;world!&quot;);\nformat!(&quot;x = {}, y = {y}&quot;, 10, y = 30);\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn greeting_contains_name()\n</code></pre>\n','<per><cide class="language-rust">let result: String\n</code></pre>\n','<per><cide class="language-rust">core::str\n</code></pre>\n<per><cide class="language-rust">pub fn contains&lt;#$%a, P&gt;(&amp;#$%a self, pat: P) -&gt; bool\nwhere\n    P: Pattern&lt;#$%a&gt;,\n</code></pre>\n<hr />\n<p>Returns <cide>true</code> if the given pattern matches a sub-slice of\nthis string slice.</p>\n<p>Returns <cide>false</code> if it does not.</p>\n<p>The <a href="https://docs.rs/core/*/core/str/pattern/index.html">pattern</a> can be a <cide>&amp;str</code>, <a href="https://docs.rs/core/*/core/char/index.html"><cide>char</code></a>, a slice of <a href="https://docs.rs/core/*/core/char/index.html"><cide>char</code></a>s, or a\nfunction or closure that determines if a character matches.</p>\n<h1 id="examples-6"><a class="header" href="#examples-6">Examples</a></h1>\n<p>Basic usage:</p>\n<per><cide>let bananas = &quot;bananas&quot;;\n\nassert!(bananas.contains(&quot;nana&quot;));\nassert!(!bananas.contains(&quot;apples&quot;));\n</code></pre>\n','<per><cide class="language-rust">core::convert::From\n</code></pre>\n<per><cide class="language-rust">pub fn from(_: T) -&gt; Self\n</code></pre>\n<hr />\n<p>Performs the conversion.</p>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">pub struct Guess\n</code></pre>\n','<per><cide class="language-rust">playcrate::Guess\n</code></pre>\n<per><cide class="language-rust">value: i32\n</code></pre>\n','<per><cide class="language-rust">playcrate::Guess\n</code></pre>\n<per><cide class="language-rust">pub fn new(value: i32) -&gt; Guess\n</code></pre>\n','<per><cide class="language-rust">value: i32\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn greater_than_100()\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn it_works() -&gt; Result&lt;(), String&gt;\n</code></pre>\n','<per><cide class="language-rust">core::result\n</code></pre>\n<per><cide class="language-rust">pub enum Result&lt;T, E&gt;\n</code></pre>\n<hr />\n<p><cide>Result</code> is a type that represents either success (<a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Ok</code></a>) or failure (<a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Err</code></a>).</p>\n<p>See the <a href="https://docs.rs/core/*/core/result/index.html">documentation</a> for details.</p>\n','<per><cide class="language-rust">core::result::Result\n</code></pre>\n<per><cide class="language-rust">Ok(T)\n</code></pre>\n<hr />\n<p>Contains the success value</p>\n','<per><cide class="language-rust">core::result::Result\n</code></pre>\n<per><cide class="language-rust">Err(E)\n</code></pre>\n<hr />\n<p>Contains the error value</p>\n',].map((x)=>x.replaceAll('#$%', "'").replaceAll('<per', '<pre').replaceAll('<cide', '<code'));
    window.onload = () => {
        console.log("hello");
        tippy('.ra', {
            content: (x) => {
                const div = document.createElement('div');
                div.innerHTML = hoverData[x.dataset.hover];
                div.className = 'hover-holder';
                div.querySelectorAll('code').forEach((y) => y.innerHTML = hljs.highlight('rust', y.innerText).value);
                return div;
            },
            allowHTML: true,
            delay: [200, 0],
            interactive: true,
            maxWidth: '80vw',
            appendTo: document.querySelector('.content'),
        });
    };
</script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="ch11-00-testing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="ch11-02-running-tests.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="ch11-00-testing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="ch11-02-running-tests.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="ferris.js"></script>
        
        
    </body>
</html>
