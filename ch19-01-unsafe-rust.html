<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unsafe Rust - The Rust Programming Language</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="ferris.css">
                <link rel="stylesheet" href="theme/2018-edition.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References and Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> The Slice Type</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> How to Write Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlling How Tests Are Run</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html" class="active"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.inlay-hint, .inlay-hint * {
    border-radius: .4em;
}

.light .inlay-hint, .rust .inlay-hint {
    background-color: #dcc;
    color: #777;
}

.ayu .inlay-hint, .navy .inlay-hint, .coal .inlay-hint {
    background-color: #444;
    color: #999;
}

.inlay-hint {
    font-size: 0.8em;
    user-select: none;
}
.hover-holder {
    max-height: 40vh;
    overflow: auto;
}

.tippy-content {
    background-color: var(--bg);
    color: var(--fg);
}
</style>## Unsafe Rust
<p>All the code we’ve discussed so far has had Rust’s memory safety guarantees
enforced at compile time. However, Rust has a second language hidden inside it
that doesn’t enforce these memory safety guarantees: it’s called <em>unsafe Rust</em>
and works just like regular Rust, but gives us extra superpowers.</p>
<p>Unsafe Rust exists because, by nature, static analysis is conservative. When
the compiler tries to determine whether or not code upholds the guarantees,
it’s better for it to reject some valid programs rather than accept some
invalid programs. Although the code <em>might</em> be okay, if the Rust compiler
doesn’t have enough information to be confident, it will reject the code. In
these cases, you can use unsafe code to tell the compiler, “Trust me, I know
what I’m doing.” The downside is that you use it at your own risk: if you use
unsafe code incorrectly, problems due to memory unsafety, such as null pointer
dereferencing, can occur.</p>
<p>Another reason Rust has an unsafe alter ego is that the underlying computer
hardware is inherently unsafe. If Rust didn’t let you do unsafe operations, you
couldn’t do certain tasks. Rust needs to allow you to do low-level systems
programming, such as directly interacting with the operating system or even
writing your own operating system. Working with low-level systems programming
is one of the goals of the language. Let’s explore what we can do with unsafe
Rust and how to do it.</p>
<h3 id="unsafe-superpowers"><a class="header" href="#unsafe-superpowers">Unsafe Superpowers</a></h3>
<p>To switch to unsafe Rust, use the <code>unsafe</code> keyword and then start a new block
that holds the unsafe code. You can take five actions in unsafe Rust, called
<em>unsafe superpowers</em>, that you can’t in safe Rust. Those superpowers include
the ability to:</p>
<ul>
<li>Dereference a raw pointer</li>
<li>Call an unsafe function or method</li>
<li>Access or modify a mutable static variable</li>
<li>Implement an unsafe trait</li>
<li>Access fields of <code>union</code>s</li>
</ul>
<p>It’s important to understand that <code>unsafe</code> doesn’t turn off the borrow checker
or disable any other of Rust’s safety checks: if you use a reference in unsafe
code, it will still be checked. The <code>unsafe</code> keyword only gives you access to
these five features that are then not checked by the compiler for memory
safety. You’ll still get some degree of safety inside of an unsafe block.</p>
<p>In addition, <code>unsafe</code> does not mean the code inside the block is necessarily
dangerous or that it will definitely have memory safety problems: the intent is
that as the programmer, you’ll ensure the code inside an <code>unsafe</code> block will
access memory in a valid way.</p>
<p>People are fallible, and mistakes will happen, but by requiring these five
unsafe operations to be inside blocks annotated with <code>unsafe</code> you’ll know that
any errors related to memory safety must be within an <code>unsafe</code> block. Keep
<code>unsafe</code> blocks small; you’ll be thankful later when you investigate memory
bugs.</p>
<p>To isolate unsafe code as much as possible, it’s best to enclose unsafe code
within a safe abstraction and provide a safe API, which we’ll discuss later in
the chapter when we examine unsafe functions and methods. Parts of the standard
library are implemented as safe abstractions over unsafe code that has been
audited. Wrapping unsafe code in a safe abstraction prevents uses of <code>unsafe</code>
from leaking out into all the places that you or your users might want to use
the functionality implemented with <code>unsafe</code> code, because using a safe
abstraction is safe.</p>
<p>Let’s look at each of the five unsafe superpowers in turn. We’ll also look at
some abstractions that provide a safe interface to unsafe code.</p>
<h3 id="dereferencing-a-raw-pointer"><a class="header" href="#dereferencing-a-raw-pointer">Dereferencing a Raw Pointer</a></h3>
<p>In Chapter 4, in the <a href="ch04-02-references-and-borrowing.html#dangling-references">“Dangling References”</a><!-- ignore
--> section, we mentioned that the compiler ensures references are always
valid. Unsafe Rust has two new types called <em>raw pointers</em> that are similar to
references. As with references, raw pointers can be immutable or mutable and
are written as <code>*const T</code> and <code>*mut T</code>, respectively. The asterisk isn’t the
dereference operator; it’s part of the type name. In the context of raw
pointers, <em>immutable</em> means that the pointer can’t be directly assigned to
after being dereferenced.</p>
<p>Different from references and smart pointers, raw pointers:</p>
<ul>
<li>Are allowed to ignore the borrowing rules by having both immutable and
mutable pointers or multiple mutable pointers to the same location</li>
<li>Aren’t guaranteed to point to valid memory</li>
<li>Are allowed to be null</li>
<li>Don’t implement any automatic cleanup</li>
</ul>
<p>By opting out of having Rust enforce these guarantees, you can give up
guaranteed safety in exchange for greater performance or the ability to
interface with another language or hardware where Rust’s guarantees don’t apply.</p>
<p>Listing 19-1 shows how to create an immutable and a mutable raw pointer from
references.</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">fn main() {
</span>    let mut <span class="ra" data-hover="1">num</span><span class="inlay-hint">: i32</span> = 5;

    let <span class="ra" data-hover="2">r1</span><span class="inlay-hint">: *const i32</span> = &amp;<span class="ra" data-hover="1">num</span> as *const <span class="ra" data-hover="3">i32</span>;
    let <span class="ra" data-hover="4">r2</span><span class="inlay-hint">: *mut i32</span> = &amp;mut <span class="ra" data-hover="1">num</span> as *mut <span class="ra" data-hover="3">i32</span>;
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 19-1: Creating raw pointers from references</span></p>
<p>Notice that we don’t include the <code>unsafe</code> keyword in this code. We can create
raw pointers in safe code; we just can’t dereference raw pointers outside an
unsafe block, as you’ll see in a bit.</p>
<p>We’ve created raw pointers by using <code>as</code> to cast an immutable and a mutable
reference into their corresponding raw pointer types. Because we created them
directly from references guaranteed to be valid, we know these particular raw
pointers are valid, but we can’t make that assumption about just any raw
pointer.</p>
<p>Next, we’ll create a raw pointer whose validity we can’t be so certain of.
Listing 19-2 shows how to create a raw pointer to an arbitrary location in
memory. Trying to use arbitrary memory is undefined: there might be data at
that address or there might not, the compiler might optimize the code so there
is no memory access, or the program might error with a segmentation fault.
Usually, there is no good reason to write code like this, but it is possible.</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">fn main() {
</span>    let <span class="ra" data-hover="5">address</span><span class="inlay-hint">: usize</span> = 0x012345usize;
    let <span class="ra" data-hover="6">r</span><span class="inlay-hint">: *const i32</span> = <span class="ra" data-hover="5">address</span> as *const <span class="ra" data-hover="3">i32</span>;
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 19-2: Creating a raw pointer to an arbitrary
memory address</span></p>
<p>Recall that we can create raw pointers in safe code, but we can’t <em>dereference</em>
raw pointers and read the data being pointed to. In Listing 19-3, we use the
dereference operator <code>*</code> on a raw pointer that requires an <code>unsafe</code> block.</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">fn main() {
</span>    let mut <span class="ra" data-hover="1">num</span><span class="inlay-hint">: i32</span> = 5;

    let <span class="ra" data-hover="2">r1</span><span class="inlay-hint">: *const i32</span> = &amp;<span class="ra" data-hover="1">num</span> as *const <span class="ra" data-hover="3">i32</span>;
    let <span class="ra" data-hover="4">r2</span><span class="inlay-hint">: *mut i32</span> = &amp;mut <span class="ra" data-hover="1">num</span> as *mut <span class="ra" data-hover="3">i32</span>;

    unsafe {
        <span class="ra" data-hover="7">println</span>!("r1 is: {}", *<span class="ra" data-hover="2">r1</span>);
        <span class="ra" data-hover="7">println</span>!("r2 is: {}", *<span class="ra" data-hover="4">r2</span>);
    }
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 19-3: Dereferencing raw pointers within an
<code>unsafe</code> block</span></p>
<p>Creating a pointer does no harm; it’s only when we try to access the value that
it points at that we might end up dealing with an invalid value.</p>
<p>Note also that in Listing 19-1 and 19-3, we created <code>*const i32</code> and <code>*mut i32</code>
raw pointers that both pointed to the same memory location, where <code>num</code> is
stored. If we instead tried to create an immutable and a mutable reference to
<code>num</code>, the code would not have compiled because Rust’s ownership rules don’t
allow a mutable reference at the same time as any immutable references. With
raw pointers, we can create a mutable pointer and an immutable pointer to the
same location and change data through the mutable pointer, potentially creating
a data race. Be careful!</p>
<p>With all of these dangers, why would you ever use raw pointers? One major use
case is when interfacing with C code, as you’ll see in the next section,
<a href="#calling-an-unsafe-function-or-method">“Calling an Unsafe Function or
Method.”</a><!-- ignore --> Another case is
when building up safe abstractions that the borrow checker doesn’t understand.
We’ll introduce unsafe functions and then look at an example of a safe
abstraction that uses unsafe code.</p>
<h3 id="calling-an-unsafe-function-or-method"><a class="header" href="#calling-an-unsafe-function-or-method">Calling an Unsafe Function or Method</a></h3>
<p>The second type of operation that requires an unsafe block is calls to unsafe
functions. Unsafe functions and methods look exactly like regular functions and
methods, but they have an extra <code>unsafe</code> before the rest of the definition. The
<code>unsafe</code> keyword in this context indicates the function has requirements we
need to uphold when we call this function, because Rust can’t guarantee we’ve
met these requirements. By calling an unsafe function within an <code>unsafe</code> block,
we’re saying that we’ve read this function’s documentation and take
responsibility for upholding the function’s contracts.</p>
<p>Here is an unsafe function named <code>dangerous</code> that doesn’t do anything in its
body:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">fn main() {
</span>    unsafe fn <span class="ra" data-hover="8">dangerous</span>() {}

    unsafe {
        <span class="ra" data-hover="8">dangerous</span>();
    }
<span class="boring">}
</span>
</code></pre></pre>
<p>We must call the <code>dangerous</code> function within a separate <code>unsafe</code> block. If we
try to call <code>dangerous</code> without the <code>unsafe</code> block, we’ll get an error:</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example` due to previous error
</code></pre>
<p>By inserting the <code>unsafe</code> block around our call to <code>dangerous</code>, we’re asserting
to Rust that we’ve read the function’s documentation, we understand how to use
it properly, and we’ve verified that we’re fulfilling the contract of the
function.</p>
<p>Bodies of unsafe functions are effectively <code>unsafe</code> blocks, so to perform other
unsafe operations within an unsafe function, we don’t need to add another
<code>unsafe</code> block.</p>
<h4 id="creating-a-safe-abstraction-over-unsafe-code"><a class="header" href="#creating-a-safe-abstraction-over-unsafe-code">Creating a Safe Abstraction over Unsafe Code</a></h4>
<p>Just because a function contains unsafe code doesn’t mean we need to mark the
entire function as unsafe. In fact, wrapping unsafe code in a safe function is
a common abstraction. As an example, let’s study a function from the standard
library, <code>split_at_mut</code>, that requires some unsafe code and explore how we
might implement it. This safe method is defined on mutable slices: it takes one
slice and makes it two by splitting the slice at the index given as an
argument. Listing 19-4 shows how to use <code>split_at_mut</code>.</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">fn main() {
</span>    let mut <span class="ra" data-hover="9">v</span><span class="inlay-hint">: Vec&lt;i32&gt;</span> = <span class="ra" data-hover="10">vec</span>![1, 2, 3, 4, 5, 6];

    let <span class="ra" data-hover="11">r</span><span class="inlay-hint">: &amp;mut [i32]</span> = &amp;mut <span class="ra" data-hover="9">v</span>[..];

    let (<span class="ra" data-hover="12">a</span><span class="inlay-hint">: &amp;mut [i32]</span>, <span class="ra" data-hover="13">b</span><span class="inlay-hint">: &amp;mut [i32]</span>) = <span class="ra" data-hover="11">r</span>.<span class="ra" data-hover="14">split_at_mut</span>(<span class="inlay-hint">mid: </span>3);

    <span class="ra" data-hover="15">assert_eq</span>!(<span class="ra" data-hover="12">a</span>, &amp;mut [1, 2, 3]);
    <span class="ra" data-hover="15">assert_eq</span>!(<span class="ra" data-hover="13">b</span>, &amp;mut [4, 5, 6]);
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 19-4: Using the safe <code>split_at_mut</code>
function</span></p>
<p>We can’t implement this function using only safe Rust. An attempt might look
something like Listing 19-5, which won’t compile. For simplicity, we’ll
implement <code>split_at_mut</code> as a function rather than a method and only for slices
of <code>i32</code> values rather than for a generic type <code>T</code>.</p>
<pre><pre class="playground"><code class="language-rust hljs">fn <span class="ra" data-hover="16">split_at_mut</span>(<span class="ra" data-hover="17">slice</span>: &amp;mut [<span class="ra" data-hover="3">i32</span>], <span class="ra" data-hover="18">mid</span>: <span class="ra" data-hover="19">usize</span>) -&gt; (&amp;mut [<span class="ra" data-hover="3">i32</span>], &amp;mut [<span class="ra" data-hover="3">i32</span>]) {
    let <span class="ra" data-hover="20">len</span><span class="inlay-hint">: usize</span> = <span class="ra" data-hover="17">slice</span>.<span class="ra" data-hover="21">len</span>();

    <span class="ra" data-hover="22">assert</span>!(<span class="ra" data-hover="18">mid</span> &lt;= <span class="ra" data-hover="20">len</span>);

    (&amp;mut <span class="ra" data-hover="17">slice</span>[..<span class="ra" data-hover="18">mid</span>], &amp;mut <span class="ra" data-hover="17">slice</span>[<span class="ra" data-hover="18">mid</span>..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&mut vector, 3);
</span><span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 19-5: An attempted implementation of
<code>split_at_mut</code> using only safe Rust</span></p>
<p>This function first gets the total length of the slice. Then it asserts that
the index given as a parameter is within the slice by checking whether it’s
less than or equal to the length. The assertion means that if we pass an index
that is greater than the length to split the slice at, the function will panic
before it attempts to use that index.</p>
<p>Then we return two mutable slices in a tuple: one from the start of the
original slice to the <code>mid</code> index and another from <code>mid</code> to the end of the
slice.</p>
<p>When we try to compile the code in Listing 19-5, we’ll get an error.</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 --&gt; src/main.rs:6:30
  |
1 | fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                        - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut slice[..mid], &amp;mut slice[mid..])
  |     -------------------------^^^^^--------
  |     |     |                  |
  |     |     |                  second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*slice` is borrowed for `'1`

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example` due to previous error
</code></pre>
<p>Rust’s borrow checker can’t understand that we’re borrowing different parts of
the slice; it only knows that we’re borrowing from the same slice twice.
Borrowing different parts of a slice is fundamentally okay because the two
slices aren’t overlapping, but Rust isn’t smart enough to know this. When we
know code is okay, but Rust doesn’t, it’s time to reach for unsafe code.</p>
<p>Listing 19-6 shows how to use an <code>unsafe</code> block, a raw pointer, and some calls
to unsafe functions to make the implementation of <code>split_at_mut</code> work.</p>
<pre><pre class="playground"><code class="language-rust hljs">use <span class="ra" data-hover="26">std</span>::<span class="ra" data-hover="27">slice</span>;

fn <span class="ra" data-hover="16">split_at_mut</span>(<span class="ra" data-hover="17">slice</span>: &amp;mut [<span class="ra" data-hover="3">i32</span>], <span class="ra" data-hover="18">mid</span>: <span class="ra" data-hover="19">usize</span>) -&gt; (&amp;mut [<span class="ra" data-hover="3">i32</span>], &amp;mut [<span class="ra" data-hover="3">i32</span>]) {
    let <span class="ra" data-hover="20">len</span><span class="inlay-hint">: usize</span> = <span class="ra" data-hover="17">slice</span>.<span class="ra" data-hover="21">len</span>();
    let <span class="ra" data-hover="28">ptr</span><span class="inlay-hint">: *mut i32</span> = <span class="ra" data-hover="17">slice</span>.<span class="ra" data-hover="29">as_mut_ptr</span>();

    <span class="ra" data-hover="22">assert</span>!(<span class="ra" data-hover="18">mid</span> &lt;= <span class="ra" data-hover="20">len</span>);

    unsafe {
        (
            <span class="ra" data-hover="27">slice</span>::<span class="ra" data-hover="30">from_raw_parts_mut</span>(<span class="ra" data-hover="28"><span class="inlay-hint">data: </span>ptr</span>, <span class="ra" data-hover="18"><span class="inlay-hint">len: </span>mid</span>),
            <span class="ra" data-hover="27">slice</span>::<span class="ra" data-hover="30">from_raw_parts_mut</span>(<span class="ra" data-hover="28"><span class="inlay-hint">data: </span>ptr</span>.<span class="ra" data-hover="31">add</span>(<span class="ra" data-hover="18"><span class="inlay-hint">count: </span>mid</span>), <span class="ra" data-hover="20"><span class="inlay-hint">len: </span>len</span> - <span class="ra" data-hover="18">mid</span>),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&mut vector, 3);
</span><span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 19-6: Using unsafe code in the implementation of
the <code>split_at_mut</code> function</span></p>
<p>Recall from <a href="ch04-03-slices.html#the-slice-type">“The Slice Type”</a><!-- ignore --> section in
Chapter 4 that slices are a pointer to some data and the length of the slice.
We use the <code>len</code> method to get the length of a slice and the <code>as_mut_ptr</code>
method to access the raw pointer of a slice. In this case, because we have a
mutable slice to <code>i32</code> values, <code>as_mut_ptr</code> returns a raw pointer with the type
<code>*mut i32</code>, which we’ve stored in the variable <code>ptr</code>.</p>
<p>We keep the assertion that the <code>mid</code> index is within the slice. Then we get to
the unsafe code: the <code>slice::from_raw_parts_mut</code> function takes a raw pointer
and a length, and it creates a slice. We use this function to create a slice
that starts from <code>ptr</code> and is <code>mid</code> items long. Then we call the <code>add</code>
method on <code>ptr</code> with <code>mid</code> as an argument to get a raw pointer that starts at
<code>mid</code>, and we create a slice using that pointer and the remaining number of
items after <code>mid</code> as the length.</p>
<p>The function <code>slice::from_raw_parts_mut</code> is unsafe because it takes a raw
pointer and must trust that this pointer is valid. The <code>add</code> method on raw
pointers is also unsafe, because it must trust that the offset location is also
a valid pointer. Therefore, we had to put an <code>unsafe</code> block around our calls to
<code>slice::from_raw_parts_mut</code> and <code>add</code> so we could call them. By looking at
the code and by adding the assertion that <code>mid</code> must be less than or equal to
<code>len</code>, we can tell that all the raw pointers used within the <code>unsafe</code> block
will be valid pointers to data within the slice. This is an acceptable and
appropriate use of <code>unsafe</code>.</p>
<p>Note that we don’t need to mark the resulting <code>split_at_mut</code> function as
<code>unsafe</code>, and we can call this function from safe Rust. We’ve created a safe
abstraction to the unsafe code with an implementation of the function that uses
<code>unsafe</code> code in a safe way, because it creates only valid pointers from the
data this function has access to.</p>
<p>In contrast, the use of <code>slice::from_raw_parts_mut</code> in Listing 19-7 would
likely crash when the slice is used. This code takes an arbitrary memory
location and creates a slice 10,000 items long.</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">fn main() {
</span>    use <span class="ra" data-hover="26">std</span>::<span class="ra" data-hover="27">slice</span>;

    let <span class="ra" data-hover="5">address</span><span class="inlay-hint">: usize</span> = 0x01234usize;
    let <span class="ra" data-hover="32">r</span><span class="inlay-hint">: *mut i32</span> = <span class="ra" data-hover="5">address</span> as *mut <span class="ra" data-hover="3">i32</span>;

    let <span class="ra" data-hover="33">slice</span>: &amp;[<span class="ra" data-hover="3">i32</span>] = unsafe { <span class="ra" data-hover="27">slice</span>::<span class="ra" data-hover="30">from_raw_parts_mut</span>(<span class="ra" data-hover="32"><span class="inlay-hint">data: </span>r</span>, <span class="inlay-hint">len: </span>10000) };
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 19-7: Creating a slice from an arbitrary memory
location</span></p>
<p>We don’t own the memory at this arbitrary location, and there is no guarantee
that the slice this code creates contains valid <code>i32</code> values. Attempting to use
<code>slice</code> as though it’s a valid slice results in undefined behavior.</p>
<h4 id="using-extern-functions-to-call-external-code"><a class="header" href="#using-extern-functions-to-call-external-code">Using <code>extern</code> Functions to Call External Code</a></h4>
<p>Sometimes, your Rust code might need to interact with code written in another
language. For this, Rust has a keyword, <code>extern</code>, that facilitates the creation
and use of a <em>Foreign Function Interface (FFI)</em>. An FFI is a way for a
programming language to define functions and enable a different (foreign)
programming language to call those functions.</p>
<p>Listing 19-8 demonstrates how to set up an integration with the <code>abs</code> function
from the C standard library. Functions declared within <code>extern</code> blocks are
always unsafe to call from Rust code. The reason is that other languages don’t
enforce Rust’s rules and guarantees, and Rust can’t check them, so
responsibility falls on the programmer to ensure safety.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern "C" {
    fn <span class="ra" data-hover="34">abs</span>(<span class="ra" data-hover="35">input</span>: <span class="ra" data-hover="3">i32</span>) -&gt; <span class="ra" data-hover="3">i32</span>;
}

fn <span class="ra" data-hover="0">main</span>() {
    unsafe {
        <span class="ra" data-hover="7">println</span>!("Absolute value of -3 according to C: {}", <span class="ra" data-hover="34">abs</span>(-3));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-8: Declaring and calling an <code>extern</code> function
defined in another language</span></p>
<p>Within the <code>extern &quot;C&quot;</code> block, we list the names and signatures of external
functions from another language we want to call. The <code>&quot;C&quot;</code> part defines which
<em>application binary interface (ABI)</em> the external function uses: the ABI
defines how to call the function at the assembly level. The <code>&quot;C&quot;</code> ABI is the
most common and follows the C programming language’s ABI.</p>
<blockquote>
<h4 id="calling-rust-functions-from-other-languages"><a class="header" href="#calling-rust-functions-from-other-languages">Calling Rust Functions from Other Languages</a></h4>
<p>We can also use <code>extern</code> to create an interface that allows other languages
to call Rust functions. Instead of an <code>extern</code> block, we add the <code>extern</code>
keyword and specify the ABI to use just before the <code>fn</code> keyword. We also need
to add a <code>#[no_mangle]</code> annotation to tell the Rust compiler not to mangle
the name of this function. <em>Mangling</em> is when a compiler changes the name
we’ve given a function to a different name that contains more information for
other parts of the compilation process to consume but is less human readable.
Every programming language compiler mangles names slightly differently, so
for a Rust function to be nameable by other languages, we must disable the
Rust compiler’s name mangling.</p>
<p>In the following example, we make the <code>call_from_c</code> function accessible from
C code, after it’s compiled to a shared library and linked from C:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</blockquote>
<p></span><span class="boring">fn main() {
</span>&gt; #[no_mangle]
&gt; pub extern &quot;C&quot; fn <span class="ra" data-hover="36">call_from_c</span>() {
&gt;     <span class="ra" data-hover="7">println</span>!(&quot;Just called a Rust function from C!&quot;);
&gt; }
&gt; # }
</code></pre></pre>
&gt;</p>
<blockquote>
<p>This usage of <code>extern</code> does not require <code>unsafe</code>.</p>
</blockquote>
<h3 id="accessing-or-modifying-a-mutable-static-variable"><a class="header" href="#accessing-or-modifying-a-mutable-static-variable">Accessing or Modifying a Mutable Static Variable</a></h3>
<p>Until now, we’ve not talked about <em>global variables</em>, which Rust does support
but can be problematic with Rust’s ownership rules. If two threads are
accessing the same mutable global variable, it can cause a data race.</p>
<p>In Rust, global variables are called <em>static</em> variables. Listing 19-9 shows an
example declaration and use of a static variable with a string slice as a
value.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static <span class="ra" data-hover="37">HELLO_WORLD</span>: &amp;<span class="ra" data-hover="38">str</span> = "Hello, world!";

fn <span class="ra" data-hover="0">main</span>() {
    <span class="ra" data-hover="7">println</span>!("name is: {}", <span class="ra" data-hover="37">HELLO_WORLD</span>);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-9: Defining and using an immutable static
variable</span></p>
<p>Static variables are similar to constants, which we discussed in the
<a href="ch03-01-variables-and-mutability.html#differences-between-variables-and-constants">“Differences Between Variables and
Constants”</a><!-- ignore -->
section in Chapter 3. The names of static variables are in
<code>SCREAMING_SNAKE_CASE</code> by convention. Static variables can only store
references with the <code>'static</code> lifetime, which means the Rust compiler can
figure out the lifetime and we aren’t required to annotate it explicitly.
Accessing an immutable static variable is safe.</p>
<p>Constants and immutable static variables might seem similar, but a subtle
difference is that values in a static variable have a fixed address in memory.
Using the value will always access the same data. Constants, on the other hand,
are allowed to duplicate their data whenever they’re used.</p>
<p>Another difference between constants and static variables is that static
variables can be mutable. Accessing and modifying mutable static variables is
<em>unsafe</em>. Listing 19-10 shows how to declare, access, and modify a mutable
static variable named <code>COUNTER</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut <span class="ra" data-hover="39">COUNTER</span>: <span class="ra" data-hover="40">u32</span> = 0;

fn <span class="ra" data-hover="41">add_to_count</span>(<span class="ra" data-hover="42">inc</span>: <span class="ra" data-hover="40">u32</span>) {
    unsafe {
        <span class="ra" data-hover="39">COUNTER</span> += <span class="ra" data-hover="42">inc</span>;
    }
}

fn <span class="ra" data-hover="0">main</span>() {
    <span class="ra" data-hover="41">add_to_count</span>(<span class="inlay-hint">inc: </span>3);

    unsafe {
        <span class="ra" data-hover="7">println</span>!("COUNTER: {}", <span class="ra" data-hover="39">COUNTER</span>);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-10: Reading from or writing to a mutable
static variable is unsafe</span></p>
<p>As with regular variables, we specify mutability using the <code>mut</code> keyword. Any
code that reads or writes from <code>COUNTER</code> must be within an <code>unsafe</code> block. This
code compiles and prints <code>COUNTER: 3</code> as we would expect because it’s single
threaded. Having multiple threads access <code>COUNTER</code> would likely result in data
races.</p>
<p>With mutable data that is globally accessible, it’s difficult to ensure there
are no data races, which is why Rust considers mutable static variables to be
unsafe. Where possible, it’s preferable to use the concurrency techniques and
thread-safe smart pointers we discussed in Chapter 16 so the compiler checks
that data accessed from different threads is done safely.</p>
<h3 id="implementing-an-unsafe-trait"><a class="header" href="#implementing-an-unsafe-trait">Implementing an Unsafe Trait</a></h3>
<p>Another use case for <code>unsafe</code> is implementing an unsafe trait. A trait is
unsafe when at least one of its methods has some invariant that the compiler
can’t verify. We can declare that a trait is <code>unsafe</code> by adding the <code>unsafe</code>
keyword before <code>trait</code> and marking the implementation of the trait as <code>unsafe</code>
too, as shown in Listing 19-11.</p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe trait <span class="ra" data-hover="43">Foo</span> {
    // methods go here
}

unsafe impl <span class="ra" data-hover="43">Foo</span> for <span class="ra" data-hover="3">i32</span> {
    // method implementations go here
}

fn <span class="ra" data-hover="0">main</span>() {}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-11: Defining and implementing an unsafe
trait</span></p>
<p>By using <code>unsafe impl</code>, we’re promising that we’ll uphold the invariants that
the compiler can’t verify.</p>
<p>As an example, recall the <code>Sync</code> and <code>Send</code> marker traits we discussed in the
<a href="ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits">“Extensible Concurrency with the <code>Sync</code> and <code>Send</code>
Traits”</a><!-- ignore -->
section in Chapter 16: the compiler implements these traits automatically if
our types are composed entirely of <code>Send</code> and <code>Sync</code> types. If we implement a
type that contains a type that is not <code>Send</code> or <code>Sync</code>, such as raw pointers,
and we want to mark that type as <code>Send</code> or <code>Sync</code>, we must use <code>unsafe</code>. Rust
can’t verify that our type upholds the guarantees that it can be safely sent
across threads or accessed from multiple threads; therefore, we need to do
those checks manually and indicate as such with <code>unsafe</code>.</p>
<h3 id="accessing-fields-of-a-union"><a class="header" href="#accessing-fields-of-a-union">Accessing Fields of a Union</a></h3>
<p>The final action that works only with <code>unsafe</code> is accessing fields of a
<em>union</em>. A <code>union</code> is similar to a <code>struct</code>, but only one declared field is
used in a particular instance at one time. Unions are primarily used to
interface with unions in C code. Accessing union fields is unsafe because Rust
can’t guarantee the type of the data currently being stored in the union
instance. You can learn more about unions in <a href="../reference/items/unions.html">the reference</a>.</p>
<h3 id="when-to-use-unsafe-code"><a class="header" href="#when-to-use-unsafe-code">When to Use Unsafe Code</a></h3>
<p>Using <code>unsafe</code> to take one of the five actions (superpowers) just discussed
isn’t wrong or even frowned upon. But it is trickier to get <code>unsafe</code> code
correct because the compiler can’t help uphold memory safety. When you have a
reason to use <code>unsafe</code> code, you can do so, and having the explicit <code>unsafe</code>
annotation makes it easier to track down the source of problems when they occur.</p>
<script src="https://unpkg.com/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
<script src="https://unpkg.com/tippy.js@6.3.2/dist/tippy-bundle.umd.min.js" integrity="sha384-vApKv6LkBdPwmt/fNiQrBCVCZvuniXpG0b5UZhVrGAq1zXdZRSsPcWjGdVxkZJtX" crossorigin="anonymous"></script>
<script>
    const hoverData = ['<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn main()\n</code></pre>\n','<per><cide class="language-rust">let mut num: i32\n</code></pre>\n','<per><cide class="language-rust">let r1: *const i32\n</code></pre>\n','<per><cide class="language-rust">i32\n</code></pre>\n<hr />\n<p>The 32-bit signed integer type.</p>\n','<per><cide class="language-rust">let r2: *mut i32\n</code></pre>\n','<per><cide class="language-rust">let address: usize\n</code></pre>\n','<per><cide class="language-rust">let r: *const i32\n</code></pre>\n','<per><cide class="language-rust">std\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! println\n</code></pre>\n<hr />\n<p>Prints to the standard output, with a newline.</p>\n<p>On all platforms, the newline is the LINE FEED character (<cide>\n</code>/<cide>U+000A</code>) alone\n(no additional CARRIAGE RETURN (<cide>\r</code>/<cide>U+000D</code>)).</p>\n<p>Use the <a href="%60format!%60"><cide>format!</code></a> syntax to write data to the standard output.\nSee <a href="crate::fmt"><cide>std::fmt</code></a> for more information.</p>\n<p>Use <cide>println!</code> only for the primary output of your program. Use\n<a href="%60eprintln!%60"><cide>eprintln!</code></a> instead to print error and progress messages.</p>\n<h1 id="panics"><a class="header" href="#panics">Panics</a></h1>\n<p>Panics if writing to <a href="crate::io::stdout"><cide>io::stdout</code></a> fails.</p>\n<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>\n<per><cide>println!(); // prints just a newline\nprintln!(&quot;hello there!&quot;);\nprintln!(&quot;format {} arguments&quot;, &quot;some&quot;);\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">unsafe fn dangerous()\n</code></pre>\n','<per><cide class="language-rust">let mut v: Vec&lt;i32, Global&gt;\n</code></pre>\n','<per><cide class="language-rust">alloc\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! vec\n</code></pre>\n<hr />\n<p>Creates a <a href="crate::vec::Vec"><cide>Vec</code></a> containing the arguments.</p>\n<p><cide>vec!</code> allows <cide>Vec</code>s to be defined with the same syntax as array expressions.\nThere are two forms of this macro:</p>\n<ul>\n<li>Create a <a href="crate::vec::Vec"><cide>Vec</code></a> containing a given list of elements:</li>\n</ul>\n<per><cide>let v = vec![1, 2, 3];\nassert_eq!(v[0], 1);\nassert_eq!(v[1], 2);\nassert_eq!(v[2], 3);\n</code></pre>\n<ul>\n<li>Create a <a href="crate::vec::Vec"><cide>Vec</code></a> from a given element and size:</li>\n</ul>\n<per><cide>let v = vec![1; 3];\nassert_eq!(v, [1, 1, 1]);\n</code></pre>\n<p>Note that unlike array expressions this syntax supports all elements\nwhich implement <a href="%60Clone%60"><cide>Clone</code></a> and the number of elements doesn#$%t have to be\na constant.</p>\n<p>This will use <cide>clone</code> to duplicate an expression, so one should be careful\nusing this with types having a nonstandard <cide>Clone</code> implementation. For\nexample, <cide>vec![Rc::new(1); 5]</code> will create a vector of five references\nto the same boxed integer value, not five references pointing to independently\nboxed integers.</p>\n<p>Also, note that <cide>vec![expr; 0]</code> is allowed, and produces an empty vector.\nThis will still evaluate <cide>expr</code>, however, and immediately drop the resulting value, so\nbe mindful of side effects.</p>\n','<per><cide class="language-rust">let r: &amp;mut [i32]\n</code></pre>\n','<per><cide class="language-rust">a: &amp;mut [i32]\n</code></pre>\n','<per><cide class="language-rust">b: &amp;mut [i32]\n</code></pre>\n','<per><cide class="language-rust">core::slice\n</code></pre>\n<per><cide class="language-rust">pub fn split_at_mut(&amp;mut self, mid: usize) -&gt; (&amp;mut [T], &amp;mut [T])\n</code></pre>\n<hr />\n<p>Divides one mutable slice into two at an index.</p>\n<p>The first will contain all indices from <cide>[0, mid)</code> (excluding\nthe index <cide>mid</code> itself) and the second will contain all\nindices from <cide>[mid, len)</code> (excluding the index <cide>len</code> itself).</p>\n<h1 id="panics-1"><a class="header" href="#panics-1">Panics</a></h1>\n<p>Panics if <cide>mid &gt; len</code>.</p>\n<h1 id="examples-1"><a class="header" href="#examples-1">Examples</a></h1>\n<per><cide>let mut v = [1, 0, 3, 0, 5, 6];\nlet (left, right) = v.split_at_mut(2);\nassert_eq!(left, [1, 0]);\nassert_eq!(right, [3, 0, 5, 6]);\nleft[1] = 2;\nright[1] = 4;\nassert_eq!(v, [1, 2, 3, 4, 5, 6]);\n</code></pre>\n','<per><cide class="language-rust">core\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! assert_eq\n</code></pre>\n<hr />\n<p>Asserts that two expressions are equal to each other (using <a href="%60PartialEq%60"><cide>PartialEq</code></a>).</p>\n<p>On panic, this macro will print the values of the expressions with their\ndebug representations.</p>\n<p>Like <a href="%60assert!%60"><cide>assert!</code></a>, this macro has a second form, where a custom\npanic message can be provided.</p>\n<h1 id="examples-2"><a class="header" href="#examples-2">Examples</a></h1>\n<per><cide>let a = 3;\nlet b = 1 + 2;\nassert_eq!(a, b);\n\nassert_eq!(a, b, &quot;we are testing addition with {} and {}&quot;, a, b);\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32])\n</code></pre>\n','<per><cide class="language-rust">slice: &amp;mut [i32]\n</code></pre>\n','<per><cide class="language-rust">mid: usize\n</code></pre>\n','<per><cide class="language-rust">usize\n</code></pre>\n<hr />\n<p>The pointer-sized unsigned integer type.</p>\n<p>The size of this primitive is how many bytes it takes to reference any\nlocation in memory. For example, on a 32 bit target, this is 4 bytes\nand on a 64 bit target, this is 8 bytes.</p>\n','<per><cide class="language-rust">let len: usize\n</code></pre>\n','<per><cide class="language-rust">core::slice\n</code></pre>\n<per><cide class="language-rust">pub const fn len(&amp;self) -&gt; usize\n</code></pre>\n<hr />\n<p>Returns the number of elements in the slice.</p>\n<h1 id="examples-3"><a class="header" href="#examples-3">Examples</a></h1>\n<per><cide>let a = [1, 2, 3];\nassert_eq!(a.len(), 3);\n</code></pre>\n','<per><cide class="language-rust">core\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! assert\n</code></pre>\n<hr />\n<p>Asserts that a boolean expression is <cide>true</code> at runtime.</p>\n<p>This will invoke the <a href="%60panic!%60"><cide>panic!</code></a> macro if the provided expression cannot be\nevaluated to <cide>true</code> at runtime.</p>\n<h1 id="uses"><a class="header" href="#uses">Uses</a></h1>\n<p>Assertions are always checked in both debug and release builds, and cannot\nbe disabled. See <a href="%60debug_assert!%60"><cide>debug_assert!</code></a> for assertions that are not enabled in\nrelease builds by default.</p>\n<p>Unsafe code may rely on <cide>assert!</code> to enforce run-time invariants that, if\nviolated could lead to unsafety.</p>\n<p>Other use-cases of <cide>assert!</code> include testing and enforcing run-time\ninvariants in safe code (whose violation cannot result in unsafety).</p>\n<h1 id="custom-messages"><a class="header" href="#custom-messages">Custom Messages</a></h1>\n<p>This macro has a second form, where a custom panic message can\nbe provided with or without arguments for formatting. See <a href="../std/fmt/index.html"><cide>std::fmt</code></a>\nfor syntax for this form. Expressions used as format arguments will only\nbe evaluated if the assertion fails.</p>\n<h1 id="examples-4"><a class="header" href="#examples-4">Examples</a></h1>\n<per><cide>// the panic message for these assertions is the stringified value of the\n// expression given.\nassert!(true);\n\nfn some_computation() -&gt; bool { true } // a very simple function\n\nassert!(some_computation());\n\n// assert with a custom message\nlet x = true;\nassert!(x, &quot;x wasn#$%t true!&quot;);\n\nlet a = 3; let b = 27;\nassert!(a + b == 30, &quot;a = {}, b = {}&quot;, a, b);\n</code></pre>\n','<per><cide class="language-rust">let mut vector: Vec&lt;i32, Global&gt;\n</code></pre>\n','<per><cide class="language-rust">left: &amp;mut [i32]\n</code></pre>\n','<per><cide class="language-rust">right: &amp;mut [i32]\n</code></pre>\n','<per><cide class="language-rust">extern crate std\n</code></pre>\n<hr />\n<h1 id="the-rust-standard-library"><a class="header" href="#the-rust-standard-library">The Rust Standard Library</a></h1>\n<p>The Rust Standard Library is the foundation of portable Rust software, a\nset of minimal and battle-tested shared abstractions for the <a href="https://crates.io">broader Rust\necosystem</a>. It offers core types, like <a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a> and\n<a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>Option&lt;T&gt;</code></a>, library-defined <a href="https://docs.rs/std/*/std/index.html#primitives">operations on language\nprimitives</a>, <a href="https://docs.rs/std/*/std/index.html#macros">standard macros</a>, <a href="https://docs.rs/std/*/std/io/index.html">I/O</a> and\n<a href="https://docs.rs/std/*/std/thread/index.html">multithreading</a>, among <a href="https://docs.rs/std/*/std/index.html#what-is-in-the-standard-library-documentation">many other things</a>.</p>\n<p><cide>std</code> is available to all Rust crates by default. Therefore, the\nstandard library can be accessed in <a href="https://docs.rs/std/*/book/ch07-02-defining-modules-to-control-scope-and-privacy.html"><cide>use</code></a> statements through the path\n<cide>std</code>, as in <a href="https://docs.rs/std/*/std/env/index.html"><cide>use std::env</code></a>.</p>\n<h1 id="how-to-read-this-documentation"><a class="header" href="#how-to-read-this-documentation">How to read this documentation</a></h1>\n<p>If you already know the name of what you are looking for, the fastest way to\nfind it is to use the <!-- raw HTML omitted -->search\nbar<!-- raw HTML omitted --> at the top of the page.</p>\n<p>Otherwise, you may want to jump to one of these useful sections:</p>\n<ul>\n<li><a href="https://docs.rs/std/*/std/index.html#modules"><cide>std::*</code> modules</a></li>\n<li><a href="https://docs.rs/std/*/std/index.html#primitives">Primitive types</a></li>\n<li><a href="https://docs.rs/std/*/std/index.html#macros">Standard macros</a></li>\n<li><a href="https://docs.rs/std/*/std/prelude/index.html">The Rust Prelude</a></li>\n</ul>\n<p>If this is your first time, the documentation for the standard library is\nwritten to be casually perused. Clicking on interesting things should\ngenerally lead you to interesting places. Still, there are important bits\nyou don#$%t want to miss, so read on for a tour of the standard library and\nits documentation!</p>\n<p>Once you are familiar with the contents of the standard library you may\nbegin to find the verbosity of the prose distracting. At this stage in your\ndevelopment you may want to press the <cide>[-]</code> button near the top of the\npage to collapse it into a more skimmable view.</p>\n<p>While you are looking at that <cide>[-]</code> button also notice the <cide>[src]</code>\nbutton. Rust#$%s API documentation comes with the source code and you are\nencouraged to read it. The standard library source is generally high\nquality and a peek behind the curtains is often enlightening.</p>\n<h1 id="what-is-in-the-standard-library-documentation"><a class="header" href="#what-is-in-the-standard-library-documentation">What is in the standard library documentation?</a></h1>\n<p>First of all, The Rust Standard Library is divided into a number of focused\nmodules, <a href="https://docs.rs/std/*/std/index.html#modules">all listed further down this page</a>. These modules are\nthe bedrock upon which all of Rust is forged, and they have mighty names\nlike <a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>std::slice</code></a> and <a href="https://docs.rs/core/*/core/cmp/index.html"><cide>std::cmp</code></a>. Modules#$% documentation typically\nincludes an overview of the module along with examples, and are a smart\nplace to start familiarizing yourself with the library.</p>\n<p>Second, implicit methods on <a href="https://docs.rs/std/*/book/ch03-02-data-types.html">primitive types</a> are documented here. This can\nbe a source of confusion for two reasons:</p>\n<ol>\n<li>While primitives are implemented by the compiler, the standard library\nimplements methods directly on the primitive types (and it is the only\nlibrary that does so), which are <a href="https://docs.rs/std/*/std/index.html#primitives">documented in the section on\nprimitives</a>.</li>\n<li>The standard library exports many modules <em>with the same name as\nprimitive types</em>. These define additional items related to the primitive\ntype, but not the all-important methods.</li>\n</ol>\n<p>So for example there is a <a href="primitive::i32">page for the primitive type\n<cide>i32</code></a> that lists all the methods that can be called on\n32-bit integers (very useful), and there is a <a href="https://docs.rs/core/*/core/i32/index.html">page for the module\n<cide>std::i32</code></a> that documents the constant values <a href="https://docs.rs/core/*/core/i32/const.MIN.html"><cide>MIN</code></a> and <a href="https://docs.rs/core/*/core/i32/const.MAX.html"><cide>MAX</code></a> (rarely\nuseful).</p>\n<p>Note the documentation for the primitives <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a> and <a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>[T]</code></a> (also\ncalled #$%slice#$%). Many method calls on <a href="https://docs.rs/alloc/*/alloc/string/struct.String.html"><cide>String</code></a> and <a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a> are actually\ncalls to methods on <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a> and <a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>[T]</code></a> respectively, via <a href="https://docs.rs/std/*/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods">deref\ncoercions</a>.</p>\n<p>Third, the standard library defines <a href="https://docs.rs/std/*/std/prelude/index.html">The Rust Prelude</a>, a small collection\nof items - mostly traits - that are imported into every module of every\ncrate. The traits in the prelude are pervasive, making the prelude\ndocumentation a good entry point to learning about the library.</p>\n<p>And finally, the standard library exports a number of standard macros, and\n<a href="https://docs.rs/std/*/std/index.html#macros">lists them on this page</a> (technically, not all of the standard\nmacros are defined by the standard library - some are defined by the\ncompiler - but they are documented here the same). Like the prelude, the\nstandard macros are imported by default into all crates.</p>\n<h1 id="contributing-changes-to-the-documentation"><a class="header" href="#contributing-changes-to-the-documentation">Contributing changes to the documentation</a></h1>\n<p>Check out the rust contribution guidelines <a href="https://rustc-dev-guide.rust-lang.org/contributing.html#writing-documentation">here</a>.\nThe source for this documentation can be found on\n<a href="https://github.com/rust-lang/rust">GitHub</a>.\nTo contribute changes, make sure you read the guidelines first, then submit\npull-requests for your suggested changes.</p>\n<p>Contributions are appreciated! If you see a part of the docs that can be\nimproved, submit a PR, or chat with us first on <a href="https://discord.gg/rust-lang">Discord</a>\n#docs.</p>\n<h1 id="a-tour-of-the-rust-standard-library"><a class="header" href="#a-tour-of-the-rust-standard-library">A Tour of The Rust Standard Library</a></h1>\n<p>The rest of this crate documentation is dedicated to pointing out notable\nfeatures of The Rust Standard Library.</p>\n<h2 id="containers-and-collections"><a class="header" href="#containers-and-collections">Containers and collections</a></h2>\n<p>The <a href="https://docs.rs/core/*/core/option/index.html"><cide>option</code></a> and <a href="https://docs.rs/core/*/core/result/index.html"><cide>result</code></a> modules define optional and error-handling\ntypes, <a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>Option&lt;T&gt;</code></a> and <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Result&lt;T, E&gt;</code></a>. The <a href="https://docs.rs/core/*/core/iter/index.html"><cide>iter</code></a> module defines\nRust#$%s iterator trait, <a href="https://docs.rs/core/*/core/iter/traits/iterator/trait.Iterator.html"><cide>Iterator</code></a>, which works with the <a href="https://docs.rs/std/*/book/ch03-05-control-flow.html#looping-through-a-collection-with-for"><cide>for</code></a> loop to\naccess collections.</p>\n<p>The standard library exposes three common ways to deal with contiguous\nregions of memory:</p>\n<ul>\n<li><a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a> - A heap-allocated <em>vector</em> that is resizable at runtime.</li>\n<li><a href="https://docs.rs/core/*/core/array/index.html"><cide>[T; N]</code></a> - An inline <em>array</em> with a fixed size at compile time.</li>\n<li><a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>[T]</code></a> - A dynamically sized <em>slice</em> into any other kind of contiguous\nstorage, whether heap-allocated or not.</li>\n</ul>\n<p>Slices can only be handled through some kind of <em>pointer</em>, and as such come\nin many flavors such as:</p>\n<ul>\n<li><cide>&amp;[T]</code> - <em>shared slice</em></li>\n<li><cide>&amp;mut [T]</code> - <em>mutable slice</em></li>\n<li><a href="https://docs.rs/alloc/*/alloc/boxed/index.html"><cide>Box&lt;[T]&gt;</code></a> - <em>owned slice</em></li>\n</ul>\n<p><a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>, a UTF-8 string slice, is a primitive type, and the standard library\ndefines many methods for it. Rust <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>s are typically accessed as\nimmutable references: <cide>&amp;str</code>. Use the owned <a href="https://docs.rs/alloc/*/alloc/string/struct.String.html"><cide>String</code></a> for building and\nmutating strings.</p>\n<p>For converting to strings use the <a href="https://docs.rs/alloc/*/alloc/macro.format.html"><cide>format</code></a> macro, and for converting from\nstrings use the <a href="https://docs.rs/core/*/core/str/traits/trait.FromStr.html"><cide>FromStr</code></a> trait.</p>\n<p>Data may be shared by placing it in a reference-counted box or the <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a>\ntype, and if further contained in a <a href="https://docs.rs/core/*/core/cell/struct.Cell.html"><cide>Cell</code></a> or <a href="https://docs.rs/core/*/core/cell/struct.RefCell.html"><cide>RefCell</code></a>, may be mutated\nas well as shared. Likewise, in a concurrent setting it is common to pair an\natomically-reference-counted box, <a href="https://docs.rs/alloc/*/alloc/sync/struct.Arc.html"><cide>Arc</code></a>, with a <a href="https://docs.rs/std/*/std/sync/mutex/struct.Mutex.html"><cide>Mutex</code></a> to get the same\neffect.</p>\n<p>The <a href="https://docs.rs/std/*/std/collections/index.html"><cide>collections</code></a> module defines maps, sets, linked lists and other\ntypical collection types, including the common <a href="https://docs.rs/std/*/std/collections/hash/map/struct.HashMap.html"><cide>HashMap&lt;K, V&gt;</code></a>.</p>\n<h2 id="platform-abstractions-and-io"><a class="header" href="#platform-abstractions-and-io">Platform abstractions and I/O</a></h2>\n<p>Besides basic data types, the standard library is largely concerned with\nabstracting over differences in common platforms, most notably Windows and\nUnix derivatives.</p>\n<p>Common types of I/O, including <a href="https://docs.rs/std/*/std/fs/struct.File.html">files</a>, <a href="https://docs.rs/std/*/std/net/tcp/struct.TcpStream.html">TCP</a>, <a href="https://docs.rs/std/*/std/net/udp/struct.UdpSocket.html">UDP</a>, are defined in the\n<a href="https://docs.rs/std/*/std/io/index.html"><cide>io</code></a>, <a href="https://docs.rs/std/*/std/fs/index.html"><cide>fs</code></a>, and <a href="https://docs.rs/std/*/std/net/index.html"><cide>net</code></a> modules.</p>\n<p>The <a href="https://docs.rs/std/*/std/thread/index.html"><cide>thread</code></a> module contains Rust#$%s threading abstractions. <a href="https://docs.rs/std/*/std/sync/index.html"><cide>sync</code></a>\ncontains further primitive shared memory types, including <a href="https://docs.rs/core/*/core/sync/atomic/index.html"><cide>atomic</code></a> and\n<a href="https://docs.rs/std/*/std/sync/mpsc/index.html"><cide>mpsc</code></a>, which contains the channel types for message passing.</p>\n','<per><cide class="language-rust">alloc\n</code></pre>\n<per><cide class="language-rust">mod slice\n</code></pre>\n<hr />\n<p>A dynamically-sized view into a contiguous sequence, <cide>[T]</code>.</p>\n<p><em><a href="slice">See also the slice primitive type</a>.</em></p>\n<p>Slices are a view into a block of memory represented as a pointer and a\nlength.</p>\n<per><cide>// slicing a Vec\nlet vec = vec![1, 2, 3];\nlet int_slice = &amp;vec[..];\n// coercing an array to a slice\nlet str_slice: &amp;[&amp;str] = &amp;[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];\n</code></pre>\n<p>Slices are either mutable or shared. The shared slice type is <cide>&amp;[T]</code>,\nwhile the mutable slice type is <cide>&amp;mut [T]</code>, where <cide>T</code> represents the element\ntype. For example, you can mutate the block of memory that a mutable slice\npoints to:</p>\n<per><cide>let x = &amp;mut [1, 2, 3];\nx[1] = 7;\nassert_eq!(x, &amp;[1, 7, 3]);\n</code></pre>\n<p>Here are some of the things this module contains:</p>\n<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>\n<p>There are several structs that are useful for slices, such as <a href="https://docs.rs/core/*/core/slice/iter/struct.Iter.html"><cide>Iter</code></a>, which\nrepresents iteration over a slice.</p>\n<h2 id="trait-implementations"><a class="header" href="#trait-implementations">Trait Implementations</a></h2>\n<p>There are several implementations of common traits for slices. Some examples\ninclude:</p>\n<ul>\n<li><a href="https://docs.rs/core/*/core/clone/trait.Clone.html"><cide>Clone</code></a></li>\n<li><a href="https://docs.rs/core/*/core/cmp/trait.Eq.html"><cide>Eq</code></a>, <a href="https://docs.rs/core/*/core/cmp/trait.Ord.html"><cide>Ord</code></a> - for slices whose element type are <a href="https://docs.rs/core/*/core/cmp/trait.Eq.html"><cide>Eq</code></a> or <a href="https://docs.rs/core/*/core/cmp/trait.Ord.html"><cide>Ord</code></a>.</li>\n<li><a href="https://docs.rs/core/*/core/hash/trait.Hash.html"><cide>Hash</code></a> - for slices whose element type is <a href="https://docs.rs/core/*/core/hash/trait.Hash.html"><cide>Hash</code></a>.</li>\n</ul>\n<h2 id="iteration"><a class="header" href="#iteration">Iteration</a></h2>\n<p>The slices implement <cide>IntoIterator</code>. The iterator yields references to the\nslice elements.</p>\n<per><cide>let numbers = &amp;[0, 1, 2];\nfor n in numbers {\n    println!(&quot;{} is a number!&quot;, n);\n}\n</code></pre>\n<p>The mutable slice yields mutable references to the elements:</p>\n<per><cide>let mut scores = [7, 8, 9];\nfor score in &amp;mut scores[..] {\n    *score += 1;\n}\n</code></pre>\n<p>This iterator yields mutable references to the slice#$%s elements, so while\nthe element type of the slice is <cide>i32</code>, the element type of the iterator is\n<cide>&amp;mut i32</code>.</p>\n<ul>\n<li><a href="slice::iter"><cide>.iter</code></a> and <a href="slice::iter_mut"><cide>.iter_mut</code></a> are the explicit methods to return the default\niterators.</li>\n<li>Further methods that return iterators are <a href="slice::split"><cide>.split</code></a>, <a href="slice::splitn"><cide>.splitn</code></a>,\n<a href="slice::chunks"><cide>.chunks</code></a>, <a href="slice::windows"><cide>.windows</code></a> and more.</li>\n</ul>\n','<per><cide class="language-rust">let ptr: *mut i32\n</code></pre>\n','<per><cide class="language-rust">core::slice\n</code></pre>\n<per><cide class="language-rust">pub const fn as_mut_ptr(&amp;mut self) -&gt; *mut T\n</code></pre>\n<hr />\n<p>Returns an unsafe mutable pointer to the slice#$%s buffer.</p>\n<p>The caller must ensure that the slice outlives the pointer this\nfunction returns, or else it will end up pointing to garbage.</p>\n<p>Modifying the container referenced by this slice may cause its buffer\nto be reallocated, which would also make any pointers to it invalid.</p>\n<h1 id="examples-5"><a class="header" href="#examples-5">Examples</a></h1>\n<per><cide>let x = &amp;mut [1, 2, 4];\nlet x_ptr = x.as_mut_ptr();\n\nunsafe {\n    for i in 0..x.len() {\n        *x_ptr.add(i) += 2;\n    }\n}\nassert_eq!(x, &amp;[3, 4, 6]);\n</code></pre>\n','<per><cide class="language-rust">core::slice::raw\n</code></pre>\n<per><cide class="language-rust">pub unsafe fn from_raw_parts_mut&lt;#$%a, T&gt;(data: *mut T, len: usize) -&gt; &amp;#$%a mut [T]\n</code></pre>\n<hr />\n<p>Performs the same functionality as <a href="https://docs.rs/core/*/core/slice/raw/fn.from_raw_parts.html"><cide>from_raw_parts</code></a>, except that a\nmutable slice is returned.</p>\n<h1 id="safety"><a class="header" href="#safety">Safety</a></h1>\n<p>Behavior is undefined if any of the following conditions are violated:</p>\n<ul>\n<li>\n<p><cide>data</code> must be <a href="https://docs.rs/core/*/core/slice/raw/ptr#safety">valid</a> for both reads and writes for <cide>len * mem::size_of::&lt;T&gt;()</code> many bytes,\nand it must be properly aligned. This means in particular:</p>\n<ul>\n<li>The entire memory range of this slice must be contained within a single allocated object!\nSlices can never span across multiple allocated objects.</li>\n<li><cide>data</code> must be non-null and aligned even for zero-length slices. One\nreason for this is that enum layout optimizations may rely on references\n(including slices of any length) being aligned and non-null to distinguish\nthem from other data. You can obtain a pointer that is usable as <cide>data</code>\nfor zero-length slices using <a href="ptr::NonNull::dangling"><cide>NonNull::dangling()</code></a>.</li>\n</ul>\n</li>\n<li>\n<p><cide>data</code> must point to <cide>len</code> consecutive properly initialized values of type <cide>T</code>.</p>\n</li>\n<li>\n<p>The memory referenced by the returned slice must not be accessed through any other pointer\n(not derived from the return value) for the duration of lifetime <cide>#$%a</code>.\nBoth read and write accesses are forbidden.</p>\n</li>\n<li>\n<p>The total size <cide>len * mem::size_of::&lt;T&gt;()</code> of the slice must be no larger than <cide>isize::MAX</code>.\nSee the safety documentation of <a href="%60pointer::offset%60"><cide>pointer::offset</code></a>.</p>\n</li>\n</ul>\n','<per><cide class="language-rust">core::ptr::mut_ptr\n</code></pre>\n<per><cide class="language-rust">pub const unsafe fn add(self, count: usize) -&gt; Self\nwhere\n    T: Sized,\n</code></pre>\n<hr />\n<p>Calculates the offset from a pointer (convenience for <cide>.offset(count as isize)</code>).</p>\n<p><cide>count</code> is in units of T; e.g., a <cide>count</code> of 3 represents a pointer\noffset of <cide>3 * size_of::&lt;T&gt;()</code> bytes.</p>\n<h1 id="safety-1"><a class="header" href="#safety-1">Safety</a></h1>\n<p>If any of the following conditions are violated, the result is Undefined\nBehavior:</p>\n<ul>\n<li>\n<p>Both the starting and resulting pointer must be either in bounds or one\nbyte past the end of the same <a href="allocated%20object">allocated object</a>.</p>\n</li>\n<li>\n<p>The computed offset, <strong>in bytes</strong>, cannot overflow an <cide>isize</code>.</p>\n</li>\n<li>\n<p>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address\nspace. That is, the infinite-precision sum must fit in a <cide>usize</code>.</p>\n</li>\n</ul>\n<p>The compiler and standard library generally tries to ensure allocations\nnever reach a size where an offset is a concern. For instance, <cide>Vec</code>\nand <cide>Box</code> ensure they never allocate more than <cide>isize::MAX</code> bytes, so\n<cide>vec.as_ptr().add(vec.len())</code> is always safe.</p>\n<p>Most platforms fundamentally can#$%t even construct such an allocation.\nFor instance, no known 64-bit platform can ever serve a request\nfor 2<!-- raw HTML omitted -->63<!-- raw HTML omitted --> bytes due to page-table limitations or splitting the address space.\nHowever, some 32-bit and 16-bit platforms may successfully serve a request for\nmore than <cide>isize::MAX</code> bytes with things like Physical Address\nExtension. As such, memory acquired directly from allocators or memory\nmapped files <em>may</em> be too large to handle with this function.</p>\n<p>Consider using <a href="https://docs.rs/core/*/core/ptr/mut_ptr/fn.add.html#method.wrapping_add"><cide>wrapping_add</code></a> instead if these constraints are\ndifficult to satisfy. The only advantage of this method is that it\nenables more aggressive compiler optimizations.</p>\n<h1 id="examples-6"><a class="header" href="#examples-6">Examples</a></h1>\n<p>Basic usage:</p>\n<per><cide>let s: &amp;str = &quot;123&quot;;\nlet ptr: *const u8 = s.as_ptr();\n\nunsafe {\n    println!(&quot;{}&quot;, *ptr.add(1) as char);\n    println!(&quot;{}&quot;, *ptr.add(2) as char);\n}\n</code></pre>\n','<per><cide class="language-rust">let r: *mut i32\n</code></pre>\n','<per><cide class="language-rust">let slice: &amp;[i32]\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">unsafe fn abs(input: i32) -&gt; i32\n</code></pre>\n','<per><cide class="language-rust">input: i32\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">pub extern &quot;C&quot; fn call_from_c()\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">static HELLO_WORLD: &amp;str\n</code></pre>\n','<per><cide class="language-rust">str\n</code></pre>\n<hr />\n<p>String slices.</p>\n<p><em><a href="crate::str">See also the <cide>std::str</code> module</a>.</em></p>\n<p>The <cide>str</code> type, also called a #$%string slice#$%, is the most primitive string\ntype. It is usually seen in its borrowed form, <cide>&amp;str</code>. It is also the type\nof string literals, <cide>&amp;#$%static str</code>.</p>\n<p>String slices are always valid UTF-8.</p>\n<h1 id="examples-7"><a class="header" href="#examples-7">Examples</a></h1>\n<p>String literals are string slices:</p>\n<per><cide>let hello = &quot;Hello, world!&quot;;\n\n// with an explicit type annotation\nlet hello: &amp;#$%static str = &quot;Hello, world!&quot;;\n</code></pre>\n<p>They are <cide>#$%static</code> because they#$%re stored directly in the final binary, and\nso will be valid for the <cide>#$%static</code> duration.</p>\n<h1 id="representation"><a class="header" href="#representation">Representation</a></h1>\n<p>A <cide>&amp;str</code> is made up of two components: a pointer to some bytes, and a\nlength. You can look at these with the <a href="str::as_ptr"><cide>as_ptr</code></a> and <a href="str::len"><cide>len</code></a> methods:</p>\n<per><cide>use std::slice;\nuse std::str;\n\nlet story = &quot;Once upon a time...&quot;;\n\nlet ptr = story.as_ptr();\nlet len = story.len();\n\n// story has nineteen bytes\nassert_eq!(19, len);\n\n// We can re-build a str out of ptr and len. This is all unsafe because\n// we are responsible for making sure the two components are valid:\nlet s = unsafe {\n    // First, we build a &amp;[u8]...\n    let slice = slice::from_raw_parts(ptr, len);\n\n    // ... and then convert that slice into a string slice\n    str::from_utf8(slice)\n};\n\nassert_eq!(s, Ok(story));\n</code></pre>\n<p>Note: This example shows the internals of <cide>&amp;str</code>. <cide>unsafe</code> should not be\nused to get a string slice under normal circumstances. Use <cide>as_str</code>\ninstead.</p>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">static mut COUNTER: u32\n</code></pre>\n','<per><cide class="language-rust">u32\n</code></pre>\n<hr />\n<p>The 32-bit unsigned integer type.</p>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn add_to_count(inc: u32)\n</code></pre>\n','<per><cide class="language-rust">inc: u32\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">unsafe trait Foo\n</code></pre>\n',].map((x)=>x.replaceAll('#$%', "'").replaceAll('<per', '<pre').replaceAll('<cide', '<code'));
    window.onload = () => {
        console.log("hello");
        tippy('.ra', {
            content: (x) => {
                const div = document.createElement('div');
                div.innerHTML = hoverData[x.dataset.hover];
                div.className = 'hover-holder';
                div.querySelectorAll('code').forEach((y) => y.innerHTML = hljs.highlight('rust', y.innerText).value);
                return div;
            },
            allowHTML: true,
            delay: [200, 0],
            interactive: true,
            maxWidth: '80vw',
            appendTo: document.querySelector('.content'),
        });
    };
</script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="ch19-00-advanced-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="ch19-03-advanced-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="ch19-00-advanced-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="ch19-03-advanced-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="ferris.js"></script>
        
        
    </body>
</html>
