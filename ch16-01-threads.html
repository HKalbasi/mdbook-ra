<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Using Threads to Run Code Simultaneously - The Rust Programming Language</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="ferris.css">
                <link rel="stylesheet" href="theme/2018-edition.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References and Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> The Slice Type</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> How to Write Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlling How Tests Are Run</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html" class="active"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.inlay-hint, .inlay-hint * {
    border-radius: .4em;
}

.light .inlay-hint, .rust .inlay-hint {
    background-color: #dcc;
    color: #777;
}

.ayu .inlay-hint, .navy .inlay-hint, .coal .inlay-hint {
    background-color: #444;
    color: #999;
}

.inlay-hint {
    font-size: 0.8em;
    user-select: none;
}
.hover-holder {
    max-height: 40vh;
    overflow: auto;
}

.tippy-content {
    background-color: var(--bg);
    color: var(--fg);
}
</style>## Using Threads to Run Code Simultaneously
<p>In most current operating systems, an executed program’s code is run in a
<em>process</em>, and the operating system manages multiple processes at once. Within
your program, you can also have independent parts that run simultaneously. The
features that run these independent parts are called <em>threads</em>.</p>
<p>Splitting the computation in your program into multiple threads can improve
performance because the program does multiple tasks at the same time, but it
also adds complexity. Because threads can run simultaneously, there’s no
inherent guarantee about the order in which parts of your code on different
threads will run. This can lead to problems, such as:</p>
<ul>
<li>Race conditions, where threads are accessing data or resources in an
inconsistent order</li>
<li>Deadlocks, where two threads are waiting for each other to finish using a
resource the other thread has, preventing both threads from continuing</li>
<li>Bugs that happen only in certain situations and are hard to reproduce and fix
reliably</li>
</ul>
<p>Rust attempts to mitigate the negative effects of using threads, but
programming in a multithreaded context still takes careful thought and requires
a code structure that is different from that in programs running in a single
thread.</p>
<p>Programming languages implement threads in a few different ways. Many operating
systems provide an API for creating new threads. This model where a language
calls the operating system APIs to create threads is sometimes called <em>1:1</em>,
meaning one operating system thread per one language thread.</p>
<p>Many programming languages provide their own special implementation of threads.
Programming language-provided threads are known as <em>green</em> threads, and
languages that use these green threads will execute them in the context of a
different number of operating system threads. For this reason, the
green-threaded model is called the <em>M:N</em> model: there are <code>M</code> green threads per
<code>N</code> operating system threads, where <code>M</code> and <code>N</code> are not necessarily the same
number.</p>
<p>Each model has its own advantages and trade-offs, and the trade-off most
important to Rust is runtime support. <em>Runtime</em> is a confusing term and can
have different meanings in different contexts.</p>
<p>In this context, by <em>runtime</em> we mean code that is included by the language in
every binary. This code can be large or small depending on the language, but
every non-assembly language will have some amount of runtime code. For that
reason, colloquially when people say a language has “no runtime,” they often
mean “small runtime.” Smaller runtimes have fewer features but have the
advantage of resulting in smaller binaries, which make it easier to combine the
language with other languages in more contexts. Although many languages are
okay with increasing the runtime size in exchange for more features, Rust needs
to have nearly no runtime and cannot compromise on being able to call into C to
maintain performance.</p>
<p>The green-threading M:N model requires a larger language runtime to manage
threads. As such, the Rust standard library only provides an implementation of
1:1 threading. Because Rust is such a low-level language, there are crates that
implement M:N threading if you would rather trade overhead for aspects such as
more control over which threads run when and lower costs of context switching,
for example.</p>
<p>Now that we’ve defined threads in Rust, let’s explore how to use the
thread-related API provided by the standard library.</p>
<h3 id="creating-a-new-thread-with-spawn"><a class="header" href="#creating-a-new-thread-with-spawn">Creating a New Thread with <code>spawn</code></a></h3>
<p>To create a new thread, we call the <code>thread::spawn</code> function and pass it a
closure (we talked about closures in Chapter 13) containing the code we want to
run in the new thread. The example in Listing 16-1 prints some text from a main
thread and other text from a new thread:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use <span class="ra" data-hover="0">std</span>::<span class="ra" data-hover="1">thread</span>;
use <span class="ra" data-hover="0">std</span>::<span class="ra" data-hover="2">time</span>::<span class="ra" data-hover="3">Duration</span>;

fn <span class="ra" data-hover="4">main</span>() {
    <span class="ra" data-hover="1">thread</span>::<span class="ra" data-hover="5">spawn</span>(|| {
        for <span class="ra" data-hover="6">i</span><span class="inlay-hint">: i32</span> in 1..10 {
            <span class="ra" data-hover="7">println</span>!("hi number {} from the spawned thread!", <span class="ra" data-hover="6">i</span>);
            <span class="ra" data-hover="1">thread</span>::<span class="ra" data-hover="8">sleep</span>(<span class="ra" data-hover="3"><span class="inlay-hint">dur: </span>Duration</span>::<span class="ra" data-hover="9">from_millis</span>(1));
        }
    });

    for <span class="ra" data-hover="6">i</span><span class="inlay-hint">: i32</span> in 1..5 {
        <span class="ra" data-hover="7">println</span>!("hi number {} from the main thread!", <span class="ra" data-hover="6">i</span>);
        <span class="ra" data-hover="1">thread</span>::<span class="ra" data-hover="8">sleep</span>(<span class="ra" data-hover="3"><span class="inlay-hint">dur: </span>Duration</span>::<span class="ra" data-hover="9">from_millis</span>(1));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 16-1: Creating a new thread to print one thing
while the main thread prints something else</span></p>
<p>Note that with this function, the new thread will be stopped when the main
thread ends, whether or not it has finished running. The output from this
program might be a little different every time, but it will look similar to the
following:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>The calls to <code>thread::sleep</code> force a thread to stop its execution for a short
duration, allowing a different thread to run. The threads will probably take
turns, but that isn’t guaranteed: it depends on how your operating system
schedules the threads. In this run, the main thread printed first, even though
the print statement from the spawned thread appears first in the code. And even
though we told the spawned thread to print until <code>i</code> is 9, it only got to 5
before the main thread shut down.</p>
<p>If you run this code and only see output from the main thread, or don’t see any
overlap, try increasing the numbers in the ranges to create more opportunities
for the operating system to switch between the threads.</p>
<h3 id="waiting-for-all-threads-to-finish-using-join-handles"><a class="header" href="#waiting-for-all-threads-to-finish-using-join-handles">Waiting for All Threads to Finish Using <code>join</code> Handles</a></h3>
<p>The code in Listing 16-1 not only stops the spawned thread prematurely most of
the time due to the main thread ending, but also can’t guarantee that the
spawned thread will get to run at all. The reason is that there is no guarantee
on the order in which threads run!</p>
<p>We can fix the problem of the spawned thread not getting to run, or not getting
to run completely, by saving the return value of <code>thread::spawn</code> in a variable.
The return type of <code>thread::spawn</code> is <code>JoinHandle</code>. A <code>JoinHandle</code> is an owned
value that, when we call the <code>join</code> method on it, will wait for its thread to
finish. Listing 16-2 shows how to use the <code>JoinHandle</code> of the thread we created
in Listing 16-1 and call <code>join</code> to make sure the spawned thread finishes before
<code>main</code> exits:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use <span class="ra" data-hover="0">std</span>::<span class="ra" data-hover="1">thread</span>;
use <span class="ra" data-hover="0">std</span>::<span class="ra" data-hover="2">time</span>::<span class="ra" data-hover="3">Duration</span>;

fn <span class="ra" data-hover="4">main</span>() {
    let <span class="ra" data-hover="10">handle</span><span class="inlay-hint">: JoinHandle&lt;()&gt;</span> = <span class="ra" data-hover="1">thread</span>::<span class="ra" data-hover="5">spawn</span>(|| {
        for <span class="ra" data-hover="6">i</span><span class="inlay-hint">: i32</span> in 1..10 {
            <span class="ra" data-hover="7">println</span>!("hi number {} from the spawned thread!", <span class="ra" data-hover="6">i</span>);
            <span class="ra" data-hover="1">thread</span>::<span class="ra" data-hover="8">sleep</span>(<span class="ra" data-hover="3"><span class="inlay-hint">dur: </span>Duration</span>::<span class="ra" data-hover="9">from_millis</span>(1));
        }
    });

    for <span class="ra" data-hover="6">i</span><span class="inlay-hint">: i32</span> in 1..5 {
        <span class="ra" data-hover="7">println</span>!("hi number {} from the main thread!", <span class="ra" data-hover="6">i</span>);
        <span class="ra" data-hover="1">thread</span>::<span class="ra" data-hover="8">sleep</span>(<span class="ra" data-hover="3"><span class="inlay-hint">dur: </span>Duration</span>::<span class="ra" data-hover="9">from_millis</span>(1));
    }

    <span class="ra" data-hover="10">handle</span>.<span class="ra" data-hover="11">join</span>().<span class="ra" data-hover="12">unwrap</span>();
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 16-2: Saving a <code>JoinHandle</code> from <code>thread::spawn</code>
to guarantee the thread is run to completion</span></p>
<p>Calling <code>join</code> on the handle blocks the thread currently running until the
thread represented by the handle terminates. <em>Blocking</em> a thread means that
thread is prevented from performing work or exiting. Because we’ve put the call
to <code>join</code> after the main thread’s <code>for</code> loop, running Listing 16-2 should
produce output similar to this:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>The two threads continue alternating, but the main thread waits because of the
call to <code>handle.join()</code> and does not end until the spawned thread is finished.</p>
<p>But let’s see what happens when we instead move <code>handle.join()</code> before the
<code>for</code> loop in <code>main</code>, like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use <span class="ra" data-hover="0">std</span>::<span class="ra" data-hover="1">thread</span>;
use <span class="ra" data-hover="0">std</span>::<span class="ra" data-hover="2">time</span>::<span class="ra" data-hover="3">Duration</span>;

fn <span class="ra" data-hover="4">main</span>() {
    let <span class="ra" data-hover="10">handle</span><span class="inlay-hint">: JoinHandle&lt;()&gt;</span> = <span class="ra" data-hover="1">thread</span>::<span class="ra" data-hover="5">spawn</span>(|| {
        for <span class="ra" data-hover="6">i</span><span class="inlay-hint">: i32</span> in 1..10 {
            <span class="ra" data-hover="7">println</span>!("hi number {} from the spawned thread!", <span class="ra" data-hover="6">i</span>);
            <span class="ra" data-hover="1">thread</span>::<span class="ra" data-hover="8">sleep</span>(<span class="ra" data-hover="3"><span class="inlay-hint">dur: </span>Duration</span>::<span class="ra" data-hover="9">from_millis</span>(1));
        }
    });

    <span class="ra" data-hover="10">handle</span>.<span class="ra" data-hover="11">join</span>().<span class="ra" data-hover="12">unwrap</span>();

    for <span class="ra" data-hover="6">i</span><span class="inlay-hint">: i32</span> in 1..5 {
        <span class="ra" data-hover="7">println</span>!("hi number {} from the main thread!", <span class="ra" data-hover="6">i</span>);
        <span class="ra" data-hover="1">thread</span>::<span class="ra" data-hover="8">sleep</span>(<span class="ra" data-hover="3"><span class="inlay-hint">dur: </span>Duration</span>::<span class="ra" data-hover="9">from_millis</span>(1));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The main thread will wait for the spawned thread to finish and then run its
<code>for</code> loop, so the output won’t be interleaved anymore, as shown here:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>Small details, such as where <code>join</code> is called, can affect whether or not your
threads run at the same time.</p>
<h3 id="using-move-closures-with-threads"><a class="header" href="#using-move-closures-with-threads">Using <code>move</code> Closures with Threads</a></h3>
<p>The <code>move</code> closure is often used alongside <code>thread::spawn</code> because it allows
you to use data from one thread in another thread.</p>
<p>In Chapter 13, we mentioned we can use the <code>move</code> keyword before the parameter
list of a closure to force the closure to take ownership of the values it uses
in the environment. This technique is especially useful when creating new
threads in order to transfer ownership of values from one thread to another.</p>
<p>Notice in Listing 16-1 that the closure we pass to <code>thread::spawn</code> takes no
arguments: we’re not using any data from the main thread in the spawned
thread’s code. To use data from the main thread in the spawned thread, the
spawned thread’s closure must capture the values it needs. Listing 16-3 shows
an attempt to create a vector in the main thread and use it in the spawned
thread. However, this won’t yet work, as you’ll see in a moment.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use <span class="ra" data-hover="0">std</span>::<span class="ra" data-hover="1">thread</span>;

fn <span class="ra" data-hover="4">main</span>() {
    let <span class="ra" data-hover="13">v</span><span class="inlay-hint">: Vec&lt;i32&gt;</span> = <span class="ra" data-hover="14">vec</span>![1, 2, 3];

    let <span class="ra" data-hover="10">handle</span><span class="inlay-hint">: JoinHandle&lt;()&gt;</span> = <span class="ra" data-hover="1">thread</span>::<span class="ra" data-hover="5">spawn</span>(|| {
        <span class="ra" data-hover="7">println</span>!("Here's a vector: {:?}", <span class="ra" data-hover="13">v</span>);
    });

    <span class="ra" data-hover="10">handle</span>.<span class="ra" data-hover="11">join</span>().<span class="ra" data-hover="12">unwrap</span>();
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 16-3: Attempting to use a vector created by the
main thread in another thread</span></p>
<p>The closure uses <code>v</code>, so it will capture <code>v</code> and make it part of the closure’s
environment. Because <code>thread::spawn</code> runs this closure in a new thread, we
should be able to access <code>v</code> inside that new thread. But when we compile this
example, we get the following error:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {:?}&quot;, v);
  |                                           - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!(&quot;Here's a vector: {:?}&quot;, v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` due to previous error
</code></pre>
<p>Rust <em>infers</em> how to capture <code>v</code>, and because <code>println!</code> only needs a reference
to <code>v</code>, the closure tries to borrow <code>v</code>. However, there’s a problem: Rust can’t
tell how long the spawned thread will run, so it doesn’t know if the reference
to <code>v</code> will always be valid.</p>
<p>Listing 16-4 provides a scenario that’s more likely to have a reference to <code>v</code>
that won’t be valid:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use <span class="ra" data-hover="0">std</span>::<span class="ra" data-hover="1">thread</span>;

fn <span class="ra" data-hover="4">main</span>() {
    let <span class="ra" data-hover="13">v</span><span class="inlay-hint">: Vec&lt;i32&gt;</span> = <span class="ra" data-hover="14">vec</span>![1, 2, 3];

    let <span class="ra" data-hover="10">handle</span><span class="inlay-hint">: JoinHandle&lt;()&gt;</span> = <span class="ra" data-hover="1">thread</span>::<span class="ra" data-hover="5">spawn</span>(|| {
        <span class="ra" data-hover="7">println</span>!("Here's a vector: {:?}", <span class="ra" data-hover="13">v</span>);
    });

    <span class="ra" data-hover="15">drop</span>(<span class="ra" data-hover="13">v</span>); // oh no!

    <span class="ra" data-hover="10">handle</span>.<span class="ra" data-hover="11">join</span>().<span class="ra" data-hover="12">unwrap</span>();
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 16-4: A thread with a closure that attempts to
capture a reference to <code>v</code> from a main thread that drops <code>v</code></span></p>
<p>If we were allowed to run this code, there’s a possibility the spawned thread
would be immediately put in the background without running at all. The spawned
thread has a reference to <code>v</code> inside, but the main thread immediately drops
<code>v</code>, using the <code>drop</code> function we discussed in Chapter 15. Then, when the
spawned thread starts to execute, <code>v</code> is no longer valid, so a reference to it
is also invalid. Oh no!</p>
<p>To fix the compiler error in Listing 16-3, we can use the error message’s
advice:</p>
<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-->
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
</code></pre>
<p>By adding the <code>move</code> keyword before the closure, we force the closure to take
ownership of the values it’s using rather than allowing Rust to infer that it
should borrow the values. The modification to Listing 16-3 shown in Listing
16-5 will compile and run as we intend:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use <span class="ra" data-hover="0">std</span>::<span class="ra" data-hover="1">thread</span>;

fn <span class="ra" data-hover="4">main</span>() {
    let <span class="ra" data-hover="13">v</span><span class="inlay-hint">: Vec&lt;i32&gt;</span> = <span class="ra" data-hover="14">vec</span>![1, 2, 3];

    let <span class="ra" data-hover="10">handle</span><span class="inlay-hint">: JoinHandle&lt;()&gt;</span> = <span class="ra" data-hover="1">thread</span>::<span class="ra" data-hover="5">spawn</span>(move || {
        <span class="ra" data-hover="7">println</span>!("Here's a vector: {:?}", <span class="ra" data-hover="13">v</span>);
    });

    <span class="ra" data-hover="10">handle</span>.<span class="ra" data-hover="11">join</span>().<span class="ra" data-hover="12">unwrap</span>();
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 16-5: Using the <code>move</code> keyword to force a closure
to take ownership of the values it uses</span></p>
<p>What would happen to the code in Listing 16-4 where the main thread called
<code>drop</code> if we use a <code>move</code> closure? Would <code>move</code> fix that case? Unfortunately,
no; we would get a different error because what Listing 16-4 is trying to do
isn’t allowed for a different reason. If we added <code>move</code> to the closure, we
would move <code>v</code> into the closure’s environment, and we could no longer call
<code>drop</code> on it in the main thread. We would get this compiler error instead:</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  | 
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!(&quot;Here's a vector: {:?}&quot;, v);
   |                                           - variable moved due to use in closure
...
10 |     drop(v); // oh no!
   |          ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` due to previous error
</code></pre>
<p>Rust’s ownership rules have saved us again! We got an error from the code in
Listing 16-3 because Rust was being conservative and only borrowing <code>v</code> for the
thread, which meant the main thread could theoretically invalidate the spawned
thread’s reference. By telling Rust to move ownership of <code>v</code> to the spawned
thread, we’re guaranteeing Rust that the main thread won’t use <code>v</code> anymore. If
we change Listing 16-4 in the same way, we’re then violating the ownership
rules when we try to use <code>v</code> in the main thread. The <code>move</code> keyword overrides
Rust’s conservative default of borrowing; it doesn’t let us violate the
ownership rules.</p>
<p>With a basic understanding of threads and the thread API, let’s look at what we
can <em>do</em> with threads.</p>
<script src="https://unpkg.com/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
<script src="https://unpkg.com/tippy.js@6.3.2/dist/tippy-bundle.umd.min.js" integrity="sha384-vApKv6LkBdPwmt/fNiQrBCVCZvuniXpG0b5UZhVrGAq1zXdZRSsPcWjGdVxkZJtX" crossorigin="anonymous"></script>
<script>
    const hoverData = ['<per><cide class="language-rust">extern crate std\n</code></pre>\n<hr />\n<h1 id="the-rust-standard-library"><a class="header" href="#the-rust-standard-library">The Rust Standard Library</a></h1>\n<p>The Rust Standard Library is the foundation of portable Rust software, a\nset of minimal and battle-tested shared abstractions for the <a href="https://crates.io">broader Rust\necosystem</a>. It offers core types, like <a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a> and\n<a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>Option&lt;T&gt;</code></a>, library-defined <a href="https://docs.rs/std/*/std/index.html#primitives">operations on language\nprimitives</a>, <a href="https://docs.rs/std/*/std/index.html#macros">standard macros</a>, <a href="https://docs.rs/std/*/std/io/index.html">I/O</a> and\n<a href="https://docs.rs/std/*/std/thread/index.html">multithreading</a>, among <a href="https://docs.rs/std/*/std/index.html#what-is-in-the-standard-library-documentation">many other things</a>.</p>\n<p><cide>std</code> is available to all Rust crates by default. Therefore, the\nstandard library can be accessed in <a href="https://docs.rs/std/*/book/ch07-02-defining-modules-to-control-scope-and-privacy.html"><cide>use</code></a> statements through the path\n<cide>std</code>, as in <a href="https://docs.rs/std/*/std/env/index.html"><cide>use std::env</code></a>.</p>\n<h1 id="how-to-read-this-documentation"><a class="header" href="#how-to-read-this-documentation">How to read this documentation</a></h1>\n<p>If you already know the name of what you are looking for, the fastest way to\nfind it is to use the <!-- raw HTML omitted -->search\nbar<!-- raw HTML omitted --> at the top of the page.</p>\n<p>Otherwise, you may want to jump to one of these useful sections:</p>\n<ul>\n<li><a href="https://docs.rs/std/*/std/index.html#modules"><cide>std::*</code> modules</a></li>\n<li><a href="https://docs.rs/std/*/std/index.html#primitives">Primitive types</a></li>\n<li><a href="https://docs.rs/std/*/std/index.html#macros">Standard macros</a></li>\n<li><a href="https://docs.rs/std/*/std/prelude/index.html">The Rust Prelude</a></li>\n</ul>\n<p>If this is your first time, the documentation for the standard library is\nwritten to be casually perused. Clicking on interesting things should\ngenerally lead you to interesting places. Still, there are important bits\nyou don#$%t want to miss, so read on for a tour of the standard library and\nits documentation!</p>\n<p>Once you are familiar with the contents of the standard library you may\nbegin to find the verbosity of the prose distracting. At this stage in your\ndevelopment you may want to press the <cide>[-]</code> button near the top of the\npage to collapse it into a more skimmable view.</p>\n<p>While you are looking at that <cide>[-]</code> button also notice the <cide>[src]</code>\nbutton. Rust#$%s API documentation comes with the source code and you are\nencouraged to read it. The standard library source is generally high\nquality and a peek behind the curtains is often enlightening.</p>\n<h1 id="what-is-in-the-standard-library-documentation"><a class="header" href="#what-is-in-the-standard-library-documentation">What is in the standard library documentation?</a></h1>\n<p>First of all, The Rust Standard Library is divided into a number of focused\nmodules, <a href="https://docs.rs/std/*/std/index.html#modules">all listed further down this page</a>. These modules are\nthe bedrock upon which all of Rust is forged, and they have mighty names\nlike <a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>std::slice</code></a> and <a href="https://docs.rs/core/*/core/cmp/index.html"><cide>std::cmp</code></a>. Modules#$% documentation typically\nincludes an overview of the module along with examples, and are a smart\nplace to start familiarizing yourself with the library.</p>\n<p>Second, implicit methods on <a href="https://docs.rs/std/*/book/ch03-02-data-types.html">primitive types</a> are documented here. This can\nbe a source of confusion for two reasons:</p>\n<ol>\n<li>While primitives are implemented by the compiler, the standard library\nimplements methods directly on the primitive types (and it is the only\nlibrary that does so), which are <a href="https://docs.rs/std/*/std/index.html#primitives">documented in the section on\nprimitives</a>.</li>\n<li>The standard library exports many modules <em>with the same name as\nprimitive types</em>. These define additional items related to the primitive\ntype, but not the all-important methods.</li>\n</ol>\n<p>So for example there is a <a href="primitive::i32">page for the primitive type\n<cide>i32</code></a> that lists all the methods that can be called on\n32-bit integers (very useful), and there is a <a href="https://docs.rs/core/*/core/i32/index.html">page for the module\n<cide>std::i32</code></a> that documents the constant values <a href="https://docs.rs/core/*/core/i32/const.MIN.html"><cide>MIN</code></a> and <a href="https://docs.rs/core/*/core/i32/const.MAX.html"><cide>MAX</code></a> (rarely\nuseful).</p>\n<p>Note the documentation for the primitives <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a> and <a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>[T]</code></a> (also\ncalled #$%slice#$%). Many method calls on <a href="https://docs.rs/alloc/*/alloc/string/struct.String.html"><cide>String</code></a> and <a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a> are actually\ncalls to methods on <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a> and <a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>[T]</code></a> respectively, via <a href="https://docs.rs/std/*/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods">deref\ncoercions</a>.</p>\n<p>Third, the standard library defines <a href="https://docs.rs/std/*/std/prelude/index.html">The Rust Prelude</a>, a small collection\nof items - mostly traits - that are imported into every module of every\ncrate. The traits in the prelude are pervasive, making the prelude\ndocumentation a good entry point to learning about the library.</p>\n<p>And finally, the standard library exports a number of standard macros, and\n<a href="https://docs.rs/std/*/std/index.html#macros">lists them on this page</a> (technically, not all of the standard\nmacros are defined by the standard library - some are defined by the\ncompiler - but they are documented here the same). Like the prelude, the\nstandard macros are imported by default into all crates.</p>\n<h1 id="contributing-changes-to-the-documentation"><a class="header" href="#contributing-changes-to-the-documentation">Contributing changes to the documentation</a></h1>\n<p>Check out the rust contribution guidelines <a href="https://rustc-dev-guide.rust-lang.org/contributing.html#writing-documentation">here</a>.\nThe source for this documentation can be found on\n<a href="https://github.com/rust-lang/rust">GitHub</a>.\nTo contribute changes, make sure you read the guidelines first, then submit\npull-requests for your suggested changes.</p>\n<p>Contributions are appreciated! If you see a part of the docs that can be\nimproved, submit a PR, or chat with us first on <a href="https://discord.gg/rust-lang">Discord</a>\n#docs.</p>\n<h1 id="a-tour-of-the-rust-standard-library"><a class="header" href="#a-tour-of-the-rust-standard-library">A Tour of The Rust Standard Library</a></h1>\n<p>The rest of this crate documentation is dedicated to pointing out notable\nfeatures of The Rust Standard Library.</p>\n<h2 id="containers-and-collections"><a class="header" href="#containers-and-collections">Containers and collections</a></h2>\n<p>The <a href="https://docs.rs/core/*/core/option/index.html"><cide>option</code></a> and <a href="https://docs.rs/core/*/core/result/index.html"><cide>result</code></a> modules define optional and error-handling\ntypes, <a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>Option&lt;T&gt;</code></a> and <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Result&lt;T, E&gt;</code></a>. The <a href="https://docs.rs/core/*/core/iter/index.html"><cide>iter</code></a> module defines\nRust#$%s iterator trait, <a href="https://docs.rs/core/*/core/iter/traits/iterator/trait.Iterator.html"><cide>Iterator</code></a>, which works with the <a href="https://docs.rs/std/*/book/ch03-05-control-flow.html#looping-through-a-collection-with-for"><cide>for</code></a> loop to\naccess collections.</p>\n<p>The standard library exposes three common ways to deal with contiguous\nregions of memory:</p>\n<ul>\n<li><a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a> - A heap-allocated <em>vector</em> that is resizable at runtime.</li>\n<li><a href="https://docs.rs/core/*/core/array/index.html"><cide>[T; N]</code></a> - An inline <em>array</em> with a fixed size at compile time.</li>\n<li><a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>[T]</code></a> - A dynamically sized <em>slice</em> into any other kind of contiguous\nstorage, whether heap-allocated or not.</li>\n</ul>\n<p>Slices can only be handled through some kind of <em>pointer</em>, and as such come\nin many flavors such as:</p>\n<ul>\n<li><cide>&amp;[T]</code> - <em>shared slice</em></li>\n<li><cide>&amp;mut [T]</code> - <em>mutable slice</em></li>\n<li><a href="https://docs.rs/alloc/*/alloc/boxed/index.html"><cide>Box&lt;[T]&gt;</code></a> - <em>owned slice</em></li>\n</ul>\n<p><a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>, a UTF-8 string slice, is a primitive type, and the standard library\ndefines many methods for it. Rust <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>s are typically accessed as\nimmutable references: <cide>&amp;str</code>. Use the owned <a href="https://docs.rs/alloc/*/alloc/string/struct.String.html"><cide>String</code></a> for building and\nmutating strings.</p>\n<p>For converting to strings use the <a href="https://docs.rs/alloc/*/alloc/macro.format.html"><cide>format</code></a> macro, and for converting from\nstrings use the <a href="https://docs.rs/core/*/core/str/traits/trait.FromStr.html"><cide>FromStr</code></a> trait.</p>\n<p>Data may be shared by placing it in a reference-counted box or the <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a>\ntype, and if further contained in a <a href="https://docs.rs/core/*/core/cell/struct.Cell.html"><cide>Cell</code></a> or <a href="https://docs.rs/core/*/core/cell/struct.RefCell.html"><cide>RefCell</code></a>, may be mutated\nas well as shared. Likewise, in a concurrent setting it is common to pair an\natomically-reference-counted box, <a href="https://docs.rs/alloc/*/alloc/sync/struct.Arc.html"><cide>Arc</code></a>, with a <a href="https://docs.rs/std/*/std/sync/mutex/struct.Mutex.html"><cide>Mutex</code></a> to get the same\neffect.</p>\n<p>The <a href="https://docs.rs/std/*/std/collections/index.html"><cide>collections</code></a> module defines maps, sets, linked lists and other\ntypical collection types, including the common <a href="https://docs.rs/std/*/std/collections/hash/map/struct.HashMap.html"><cide>HashMap&lt;K, V&gt;</code></a>.</p>\n<h2 id="platform-abstractions-and-io"><a class="header" href="#platform-abstractions-and-io">Platform abstractions and I/O</a></h2>\n<p>Besides basic data types, the standard library is largely concerned with\nabstracting over differences in common platforms, most notably Windows and\nUnix derivatives.</p>\n<p>Common types of I/O, including <a href="https://docs.rs/std/*/std/fs/struct.File.html">files</a>, <a href="https://docs.rs/std/*/std/net/tcp/struct.TcpStream.html">TCP</a>, <a href="https://docs.rs/std/*/std/net/udp/struct.UdpSocket.html">UDP</a>, are defined in the\n<a href="https://docs.rs/std/*/std/io/index.html"><cide>io</code></a>, <a href="https://docs.rs/std/*/std/fs/index.html"><cide>fs</code></a>, and <a href="https://docs.rs/std/*/std/net/index.html"><cide>net</code></a> modules.</p>\n<p>The <a href="https://docs.rs/std/*/std/thread/index.html"><cide>thread</code></a> module contains Rust#$%s threading abstractions. <a href="https://docs.rs/std/*/std/sync/index.html"><cide>sync</code></a>\ncontains further primitive shared memory types, including <a href="https://docs.rs/core/*/core/sync/atomic/index.html"><cide>atomic</code></a> and\n<a href="https://docs.rs/std/*/std/sync/mpsc/index.html"><cide>mpsc</code></a>, which contains the channel types for message passing.</p>\n','<per><cide class="language-rust">std\n</code></pre>\n<per><cide class="language-rust">mod thread\n</code></pre>\n<hr />\n<p>Native threads.</p>\n<h2 id="the-threading-model"><a class="header" href="#the-threading-model">The threading model</a></h2>\n<p>An executing Rust program consists of a collection of native OS threads,\neach with their own stack and local state. Threads can be named, and\nprovide some built-in support for low-level synchronization.</p>\n<p>Communication between threads can be done through\n<a href="https://docs.rs/std/*/std/sync/mpsc/index.html">channels</a>, Rust#$%s message-passing types, along with <a href="https://docs.rs/std/*/std/sync/index.html">other forms of thread\nsynchronization</a> and shared-memory data\nstructures. In particular, types that are guaranteed to be\nthreadsafe are easily shared between threads using the\natomically-reference-counted container, <a href="https://docs.rs/alloc/*/alloc/sync/struct.Arc.html"><cide>Arc</code></a>.</p>\n<p>Fatal logic errors in Rust cause <em>thread panic</em>, during which\na thread will unwind the stack, running destructors and freeing\nowned resources. While not meant as a #$%try/catch#$% mechanism, panics\nin Rust can nonetheless be caught (unless compiling with <cide>panic=abort</code>) with\n<a href="https://docs.rs/std/*/std/panic/fn.catch_unwind.html"><cide>catch_unwind</code></a> and recovered\nfrom, or alternatively be resumed with\n<a href="https://docs.rs/std/*/std/panic/fn.resume_unwind.html"><cide>resume_unwind</code></a>. If the panic\nis not caught the thread will exit, but the panic may optionally be\ndetected from a different thread with <a href="JoinHandle::join"><cide>join</code></a>. If the main thread panics\nwithout the panic being caught, the application will exit with a\nnon-zero exit code.</p>\n<p>When the main thread of a Rust program terminates, the entire program shuts\ndown, even if other threads are still running. However, this module provides\nconvenient facilities for automatically waiting for the termination of a\nchild thread (i.e., join).</p>\n<h2 id="spawning-a-thread"><a class="header" href="#spawning-a-thread">Spawning a thread</a></h2>\n<p>A new thread can be spawned using the <a href="https://docs.rs/std/*/std/thread/fn.spawn.html"><cide>thread::spawn</code></a> function:</p>\n<per><cide class="language-rust">use std::thread;\n\nthread::spawn(move || {\n    // some work here\n});\n</code></pre>\n<p>In this example, the spawned thread is &quot;detached&quot; from the current\nthread. This means that it can outlive its parent (the thread that spawned\nit), unless this parent is the main thread.</p>\n<p>The parent thread can also wait on the completion of the child\nthread; a call to <a href="https://docs.rs/std/*/std/thread/fn.spawn.html"><cide>spawn</code></a> produces a <a href="https://docs.rs/std/*/std/thread/struct.JoinHandle.html"><cide>JoinHandle</code></a>, which provides\na <cide>join</code> method for waiting:</p>\n<per><cide class="language-rust">use std::thread;\n\nlet child = thread::spawn(move || {\n    // some work here\n});\n// some work here\nlet res = child.join();\n</code></pre>\n<p>The <a href="JoinHandle::join"><cide>join</code></a> method returns a <a href="https://docs.rs/std/*/std/thread/type.Result.html"><cide>thread::Result</code></a> containing <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Ok</code></a> of the final\nvalue produced by the child thread, or <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Err</code></a> of the value given to\na call to <a href="https://docs.rs/core/*/core/macro.panic.html"><cide>panic</code></a> if the child panicked.</p>\n<h2 id="configuring-threads"><a class="header" href="#configuring-threads">Configuring threads</a></h2>\n<p>A new thread can be configured before it is spawned via the <a href="https://docs.rs/std/*/std/thread/struct.Builder.html"><cide>Builder</code></a> type,\nwhich currently allows you to set the name and stack size for the child thread:</p>\n<per><cide class="language-rust"># #![allow(unused_must_use)]\nuse std::thread;\n\nthread::Builder::new().name(&quot;child1&quot;.to_string()).spawn(move || {\n    println!(&quot;Hello, world!&quot;);\n});\n</code></pre>\n<h2 id="the-cidethread-type"><a class="header" href="#the-cidethread-type">The <cide>Thread</code> type</a></h2>\n<p>Threads are represented via the <a href="https://docs.rs/std/*/std/thread/struct.Thread.html"><cide>Thread</code></a> type, which you can get in one of\ntwo ways:</p>\n<ul>\n<li>By spawning a new thread, e.g., using the <a href="https://docs.rs/std/*/std/thread/fn.spawn.html"><cide>thread::spawn</code></a>\nfunction, and calling <a href="%60JoinHandle::thread%60"><cide>thread</code></a> on the <a href="https://docs.rs/std/*/std/thread/struct.JoinHandle.html"><cide>JoinHandle</code></a>.</li>\n<li>By requesting the current thread, using the <a href="https://docs.rs/std/*/std/thread/fn.current.html"><cide>thread::current</code></a> function.</li>\n</ul>\n<p>The <a href="https://docs.rs/std/*/std/thread/fn.current.html"><cide>thread::current</code></a> function is available even for threads not spawned\nby the APIs of this module.</p>\n<h2 id="thread-local-storage"><a class="header" href="#thread-local-storage">Thread-local storage</a></h2>\n<p>This module also provides an implementation of thread-local storage for Rust\nprograms. Thread-local storage is a method of storing data into a global\nvariable that each thread in the program will have its own copy of.\nThreads do not share this data, so accesses do not need to be synchronized.</p>\n<p>A thread-local key owns the value it contains and will destroy the value when the\nthread exits. It is created with the <a href="https://docs.rs/std/*/std/macro.thread_local.html"><cide>thread_local</code></a> macro and can contain any\nvalue that is <cide>#$%static</code> (no borrowed pointers). It provides an accessor function,\n<a href="LocalKey::with"><cide>with</code></a>, that yields a shared reference to the value to the specified\nclosure. Thread-local keys allow only shared access to values, as there would be no\nway to guarantee uniqueness if mutable borrows were allowed. Most values\nwill want to make use of some form of <strong>interior mutability</strong> through the\n<a href="https://docs.rs/core/*/core/cell/struct.Cell.html"><cide>Cell</code></a> or <a href="https://docs.rs/core/*/core/cell/struct.RefCell.html"><cide>RefCell</code></a> types.</p>\n<h2 id="naming-threads"><a class="header" href="#naming-threads">Naming threads</a></h2>\n<p>Threads are able to have associated names for identification purposes. By default, spawned\nthreads are unnamed. To specify a name for a thread, build the thread with <a href="https://docs.rs/std/*/std/thread/struct.Builder.html"><cide>Builder</code></a> and pass\nthe desired thread name to <a href="%60Builder::name%60"><cide>Builder::name</code></a>. To retrieve the thread name from within the\nthread, use <a href="%60Thread::name%60"><cide>Thread::name</code></a>. A couple examples of where the name of a thread gets used:</p>\n<ul>\n<li>If a panic occurs in a named thread, the thread name will be printed in the panic message.</li>\n<li>The thread name is provided to the OS where applicable (e.g., <cide>pthread_setname_np</code> in\nunix-like platforms).</li>\n</ul>\n<h2 id="stack-size"><a class="header" href="#stack-size">Stack size</a></h2>\n<p>The default stack size for spawned threads is 2 MiB, though this particular stack size is\nsubject to change in the future. There are two ways to manually specify the stack size for\nspawned threads:</p>\n<ul>\n<li>Build the thread with <a href="https://docs.rs/std/*/std/thread/struct.Builder.html"><cide>Builder</code></a> and pass the desired stack size to <a href="%60Builder::stack_size%60"><cide>Builder::stack_size</code></a>.</li>\n<li>Set the <cide>RUST_MIN_STACK</code> environment variable to an integer representing the desired stack\nsize (in bytes). Note that setting <a href="%60Builder::stack_size%60"><cide>Builder::stack_size</code></a> will override this.</li>\n</ul>\n<p>Note that the stack size of the main thread is <em>not</em> determined by Rust.</p>\n','<per><cide class="language-rust">std\n</code></pre>\n<per><cide class="language-rust">mod time\n</code></pre>\n<hr />\n<p>Temporal quantification.</p>\n<p>Example:</p>\n<per><cide>use std::time::Duration;\n\nlet five_seconds = Duration::new(5, 0);\n// both declarations are equivalent\nassert_eq!(Duration::new(5, 0), Duration::from_secs(5));\n</code></pre>\n','<per><cide class="language-rust">core::time\n</code></pre>\n<per><cide class="language-rust">pub struct Duration\n</code></pre>\n<hr />\n<p>A <cide>Duration</code> type to represent a span of time, typically used for system\ntimeouts.</p>\n<p>Each <cide>Duration</code> is composed of a whole number of seconds and a fractional part\nrepresented in nanoseconds. If the underlying system does not support\nnanosecond-level precision, APIs binding a system timeout will typically round up\nthe number of nanoseconds.</p>\n<p><a href="https://docs.rs/core/*/core/time/struct.Duration.html"><cide>Duration</code></a>s implement many common traits, including <a href="https://docs.rs/core/*/core/ops/arith/trait.Add.html"><cide>Add</code></a>, <a href="https://docs.rs/core/*/core/ops/arith/trait.Sub.html"><cide>Sub</code></a>, and other\n<a href="https://docs.rs/core/*/core/ops/index.html"><cide>ops</code></a> traits. It implements <a href="https://docs.rs/core/*/core/default/trait.Default.html"><cide>Default</code></a> by returning a zero-length <cide>Duration</code>.</p>\n<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>\n<per><cide>use std::time::Duration;\n\nlet five_seconds = Duration::new(5, 0);\nlet five_seconds_and_five_nanos = five_seconds + Duration::new(0, 5);\n\nassert_eq!(five_seconds_and_five_nanos.as_secs(), 5);\nassert_eq!(five_seconds_and_five_nanos.subsec_nanos(), 5);\n\nlet ten_millis = Duration::from_millis(10);\n</code></pre>\n<h1 id="formatting-cideduration-values"><a class="header" href="#formatting-cideduration-values">Formatting <cide>Duration</code> values</a></h1>\n<p><cide>Duration</code> intentionally does not have a <cide>Display</code> impl, as there are a\nvariety of ways to format spans of time for human readability. <cide>Duration</code>\nprovides a <cide>Debug</code> impl that shows the full precision of the value.</p>\n<p>The <cide>Debug</code> output uses the non-ASCII &quot;µs&quot; suffix for microseconds. If your\nprogram output may appear in contexts that cannot rely on full Unicode\ncompatibility, you may wish to format <cide>Duration</code> objects yourself or use a\ncrate to do so.</p>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn main()\n</code></pre>\n','<per><cide class="language-rust">std::thread\n</code></pre>\n<per><cide class="language-rust">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;\nwhere\n    F: FnOnce&lt;(), Output = T&gt; + Send + #$%static,\n    T: Send + #$%static,\n</code></pre>\n<hr />\n<p>Spawns a new thread, returning a <a href="https://docs.rs/std/*/std/thread/struct.JoinHandle.html"><cide>JoinHandle</code></a> for it.</p>\n<p>The join handle will implicitly <em>detach</em> the child thread upon being\ndropped. In this case, the child thread may outlive the parent (unless\nthe parent thread is the main thread; the whole process is terminated when\nthe main thread finishes). Additionally, the join handle provides a <a href="JoinHandle::join"><cide>join</code></a>\nmethod that can be used to join the child thread. If the child thread\npanics, <a href="JoinHandle::join"><cide>join</code></a> will return an <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Err</code></a> containing the argument given to\n<a href="https://docs.rs/core/*/core/macro.panic.html"><cide>panic</code></a>.</p>\n<p>This will create a thread using default parameters of <a href="https://docs.rs/std/*/std/thread/struct.Builder.html"><cide>Builder</code></a>, if you\nwant to specify the stack size or the name of the thread, use this API\ninstead.</p>\n<p>As you can see in the signature of <cide>spawn</code> there are two constraints on\nboth the closure given to <cide>spawn</code> and its return value, let#$%s explain them:</p>\n<ul>\n<li>The <cide>#$%static</code> constraint means that the closure and its return value\nmust have a lifetime of the whole program execution. The reason for this\nis that threads can <cide>detach</code> and outlive the lifetime they have been\ncreated in.\nIndeed if the thread, and by extension its return value, can outlive their\ncaller, we need to make sure that they will be valid afterwards, and since\nwe <em>can#$%t</em> know when it will return we need to have them valid as long as\npossible, that is until the end of the program, hence the <cide>#$%static</code>\nlifetime.</li>\n<li>The <a href="https://docs.rs/core/*/core/marker/trait.Send.html"><cide>Send</code></a> constraint is because the closure will need to be passed\n<em>by value</em> from the thread where it is spawned to the new thread. Its\nreturn value will need to be passed from the new thread to the thread\nwhere it is <cide>join</code>ed.\nAs a reminder, the <a href="https://docs.rs/core/*/core/marker/trait.Send.html"><cide>Send</code></a> marker trait expresses that it is safe to be\npassed from thread to thread. <a href="https://docs.rs/core/*/core/marker/trait.Sync.html"><cide>Sync</code></a> expresses that it is safe to have a\nreference be passed from thread to thread.</li>\n</ul>\n<h1 id="panics"><a class="header" href="#panics">Panics</a></h1>\n<p>Panics if the OS fails to create a thread; use <a href="%60Builder::spawn%60"><cide>Builder::spawn</code></a>\nto recover from such errors.</p>\n<h1 id="examples-1"><a class="header" href="#examples-1">Examples</a></h1>\n<p>Creating a thread.</p>\n<per><cide>use std::thread;\n\nlet handler = thread::spawn(|| {\n    // thread code\n});\n\nhandler.join().unwrap();\n</code></pre>\n<p>As mentioned in the module documentation, threads are usually made to\ncommunicate using <a href="https://docs.rs/std/*/std/sync/mpsc/index.html"><cide>channels</code></a>, here is how it usually looks.</p>\n<p>This example also shows how to use <cide>move</code>, in order to give ownership\nof values to a thread.</p>\n<per><cide>use std::thread;\nuse std::sync::mpsc::channel;\n\nlet (tx, rx) = channel();\n\nlet sender = thread::spawn(move || {\n    tx.send(&quot;Hello, thread&quot;.to_owned())\n        .expect(&quot;Unable to send on channel&quot;);\n});\n\nlet receiver = thread::spawn(move || {\n    let value = rx.recv().expect(&quot;Unable to receive from channel&quot;);\n    println!(&quot;{}&quot;, value);\n});\n\nsender.join().expect(&quot;The sender thread has panicked&quot;);\nreceiver.join().expect(&quot;The receiver thread has panicked&quot;);\n</code></pre>\n<p>A thread can also return a value through its <a href="https://docs.rs/std/*/std/thread/struct.JoinHandle.html"><cide>JoinHandle</code></a>, you can use\nthis to make asynchronous computations (futures might be more appropriate\nthough).</p>\n<per><cide>use std::thread;\n\nlet computation = thread::spawn(|| {\n    // Some expensive computation.\n    42\n});\n\nlet result = computation.join().unwrap();\nprintln!(&quot;{}&quot;, result);\n</code></pre>\n','<per><cide class="language-rust">i: i32\n</code></pre>\n','<per><cide class="language-rust">std\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! println\n</code></pre>\n<hr />\n<p>Prints to the standard output, with a newline.</p>\n<p>On all platforms, the newline is the LINE FEED character (<cide>\n</code>/<cide>U+000A</code>) alone\n(no additional CARRIAGE RETURN (<cide>\r</code>/<cide>U+000D</code>)).</p>\n<p>Use the <a href="%60format!%60"><cide>format!</code></a> syntax to write data to the standard output.\nSee <a href="crate::fmt"><cide>std::fmt</code></a> for more information.</p>\n<p>Use <cide>println!</code> only for the primary output of your program. Use\n<a href="%60eprintln!%60"><cide>eprintln!</code></a> instead to print error and progress messages.</p>\n<h1 id="panics-1"><a class="header" href="#panics-1">Panics</a></h1>\n<p>Panics if writing to <a href="crate::io::stdout"><cide>io::stdout</code></a> fails.</p>\n<h1 id="examples-2"><a class="header" href="#examples-2">Examples</a></h1>\n<per><cide>println!(); // prints just a newline\nprintln!(&quot;hello there!&quot;);\nprintln!(&quot;format {} arguments&quot;, &quot;some&quot;);\n</code></pre>\n','<per><cide class="language-rust">std::thread\n</code></pre>\n<per><cide class="language-rust">pub fn sleep(dur: Duration)\n</code></pre>\n<hr />\n<p>Puts the current thread to sleep for at least the specified amount of time.</p>\n<p>The thread may sleep longer than the duration specified due to scheduling\nspecifics or platform-dependent functionality. It will never sleep less.</p>\n<p>This function is blocking, and should not be used in <cide>async</code> functions.</p>\n<h1 id="platform-specific-behavior"><a class="header" href="#platform-specific-behavior">Platform-specific behavior</a></h1>\n<p>On Unix platforms, the underlying syscall may be interrupted by a\nspurious wakeup or signal handler. To ensure the sleep occurs for at least\nthe specified duration, this function may invoke that system call multiple\ntimes.\nPlatforms which do not support nanosecond precision for sleeping will\nhave <cide>dur</code> rounded up to the nearest granularity of time they can sleep for.</p>\n<p>Currently, specifying a zero duration on Unix platforms returns immediately\nwithout invoking the underlying <a href="https://linux.die.net/man/2/nanosleep"><cide>nanosleep</code></a> syscall, whereas on Windows\nplatforms the underlying <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep"><cide>Sleep</code></a> syscall is always invoked.\nIf the intention is to yield the current time-slice you may want to use\n<a href="https://docs.rs/std/*/std/thread/fn.yield_now.html"><cide>yield_now</code></a> instead.</p>\n<h1 id="examples-3"><a class="header" href="#examples-3">Examples</a></h1>\n<per><cide class="language-no_run">use std::{thread, time};\n\nlet ten_millis = time::Duration::from_millis(10);\nlet now = time::Instant::now();\n\nthread::sleep(ten_millis);\n\nassert!(now.elapsed() &gt;= ten_millis);\n</code></pre>\n','<per><cide class="language-rust">core::time::Duration\n</code></pre>\n<per><cide class="language-rust">pub const fn from_millis(millis: u64) -&gt; Duration\n</code></pre>\n<hr />\n<p>Creates a new <cide>Duration</code> from the specified number of milliseconds.</p>\n<h1 id="examples-4"><a class="header" href="#examples-4">Examples</a></h1>\n<per><cide>use std::time::Duration;\n\nlet duration = Duration::from_millis(2569);\n\nassert_eq!(2, duration.as_secs());\nassert_eq!(569_000_000, duration.subsec_nanos());\n</code></pre>\n','<per><cide class="language-rust">let handle: JoinHandle&lt;()&gt;\n</code></pre>\n','<per><cide class="language-rust">std::thread::JoinHandle\n</code></pre>\n<per><cide class="language-rust">pub fn join(self) -&gt; Result&lt;T&gt;\n</code></pre>\n<hr />\n<p>Waits for the associated thread to finish.</p>\n<p>In terms of <a href="https://docs.rs/core/*/core/sync/atomic/index.html">atomic memory orderings</a>,  the completion of the associated\nthread synchronizes with this function returning. In other words, all\noperations performed by that thread are ordered before all\noperations that happen after <cide>join</code> returns.</p>\n<p>If the child thread panics, <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Err</code></a> is returned with the parameter given\nto <a href="https://docs.rs/core/*/core/macro.panic.html"><cide>panic</code></a>.</p>\n<h1 id="panics-2"><a class="header" href="#panics-2">Panics</a></h1>\n<p>This function may panic on some platforms if a thread attempts to join\nitself or otherwise may create a deadlock with joining threads.</p>\n<h1 id="examples-5"><a class="header" href="#examples-5">Examples</a></h1>\n<per><cide>use std::thread;\n\nlet builder = thread::Builder::new();\n\nlet join_handle: thread::JoinHandle&lt;_&gt; = builder.spawn(|| {\n    // some work here\n}).unwrap();\njoin_handle.join().expect(&quot;Couldn#$%t join on the associated thread&quot;);\n</code></pre>\n','<per><cide class="language-rust">core::result::Result\n</code></pre>\n<per><cide class="language-rust">pub fn unwrap(self) -&gt; T\n</code></pre>\n<hr />\n<p>Returns the contained <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Ok</code></a> value, consuming the <cide>self</code> value.</p>\n<p>Because this function may panic, its use is generally discouraged.\nInstead, prefer to use pattern matching and handle the <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Err</code></a>\ncase explicitly, or call <a href="Result::unwrap_or"><cide>unwrap_or</code></a>, <a href="Result::unwrap_or_else"><cide>unwrap_or_else</code></a>, or\n<a href="Result::unwrap_or_default"><cide>unwrap_or_default</code></a>.</p>\n<h1 id="panics-3"><a class="header" href="#panics-3">Panics</a></h1>\n<p>Panics if the value is an <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Err</code></a>, with a panic message provided by the\n<a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Err</code></a>#$%s value.</p>\n<h1 id="examples-6"><a class="header" href="#examples-6">Examples</a></h1>\n<p>Basic usage:</p>\n<per><cide>let x: Result&lt;u32, &amp;str&gt; = Ok(2);\nassert_eq!(x.unwrap(), 2);\n</code></pre>\n<per><cide class="language-should_panic">let x: Result&lt;u32, &amp;str&gt; = Err(&quot;emergency failure&quot;);\nx.unwrap(); // panics with `emergency failure`\n</code></pre>\n','<per><cide class="language-rust">let v: Vec&lt;i32, Global&gt;\n</code></pre>\n','<per><cide class="language-rust">alloc\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! vec\n</code></pre>\n<hr />\n<p>Creates a <a href="crate::vec::Vec"><cide>Vec</code></a> containing the arguments.</p>\n<p><cide>vec!</code> allows <cide>Vec</code>s to be defined with the same syntax as array expressions.\nThere are two forms of this macro:</p>\n<ul>\n<li>Create a <a href="crate::vec::Vec"><cide>Vec</code></a> containing a given list of elements:</li>\n</ul>\n<per><cide>let v = vec![1, 2, 3];\nassert_eq!(v[0], 1);\nassert_eq!(v[1], 2);\nassert_eq!(v[2], 3);\n</code></pre>\n<ul>\n<li>Create a <a href="crate::vec::Vec"><cide>Vec</code></a> from a given element and size:</li>\n</ul>\n<per><cide>let v = vec![1; 3];\nassert_eq!(v, [1, 1, 1]);\n</code></pre>\n<p>Note that unlike array expressions this syntax supports all elements\nwhich implement <a href="%60Clone%60"><cide>Clone</code></a> and the number of elements doesn#$%t have to be\na constant.</p>\n<p>This will use <cide>clone</code> to duplicate an expression, so one should be careful\nusing this with types having a nonstandard <cide>Clone</code> implementation. For\nexample, <cide>vec![Rc::new(1); 5]</code> will create a vector of five references\nto the same boxed integer value, not five references pointing to independently\nboxed integers.</p>\n<p>Also, note that <cide>vec![expr; 0]</code> is allowed, and produces an empty vector.\nThis will still evaluate <cide>expr</code>, however, and immediately drop the resulting value, so\nbe mindful of side effects.</p>\n','<per><cide class="language-rust">core::mem\n</code></pre>\n<per><cide class="language-rust">pub fn drop&lt;T&gt;(_x: T)\n</code></pre>\n<hr />\n<p>Disposes of a value.</p>\n<p>This does so by calling the argument#$%s implementation of <a href="https://docs.rs/core/*/core/ops/drop/trait.Drop.html"><cide>Drop</code></a>.</p>\n<p>This effectively does nothing for types which implement <cide>Copy</code>, e.g.\nintegers. Such values are copied and <em>then</em> moved into the function, so the\nvalue persists after this function call.</p>\n<p>This function is not magic; it is literally defined as</p>\n<per><cide>pub fn drop&lt;T&gt;(_x: T) { }\n</code></pre>\n<p>Because <cide>_x</code> is moved into the function, it is automatically dropped before\nthe function returns.</p>\n<h1 id="examples-7"><a class="header" href="#examples-7">Examples</a></h1>\n<p>Basic usage:</p>\n<per><cide>let v = vec![1, 2, 3];\n\ndrop(v); // explicitly drop the vector\n</code></pre>\n<p>Since <a href="https://docs.rs/core/*/core/cell/struct.RefCell.html"><cide>RefCell</code></a> enforces the borrow rules at runtime, <cide>drop</code> can\nrelease a <a href="https://docs.rs/core/*/core/cell/struct.RefCell.html"><cide>RefCell</code></a> borrow:</p>\n<per><cide>use std::cell::RefCell;\n\nlet x = RefCell::new(1);\n\nlet mut mutable_borrow = x.borrow_mut();\n*mutable_borrow = 1;\n\ndrop(mutable_borrow); // relinquish the mutable borrow on this slot\n\nlet borrow = x.borrow();\nprintln!(&quot;{}&quot;, *borrow);\n</code></pre>\n<p>Integers and other types implementing <a href="https://docs.rs/core/*/core/marker/trait.Copy.html"><cide>Copy</code></a> are unaffected by <cide>drop</code>.</p>\n<per><cide>#[derive(Copy, Clone)]\nstruct Foo(u8);\n\nlet x = 1;\nlet y = Foo(2);\ndrop(x); // a copy of `x` is moved and dropped\ndrop(y); // a copy of `y` is moved and dropped\n\nprintln!(&quot;x: {}, y: {}&quot;, x, y.0); // still available\n</code></pre>\n',].map((x)=>x.replaceAll('#$%', "'").replaceAll('<per', '<pre').replaceAll('<cide', '<code'));
    window.onload = () => {
        console.log("hello");
        tippy('.ra', {
            content: (x) => {
                const div = document.createElement('div');
                div.innerHTML = hoverData[x.dataset.hover];
                div.className = 'hover-holder';
                div.querySelectorAll('code').forEach((y) => y.innerHTML = hljs.highlight('rust', y.innerText).value);
                return div;
            },
            allowHTML: true,
            delay: [200, 0],
            interactive: true,
            maxWidth: '80vw',
            appendTo: document.querySelector('.content'),
        });
    };
</script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="ch16-00-concurrency.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="ch16-02-message-passing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="ch16-00-concurrency.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="ch16-02-message-passing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="ferris.js"></script>
        
        
    </body>
</html>
