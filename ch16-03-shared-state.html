<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Shared-State Concurrency - The Rust Programming Language</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="ferris.css">
                <link rel="stylesheet" href="theme/2018-edition.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References and Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> The Slice Type</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> How to Write Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlling How Tests Are Run</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html" class="active"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.inlay-hint, .inlay-hint * {
    border-radius: .4em;
}

.light .inlay-hint, .rust .inlay-hint {
    background-color: #dcc;
    color: #777;
}

.ayu .inlay-hint, .navy .inlay-hint, .coal .inlay-hint {
    background-color: #444;
    color: #999;
}

.inlay-hint {
    font-size: 0.8em;
    user-select: none;
}
.hover-holder {
    max-height: 40vh;
    overflow: auto;
}

.tippy-content {
    background-color: var(--bg);
    color: var(--fg);
}
</style>## Shared-State Concurrency
<p>Message passing is a fine way of handling concurrency, but it’s not the only
one. Consider this part of the slogan from the Go language documentation again:
“do not communicate by sharing memory.”</p>
<p>What would communicating by sharing memory look like? In addition, why would
message-passing enthusiasts not use it and do the opposite instead?</p>
<p>In a way, channels in any programming language are similar to single ownership,
because once you transfer a value down a channel, you should no longer use that
value. Shared memory concurrency is like multiple ownership: multiple threads
can access the same memory location at the same time. As you saw in Chapter 15,
where smart pointers made multiple ownership possible, multiple ownership can
add complexity because these different owners need managing. Rust’s type system
and ownership rules greatly assist in getting this management correct. For an
example, let’s look at mutexes, one of the more common concurrency primitives
for shared memory.</p>
<h3 id="using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time"><a class="header" href="#using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time">Using Mutexes to Allow Access to Data from One Thread at a Time</a></h3>
<p><em>Mutex</em> is an abbreviation for <em>mutual exclusion</em>, as in, a mutex allows only
one thread to access some data at any given time. To access the data in a
mutex, a thread must first signal that it wants access by asking to acquire the
mutex’s <em>lock</em>. The lock is a data structure that is part of the mutex that
keeps track of who currently has exclusive access to the data. Therefore, the
mutex is described as <em>guarding</em> the data it holds via the locking system.</p>
<p>Mutexes have a reputation for being difficult to use because you have to
remember two rules:</p>
<ul>
<li>You must attempt to acquire the lock before using the data.</li>
<li>When you’re done with the data that the mutex guards, you must unlock the
data so other threads can acquire the lock.</li>
</ul>
<p>For a real-world metaphor for a mutex, imagine a panel discussion at a
conference with only one microphone. Before a panelist can speak, they have to
ask or signal that they want to use the microphone. When they get the
microphone, they can talk for as long as they want to and then hand the
microphone to the next panelist who requests to speak. If a panelist forgets to
hand the microphone off when they’re finished with it, no one else is able to
speak. If management of the shared microphone goes wrong, the panel won’t work
as planned!</p>
<p>Management of mutexes can be incredibly tricky to get right, which is why so
many people are enthusiastic about channels. However, thanks to Rust’s type
system and ownership rules, you can’t get locking and unlocking wrong.</p>
<h4 id="the-api-of-mutext"><a class="header" href="#the-api-of-mutext">The API of <code>Mutex&lt;T&gt;</code></a></h4>
<p>As an example of how to use a mutex, let’s start by using a mutex in a
single-threaded context, as shown in Listing 16-12:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use <span class="ra" data-hover="0">std</span>::<span class="ra" data-hover="1">sync</span>::<span class="ra" data-hover="2">Mutex</span>;

fn <span class="ra" data-hover="3">main</span>() {
    let <span class="ra" data-hover="4">m</span><span class="inlay-hint">: Mutex&lt;i32&gt;</span> = <span class="ra" data-hover="2">Mutex</span>::<span class="ra" data-hover="5">new</span>(5);

    {
        let mut <span class="ra" data-hover="6">num</span><span class="inlay-hint">: MutexGuard&lt;i32&gt;</span> = <span class="ra" data-hover="4">m</span>.<span class="ra" data-hover="7">lock</span>().<span class="ra" data-hover="8">unwrap</span>();
        *<span class="ra" data-hover="6">num</span> = 6;
    }

    <span class="ra" data-hover="9">println</span>!("m = {:?}", <span class="ra" data-hover="4">m</span>);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 16-12: Exploring the API of <code>Mutex&lt;T&gt;</code> in a
single-threaded context for simplicity</span></p>
<p>As with many types, we create a <code>Mutex&lt;T&gt;</code> using the associated function <code>new</code>.
To access the data inside the mutex, we use the <code>lock</code> method to acquire the
lock. This call will block the current thread so it can’t do any work until
it’s our turn to have the lock.</p>
<p>The call to <code>lock</code> would fail if another thread holding the lock panicked. In
that case, no one would ever be able to get the lock, so we’ve chosen to
<code>unwrap</code> and have this thread panic if we’re in that situation.</p>
<p>After we’ve acquired the lock, we can treat the return value, named <code>num</code> in
this case, as a mutable reference to the data inside. The type system ensures
that we acquire a lock before using the value in <code>m</code>: <code>Mutex&lt;i32&gt;</code> is not an
<code>i32</code>, so we <em>must</em> acquire the lock to be able to use the <code>i32</code> value. We
can’t forget; the type system won’t let us access the inner <code>i32</code> otherwise.</p>
<p>As you might suspect, <code>Mutex&lt;T&gt;</code> is a smart pointer. More accurately, the call
to <code>lock</code> <em>returns</em> a smart pointer called <code>MutexGuard</code>, wrapped in a
<code>LockResult</code> that we handled with the call to <code>unwrap</code>. The <code>MutexGuard</code> smart
pointer implements <code>Deref</code> to point at our inner data; the smart pointer also
has a <code>Drop</code> implementation that releases the lock automatically when a
<code>MutexGuard</code> goes out of scope, which happens at the end of the inner scope in
Listing 16-12. As a result, we don’t risk forgetting to release the lock and
blocking the mutex from being used by other threads because the lock release
happens automatically.</p>
<p>After dropping the lock, we can print the mutex value and see that we were able
to change the inner <code>i32</code> to 6.</p>
<h4 id="sharing-a-mutext-between-multiple-threads"><a class="header" href="#sharing-a-mutext-between-multiple-threads">Sharing a <code>Mutex&lt;T&gt;</code> Between Multiple Threads</a></h4>
<p>Now, let’s try to share a value between multiple threads using <code>Mutex&lt;T&gt;</code>.
We’ll spin up 10 threads and have them each increment a counter value by 1, so
the counter goes from 0 to 10. The next example in Listing 16-13 will have
a compiler error, and we’ll use that error to learn more about using
<code>Mutex&lt;T&gt;</code> and how Rust helps us use it correctly.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use <span class="ra" data-hover="0">std</span>::<span class="ra" data-hover="1">sync</span>::<span class="ra" data-hover="2">Mutex</span>;
use <span class="ra" data-hover="0">std</span>::<span class="ra" data-hover="10">thread</span>;

fn <span class="ra" data-hover="3">main</span>() {
    let <span class="ra" data-hover="11">counter</span><span class="inlay-hint">: Mutex&lt;i32&gt;</span> = <span class="ra" data-hover="2">Mutex</span>::<span class="ra" data-hover="5">new</span>(0);
    let mut <span class="ra" data-hover="12">handles</span><span class="inlay-hint">: Vec&lt;JoinHandle&lt;()&gt;&gt;</span> = <span class="ra" data-hover="13">vec</span>![];

    for _ in 0..10 {
        let <span class="ra" data-hover="14">handle</span><span class="inlay-hint">: JoinHandle&lt;()&gt;</span> = <span class="ra" data-hover="10">thread</span>::<span class="ra" data-hover="15">spawn</span>(move || {
            let mut <span class="ra" data-hover="6">num</span><span class="inlay-hint">: MutexGuard&lt;i32&gt;</span> = <span class="ra" data-hover="11">counter</span>.<span class="ra" data-hover="7">lock</span>().<span class="ra" data-hover="8">unwrap</span>();

            *<span class="ra" data-hover="6">num</span> += 1;
        });
        <span class="ra" data-hover="12">handles</span>.<span class="ra" data-hover="16">push</span>(<span class="ra" data-hover="14">handle</span>);
    }

    for <span class="ra" data-hover="17">handle</span><span class="inlay-hint">: JoinHandle&lt;()&gt;</span> in <span class="ra" data-hover="12">handles</span> {
        <span class="ra" data-hover="17">handle</span>.<span class="ra" data-hover="18">join</span>().<span class="ra" data-hover="8">unwrap</span>();
    }

    <span class="ra" data-hover="9">println</span>!("Result: {}", *<span class="ra" data-hover="11">counter</span>.<span class="ra" data-hover="7">lock</span>().<span class="ra" data-hover="8">unwrap</span>());
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 16-13: Ten threads each increment a counter
guarded by a <code>Mutex&lt;T&gt;</code></span></p>
<p>We create a <code>counter</code> variable to hold an <code>i32</code> inside a <code>Mutex&lt;T&gt;</code>, as we
did in Listing 16-12. Next, we create 10 threads by iterating over a range
of numbers. We use <code>thread::spawn</code> and give all the threads the same closure,
one that moves the counter into the thread, acquires a lock on the <code>Mutex&lt;T&gt;</code>
by calling the <code>lock</code> method, and then adds 1 to the value in the mutex. When a
thread finishes running its closure, <code>num</code> will go out of scope and release the
lock so another thread can acquire it.</p>
<p>In the main thread, we collect all the join handles. Then, as we did in Listing
16-2, we call <code>join</code> on each handle to make sure all the threads finish. At
that point, the main thread will acquire the lock and print the result of this
program.</p>
<p>We hinted that this example wouldn’t compile. Now let’s find out why!</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:9:36
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
9  |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^ value moved into closure here, in previous iteration of loop
10 |             let mut num = counter.lock().unwrap();
   |                           ------- use occurs due to use in closure

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` due to previous error
</code></pre>
<p>The error message states that the <code>counter</code> value was moved in the previous
iteration of the loop. So Rust is telling us that we can’t move the ownership
of lock <code>counter</code> into multiple threads. Let’s fix the compiler error with a
multiple-ownership method we discussed in Chapter 15.</p>
<h4 id="multiple-ownership-with-multiple-threads"><a class="header" href="#multiple-ownership-with-multiple-threads">Multiple Ownership with Multiple Threads</a></h4>
<p>In Chapter 15, we gave a value multiple owners by using the smart pointer
<code>Rc&lt;T&gt;</code> to create a reference counted value. Let’s do the same here and see
what happens. We’ll wrap the <code>Mutex&lt;T&gt;</code> in <code>Rc&lt;T&gt;</code> in Listing 16-14 and clone
the <code>Rc&lt;T&gt;</code> before moving ownership to the thread.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use <span class="ra" data-hover="0">std</span>::<span class="ra" data-hover="19">rc</span>::<span class="ra" data-hover="20">Rc</span>;
use <span class="ra" data-hover="0">std</span>::<span class="ra" data-hover="1">sync</span>::<span class="ra" data-hover="2">Mutex</span>;
use <span class="ra" data-hover="0">std</span>::<span class="ra" data-hover="10">thread</span>;

fn <span class="ra" data-hover="3">main</span>() {
    let <span class="ra" data-hover="21">counter</span><span class="inlay-hint">: Rc&lt;Mutex&lt;i32&gt;&gt;</span> = <span class="ra" data-hover="20">Rc</span>::<span class="ra" data-hover="22">new</span>(<span class="ra" data-hover="2">Mutex</span>::<span class="ra" data-hover="5">new</span>(0));
    let mut <span class="ra" data-hover="12">handles</span><span class="inlay-hint">: Vec&lt;JoinHandle&lt;()&gt;&gt;</span> = <span class="ra" data-hover="13">vec</span>![];

    for _ in 0..10 {
        let <span class="ra" data-hover="21">counter</span><span class="inlay-hint">: Rc&lt;Mutex&lt;i32&gt;&gt;</span> = <span class="ra" data-hover="20">Rc</span>::<span class="ra" data-hover="23">clone</span>(<span class="inlay-hint">self: </span>&amp;<span class="ra" data-hover="21">counter</span>);
        let <span class="ra" data-hover="14">handle</span><span class="inlay-hint">: JoinHandle&lt;()&gt;</span> = <span class="ra" data-hover="10">thread</span>::<span class="ra" data-hover="15">spawn</span>(move || {
            let mut <span class="ra" data-hover="6">num</span><span class="inlay-hint">: MutexGuard&lt;i32&gt;</span> = <span class="ra" data-hover="21">counter</span>.<span class="ra" data-hover="7">lock</span>().<span class="ra" data-hover="8">unwrap</span>();

            *<span class="ra" data-hover="6">num</span> += 1;
        });
        <span class="ra" data-hover="12">handles</span>.<span class="ra" data-hover="16">push</span>(<span class="ra" data-hover="14">handle</span>);
    }

    for <span class="ra" data-hover="17">handle</span><span class="inlay-hint">: JoinHandle&lt;()&gt;</span> in <span class="ra" data-hover="12">handles</span> {
        <span class="ra" data-hover="17">handle</span>.<span class="ra" data-hover="18">join</span>().<span class="ra" data-hover="8">unwrap</span>();
    }

    <span class="ra" data-hover="9">println</span>!("Result: {}", *<span class="ra" data-hover="21">counter</span>.<span class="ra" data-hover="7">lock</span>().<span class="ra" data-hover="8">unwrap</span>());
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 16-14: Attempting to use <code>Rc&lt;T&gt;</code> to allow
multiple threads to own the <code>Mutex&lt;T&gt;</code></span></p>
<p>Once again, we compile and get... different errors! The compiler is teaching us
a lot.</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:11:22
    |
11  |           let handle = thread::spawn(move || {
    |  ______________________^^^^^^^^^^^^^_-
    | |                      |
    | |                      `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
12  | |             let mut num = counter.lock().unwrap();
13  | |
14  | |             *num += 1;
15  | |         });
    | |_________- within this `[closure@src/main.rs:11:36: 15:10]`
    |
    = help: within `[closure@src/main.rs:11:36: 15:10]`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`
    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10]`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state` due to previous error
</code></pre>
<p>Wow, that error message is very wordy! Here’s the important part to focus
on: <code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>. The compiler
is also telling us the reason why: <code>the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;` </code>. We’ll talk about <code>Send</code> in the next section: it’s one of
the traits that ensures the types we use with threads are meant for use in
concurrent situations.</p>
<p>Unfortunately, <code>Rc&lt;T&gt;</code> is not safe to share across threads. When <code>Rc&lt;T&gt;</code>
manages the reference count, it adds to the count for each call to <code>clone</code> and
subtracts from the count when each clone is dropped. But it doesn’t use any
concurrency primitives to make sure that changes to the count can’t be
interrupted by another thread. This could lead to wrong counts—subtle bugs that
could in turn lead to memory leaks or a value being dropped before we’re done
with it. What we need is a type exactly like <code>Rc&lt;T&gt;</code> but one that makes changes
to the reference count in a thread-safe way.</p>
<h4 id="atomic-reference-counting-with-arct"><a class="header" href="#atomic-reference-counting-with-arct">Atomic Reference Counting with <code>Arc&lt;T&gt;</code></a></h4>
<p>Fortunately, <code>Arc&lt;T&gt;</code> <em>is</em> a type like <code>Rc&lt;T&gt;</code> that is safe to use in
concurrent situations. The <em>a</em> stands for <em>atomic</em>, meaning it’s an <em>atomically
reference counted</em> type. Atomics are an additional kind of concurrency
primitive that we won’t cover in detail here: see the standard library
documentation for <a href="../std/sync/atomic/index.html"><code>std::sync::atomic</code></a> for more details. At this point, you just
need to know that atomics work like primitive types but are safe to share
across threads.</p>
<p>You might then wonder why all primitive types aren’t atomic and why standard
library types aren’t implemented to use <code>Arc&lt;T&gt;</code> by default. The reason is that
thread safety comes with a performance penalty that you only want to pay when
you really need to. If you’re just performing operations on values within a
single thread, your code can run faster if it doesn’t have to enforce the
guarantees atomics provide.</p>
<p>Let’s return to our example: <code>Arc&lt;T&gt;</code> and <code>Rc&lt;T&gt;</code> have the same API, so we fix
our program by changing the <code>use</code> line, the call to <code>new</code>, and the call to
<code>clone</code>. The code in Listing 16-15 will finally compile and run:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use <span class="ra" data-hover="0">std</span>::<span class="ra" data-hover="1">sync</span>::{<span class="ra" data-hover="24">Arc</span>, <span class="ra" data-hover="2">Mutex</span>};
use <span class="ra" data-hover="0">std</span>::<span class="ra" data-hover="10">thread</span>;

fn <span class="ra" data-hover="3">main</span>() {
    let <span class="ra" data-hover="25">counter</span><span class="inlay-hint">: Arc&lt;Mutex&lt;i32&gt;&gt;</span> = <span class="ra" data-hover="24">Arc</span>::<span class="ra" data-hover="26">new</span>(<span class="ra" data-hover="2"><span class="inlay-hint">data: </span>Mutex</span>::<span class="ra" data-hover="5">new</span>(0));
    let mut <span class="ra" data-hover="12">handles</span><span class="inlay-hint">: Vec&lt;JoinHandle&lt;()&gt;&gt;</span> = <span class="ra" data-hover="13">vec</span>![];

    for _ in 0..10 {
        let <span class="ra" data-hover="25">counter</span><span class="inlay-hint">: Arc&lt;Mutex&lt;i32&gt;&gt;</span> = <span class="ra" data-hover="24">Arc</span>::<span class="ra" data-hover="23">clone</span>(<span class="inlay-hint">self: </span>&amp;<span class="ra" data-hover="25">counter</span>);
        let <span class="ra" data-hover="14">handle</span><span class="inlay-hint">: JoinHandle&lt;()&gt;</span> = <span class="ra" data-hover="10">thread</span>::<span class="ra" data-hover="15">spawn</span>(move || {
            let mut <span class="ra" data-hover="6">num</span><span class="inlay-hint">: MutexGuard&lt;i32&gt;</span> = <span class="ra" data-hover="25">counter</span>.<span class="ra" data-hover="7">lock</span>().<span class="ra" data-hover="8">unwrap</span>();

            *<span class="ra" data-hover="6">num</span> += 1;
        });
        <span class="ra" data-hover="12">handles</span>.<span class="ra" data-hover="16">push</span>(<span class="ra" data-hover="14">handle</span>);
    }

    for <span class="ra" data-hover="17">handle</span><span class="inlay-hint">: JoinHandle&lt;()&gt;</span> in <span class="ra" data-hover="12">handles</span> {
        <span class="ra" data-hover="17">handle</span>.<span class="ra" data-hover="18">join</span>().<span class="ra" data-hover="8">unwrap</span>();
    }

    <span class="ra" data-hover="9">println</span>!("Result: {}", *<span class="ra" data-hover="25">counter</span>.<span class="ra" data-hover="7">lock</span>().<span class="ra" data-hover="8">unwrap</span>());
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 16-15: Using an <code>Arc&lt;T&gt;</code> to wrap the <code>Mutex&lt;T&gt;</code>
to be able to share ownership across multiple threads</span></p>
<p>This code will print the following:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Result: 10
</code></pre>
<p>We did it! We counted from 0 to 10, which may not seem very impressive, but it
did teach us a lot about <code>Mutex&lt;T&gt;</code> and thread safety. You could also use this
program’s structure to do more complicated operations than just incrementing a
counter. Using this strategy, you can divide a calculation into independent
parts, split those parts across threads, and then use a <code>Mutex&lt;T&gt;</code> to have each
thread update the final result with its part.</p>
<h3 id="similarities-between-refcelltrct-and-mutextarct"><a class="header" href="#similarities-between-refcelltrct-and-mutextarct">Similarities Between <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> and <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code></a></h3>
<p>You might have noticed that <code>counter</code> is immutable but we could get a mutable
reference to the value inside it; this means <code>Mutex&lt;T&gt;</code> provides interior
mutability, as the <code>Cell</code> family does. In the same way we used <code>RefCell&lt;T&gt;</code> in
Chapter 15 to allow us to mutate contents inside an <code>Rc&lt;T&gt;</code>, we use <code>Mutex&lt;T&gt;</code>
to mutate contents inside an <code>Arc&lt;T&gt;</code>.</p>
<p>Another detail to note is that Rust can’t protect you from all kinds of logic
errors when you use <code>Mutex&lt;T&gt;</code>. Recall in Chapter 15 that using <code>Rc&lt;T&gt;</code> came
with the risk of creating reference cycles, where two <code>Rc&lt;T&gt;</code> values refer to
each other, causing memory leaks. Similarly, <code>Mutex&lt;T&gt;</code> comes with the risk of
creating <em>deadlocks</em>. These occur when an operation needs to lock two resources
and two threads have each acquired one of the locks, causing them to wait for
each other forever. If you’re interested in deadlocks, try creating a Rust
program that has a deadlock; then research deadlock mitigation strategies for
mutexes in any language and have a go at implementing them in Rust. The
standard library API documentation for <code>Mutex&lt;T&gt;</code> and <code>MutexGuard</code> offers
useful information.</p>
<p>We’ll round out this chapter by talking about the <code>Send</code> and <code>Sync</code> traits and
how we can use them with custom types.</p>
<script src="https://unpkg.com/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
<script src="https://unpkg.com/tippy.js@6.3.2/dist/tippy-bundle.umd.min.js" integrity="sha384-vApKv6LkBdPwmt/fNiQrBCVCZvuniXpG0b5UZhVrGAq1zXdZRSsPcWjGdVxkZJtX" crossorigin="anonymous"></script>
<script>
    const hoverData = ['<per><cide class="language-rust">extern crate std\n</code></pre>\n<hr />\n<h1 id="the-rust-standard-library"><a class="header" href="#the-rust-standard-library">The Rust Standard Library</a></h1>\n<p>The Rust Standard Library is the foundation of portable Rust software, a\nset of minimal and battle-tested shared abstractions for the <a href="https://crates.io">broader Rust\necosystem</a>. It offers core types, like <a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a> and\n<a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>Option&lt;T&gt;</code></a>, library-defined <a href="https://docs.rs/std/*/std/index.html#primitives">operations on language\nprimitives</a>, <a href="https://docs.rs/std/*/std/index.html#macros">standard macros</a>, <a href="https://docs.rs/std/*/std/io/index.html">I/O</a> and\n<a href="https://docs.rs/std/*/std/thread/index.html">multithreading</a>, among <a href="https://docs.rs/std/*/std/index.html#what-is-in-the-standard-library-documentation">many other things</a>.</p>\n<p><cide>std</code> is available to all Rust crates by default. Therefore, the\nstandard library can be accessed in <a href="https://docs.rs/std/*/book/ch07-02-defining-modules-to-control-scope-and-privacy.html"><cide>use</code></a> statements through the path\n<cide>std</code>, as in <a href="https://docs.rs/std/*/std/env/index.html"><cide>use std::env</code></a>.</p>\n<h1 id="how-to-read-this-documentation"><a class="header" href="#how-to-read-this-documentation">How to read this documentation</a></h1>\n<p>If you already know the name of what you are looking for, the fastest way to\nfind it is to use the <!-- raw HTML omitted -->search\nbar<!-- raw HTML omitted --> at the top of the page.</p>\n<p>Otherwise, you may want to jump to one of these useful sections:</p>\n<ul>\n<li><a href="https://docs.rs/std/*/std/index.html#modules"><cide>std::*</code> modules</a></li>\n<li><a href="https://docs.rs/std/*/std/index.html#primitives">Primitive types</a></li>\n<li><a href="https://docs.rs/std/*/std/index.html#macros">Standard macros</a></li>\n<li><a href="https://docs.rs/std/*/std/prelude/index.html">The Rust Prelude</a></li>\n</ul>\n<p>If this is your first time, the documentation for the standard library is\nwritten to be casually perused. Clicking on interesting things should\ngenerally lead you to interesting places. Still, there are important bits\nyou don#$%t want to miss, so read on for a tour of the standard library and\nits documentation!</p>\n<p>Once you are familiar with the contents of the standard library you may\nbegin to find the verbosity of the prose distracting. At this stage in your\ndevelopment you may want to press the <cide>[-]</code> button near the top of the\npage to collapse it into a more skimmable view.</p>\n<p>While you are looking at that <cide>[-]</code> button also notice the <cide>[src]</code>\nbutton. Rust#$%s API documentation comes with the source code and you are\nencouraged to read it. The standard library source is generally high\nquality and a peek behind the curtains is often enlightening.</p>\n<h1 id="what-is-in-the-standard-library-documentation"><a class="header" href="#what-is-in-the-standard-library-documentation">What is in the standard library documentation?</a></h1>\n<p>First of all, The Rust Standard Library is divided into a number of focused\nmodules, <a href="https://docs.rs/std/*/std/index.html#modules">all listed further down this page</a>. These modules are\nthe bedrock upon which all of Rust is forged, and they have mighty names\nlike <a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>std::slice</code></a> and <a href="https://docs.rs/core/*/core/cmp/index.html"><cide>std::cmp</code></a>. Modules#$% documentation typically\nincludes an overview of the module along with examples, and are a smart\nplace to start familiarizing yourself with the library.</p>\n<p>Second, implicit methods on <a href="https://docs.rs/std/*/book/ch03-02-data-types.html">primitive types</a> are documented here. This can\nbe a source of confusion for two reasons:</p>\n<ol>\n<li>While primitives are implemented by the compiler, the standard library\nimplements methods directly on the primitive types (and it is the only\nlibrary that does so), which are <a href="https://docs.rs/std/*/std/index.html#primitives">documented in the section on\nprimitives</a>.</li>\n<li>The standard library exports many modules <em>with the same name as\nprimitive types</em>. These define additional items related to the primitive\ntype, but not the all-important methods.</li>\n</ol>\n<p>So for example there is a <a href="primitive::i32">page for the primitive type\n<cide>i32</code></a> that lists all the methods that can be called on\n32-bit integers (very useful), and there is a <a href="https://docs.rs/core/*/core/i32/index.html">page for the module\n<cide>std::i32</code></a> that documents the constant values <a href="https://docs.rs/core/*/core/i32/const.MIN.html"><cide>MIN</code></a> and <a href="https://docs.rs/core/*/core/i32/const.MAX.html"><cide>MAX</code></a> (rarely\nuseful).</p>\n<p>Note the documentation for the primitives <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a> and <a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>[T]</code></a> (also\ncalled #$%slice#$%). Many method calls on <a href="https://docs.rs/alloc/*/alloc/string/struct.String.html"><cide>String</code></a> and <a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a> are actually\ncalls to methods on <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a> and <a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>[T]</code></a> respectively, via <a href="https://docs.rs/std/*/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods">deref\ncoercions</a>.</p>\n<p>Third, the standard library defines <a href="https://docs.rs/std/*/std/prelude/index.html">The Rust Prelude</a>, a small collection\nof items - mostly traits - that are imported into every module of every\ncrate. The traits in the prelude are pervasive, making the prelude\ndocumentation a good entry point to learning about the library.</p>\n<p>And finally, the standard library exports a number of standard macros, and\n<a href="https://docs.rs/std/*/std/index.html#macros">lists them on this page</a> (technically, not all of the standard\nmacros are defined by the standard library - some are defined by the\ncompiler - but they are documented here the same). Like the prelude, the\nstandard macros are imported by default into all crates.</p>\n<h1 id="contributing-changes-to-the-documentation"><a class="header" href="#contributing-changes-to-the-documentation">Contributing changes to the documentation</a></h1>\n<p>Check out the rust contribution guidelines <a href="https://rustc-dev-guide.rust-lang.org/contributing.html#writing-documentation">here</a>.\nThe source for this documentation can be found on\n<a href="https://github.com/rust-lang/rust">GitHub</a>.\nTo contribute changes, make sure you read the guidelines first, then submit\npull-requests for your suggested changes.</p>\n<p>Contributions are appreciated! If you see a part of the docs that can be\nimproved, submit a PR, or chat with us first on <a href="https://discord.gg/rust-lang">Discord</a>\n#docs.</p>\n<h1 id="a-tour-of-the-rust-standard-library"><a class="header" href="#a-tour-of-the-rust-standard-library">A Tour of The Rust Standard Library</a></h1>\n<p>The rest of this crate documentation is dedicated to pointing out notable\nfeatures of The Rust Standard Library.</p>\n<h2 id="containers-and-collections"><a class="header" href="#containers-and-collections">Containers and collections</a></h2>\n<p>The <a href="https://docs.rs/core/*/core/option/index.html"><cide>option</code></a> and <a href="https://docs.rs/core/*/core/result/index.html"><cide>result</code></a> modules define optional and error-handling\ntypes, <a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>Option&lt;T&gt;</code></a> and <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Result&lt;T, E&gt;</code></a>. The <a href="https://docs.rs/core/*/core/iter/index.html"><cide>iter</code></a> module defines\nRust#$%s iterator trait, <a href="https://docs.rs/core/*/core/iter/traits/iterator/trait.Iterator.html"><cide>Iterator</code></a>, which works with the <a href="https://docs.rs/std/*/book/ch03-05-control-flow.html#looping-through-a-collection-with-for"><cide>for</code></a> loop to\naccess collections.</p>\n<p>The standard library exposes three common ways to deal with contiguous\nregions of memory:</p>\n<ul>\n<li><a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a> - A heap-allocated <em>vector</em> that is resizable at runtime.</li>\n<li><a href="https://docs.rs/core/*/core/array/index.html"><cide>[T; N]</code></a> - An inline <em>array</em> with a fixed size at compile time.</li>\n<li><a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>[T]</code></a> - A dynamically sized <em>slice</em> into any other kind of contiguous\nstorage, whether heap-allocated or not.</li>\n</ul>\n<p>Slices can only be handled through some kind of <em>pointer</em>, and as such come\nin many flavors such as:</p>\n<ul>\n<li><cide>&amp;[T]</code> - <em>shared slice</em></li>\n<li><cide>&amp;mut [T]</code> - <em>mutable slice</em></li>\n<li><a href="https://docs.rs/alloc/*/alloc/boxed/index.html"><cide>Box&lt;[T]&gt;</code></a> - <em>owned slice</em></li>\n</ul>\n<p><a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>, a UTF-8 string slice, is a primitive type, and the standard library\ndefines many methods for it. Rust <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>s are typically accessed as\nimmutable references: <cide>&amp;str</code>. Use the owned <a href="https://docs.rs/alloc/*/alloc/string/struct.String.html"><cide>String</code></a> for building and\nmutating strings.</p>\n<p>For converting to strings use the <a href="https://docs.rs/alloc/*/alloc/macro.format.html"><cide>format</code></a> macro, and for converting from\nstrings use the <a href="https://docs.rs/core/*/core/str/traits/trait.FromStr.html"><cide>FromStr</code></a> trait.</p>\n<p>Data may be shared by placing it in a reference-counted box or the <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a>\ntype, and if further contained in a <a href="https://docs.rs/core/*/core/cell/struct.Cell.html"><cide>Cell</code></a> or <a href="https://docs.rs/core/*/core/cell/struct.RefCell.html"><cide>RefCell</code></a>, may be mutated\nas well as shared. Likewise, in a concurrent setting it is common to pair an\natomically-reference-counted box, <a href="https://docs.rs/alloc/*/alloc/sync/struct.Arc.html"><cide>Arc</code></a>, with a <a href="https://docs.rs/std/*/std/sync/mutex/struct.Mutex.html"><cide>Mutex</code></a> to get the same\neffect.</p>\n<p>The <a href="https://docs.rs/std/*/std/collections/index.html"><cide>collections</code></a> module defines maps, sets, linked lists and other\ntypical collection types, including the common <a href="https://docs.rs/std/*/std/collections/hash/map/struct.HashMap.html"><cide>HashMap&lt;K, V&gt;</code></a>.</p>\n<h2 id="platform-abstractions-and-io"><a class="header" href="#platform-abstractions-and-io">Platform abstractions and I/O</a></h2>\n<p>Besides basic data types, the standard library is largely concerned with\nabstracting over differences in common platforms, most notably Windows and\nUnix derivatives.</p>\n<p>Common types of I/O, including <a href="https://docs.rs/std/*/std/fs/struct.File.html">files</a>, <a href="https://docs.rs/std/*/std/net/tcp/struct.TcpStream.html">TCP</a>, <a href="https://docs.rs/std/*/std/net/udp/struct.UdpSocket.html">UDP</a>, are defined in the\n<a href="https://docs.rs/std/*/std/io/index.html"><cide>io</code></a>, <a href="https://docs.rs/std/*/std/fs/index.html"><cide>fs</code></a>, and <a href="https://docs.rs/std/*/std/net/index.html"><cide>net</code></a> modules.</p>\n<p>The <a href="https://docs.rs/std/*/std/thread/index.html"><cide>thread</code></a> module contains Rust#$%s threading abstractions. <a href="https://docs.rs/std/*/std/sync/index.html"><cide>sync</code></a>\ncontains further primitive shared memory types, including <a href="https://docs.rs/core/*/core/sync/atomic/index.html"><cide>atomic</code></a> and\n<a href="https://docs.rs/std/*/std/sync/mpsc/index.html"><cide>mpsc</code></a>, which contains the channel types for message passing.</p>\n','<per><cide class="language-rust">std\n</code></pre>\n<per><cide class="language-rust">mod sync\n</code></pre>\n<hr />\n<p>Useful synchronization primitives.</p>\n<h2 id="the-need-for-synchronization"><a class="header" href="#the-need-for-synchronization">The need for synchronization</a></h2>\n<p>Conceptually, a Rust program is a series of operations which will\nbe executed on a computer. The timeline of events happening in the\nprogram is consistent with the order of the operations in the code.</p>\n<p>Consider the following code, operating on some global static variables:</p>\n<per><cide class="language-rust">static mut A: u32 = 0;\nstatic mut B: u32 = 0;\nstatic mut C: u32 = 0;\n\nfn main() {\n    unsafe {\n        A = 3;\n        B = 4;\n        A = A + B;\n        C = B;\n        println!(&quot;{} {} {}&quot;, A, B, C);\n        C = A;\n    }\n}\n</code></pre>\n<p>It appears as if some variables stored in memory are changed, an addition\nis performed, result is stored in <cide>A</code> and the variable <cide>C</code> is\nmodified twice.</p>\n<p>When only a single thread is involved, the results are as expected:\nthe line <cide>7 4 4</code> gets printed.</p>\n<p>As for what happens behind the scenes, when optimizations are enabled the\nfinal generated machine code might look very different from the code:</p>\n<ul>\n<li>\n<p>The first store to <cide>C</code> might be moved before the store to <cide>A</code> or <cide>B</code>,\n<em>as if</em> we had written <cide>C = 4; A = 3; B = 4</code>.</p>\n</li>\n<li>\n<p>Assignment of <cide>A + B</code> to <cide>A</code> might be removed, since the sum can be stored\nin a temporary location until it gets printed, with the global variable\nnever getting updated.</p>\n</li>\n<li>\n<p>The final result could be determined just by looking at the code\nat compile time, so <a href="https://en.wikipedia.org/wiki/Constant_folding">constant folding</a> might turn the whole\nblock into a simple <cide>println!(&quot;7 4 4&quot;)</code>.</p>\n</li>\n</ul>\n<p>The compiler is allowed to perform any combination of these\noptimizations, as long as the final optimized code, when executed,\nproduces the same results as the one without optimizations.</p>\n<p>Due to the <a href="https://en.wikipedia.org/wiki/Concurrency_(computer_science)">concurrency</a> involved in modern computers, assumptions\nabout the program#$%s execution order are often wrong. Access to\nglobal variables can lead to nondeterministic results, <strong>even if</strong>\ncompiler optimizations are disabled, and it is <strong>still possible</strong>\nto introduce synchronization bugs.</p>\n<p>Note that thanks to Rust#$%s safety guarantees, accessing global (static)\nvariables requires <cide>unsafe</code> code, assuming we don#$%t use any of the\nsynchronization primitives in this module.</p>\n<h2 id="out-of-order-execution"><a class="header" href="#out-of-order-execution">Out-of-order execution</a></h2>\n<p>Instructions can execute in a different order from the one we define, due to\nvarious reasons:</p>\n<ul>\n<li>\n<p>The <strong>compiler</strong> reordering instructions: If the compiler can issue an\ninstruction at an earlier point, it will try to do so. For example, it\nmight hoist memory loads at the top of a code block, so that the CPU can\nstart <a href="https://en.wikipedia.org/wiki/Cache_prefetching">prefetching</a> the values from memory.</p>\n<p>In single-threaded scenarios, this can cause issues when writing\nsignal handlers or certain kinds of low-level code.\nUse <a href="https://docs.rs/core/*/core/sync/atomic/fn.compiler_fence.html">compiler fences</a> to prevent this reordering.</p>\n</li>\n<li>\n<p>A <strong>single processor</strong> executing instructions <a href="https://en.wikipedia.org/wiki/Out-of-order_execution">out-of-order</a>:\nModern CPUs are capable of <a href="https://en.wikipedia.org/wiki/Superscalar_processor">superscalar</a> execution,\ni.e., multiple instructions might be executing at the same time,\neven though the machine code describes a sequential process.</p>\n<p>This kind of reordering is handled transparently by the CPU.</p>\n</li>\n<li>\n<p>A <strong>multiprocessor</strong> system executing multiple hardware threads\nat the same time: In multi-threaded scenarios, you can use two\nkinds of primitives to deal with synchronization:</p>\n<ul>\n<li><a href="https://docs.rs/core/*/core/sync/atomic/fn.fence.html">memory fences</a> to ensure memory accesses are made visible to\nother CPUs in the right order.</li>\n<li><a href="https://docs.rs/core/*/core/sync/atomic/index.html">atomic operations</a> to ensure simultaneous access to the same\nmemory location doesn#$%t lead to undefined behavior.</li>\n</ul>\n</li>\n</ul>\n<h2 id="higher-level-synchronization-objects"><a class="header" href="#higher-level-synchronization-objects">Higher-level synchronization objects</a></h2>\n<p>Most of the low-level synchronization primitives are quite error-prone and\ninconvenient to use, which is why the standard library also exposes some\nhigher-level synchronization objects.</p>\n<p>These abstractions can be built out of lower-level primitives.\nFor efficiency, the sync objects in the standard library are usually\nimplemented with help from the operating system#$%s kernel, which is\nable to reschedule the threads while they are blocked on acquiring\na lock.</p>\n<p>The following is an overview of the available synchronization\nobjects:</p>\n<ul>\n<li>\n<p><a href="https://docs.rs/alloc/*/alloc/sync/struct.Arc.html"><cide>Arc</code></a>: Atomically Reference-Counted pointer, which can be used\nin multithreaded environments to prolong the lifetime of some\ndata until all the threads have finished using it.</p>\n</li>\n<li>\n<p><a href="https://docs.rs/std/*/std/sync/barrier/struct.Barrier.html"><cide>Barrier</code></a>: Ensures multiple threads will wait for each other\nto reach a point in the program, before continuing execution all\ntogether.</p>\n</li>\n<li>\n<p><a href="https://docs.rs/std/*/std/sync/condvar/struct.Condvar.html"><cide>Condvar</code></a>: Condition Variable, providing the ability to block\na thread while waiting for an event to occur.</p>\n</li>\n<li>\n<p><a href="https://docs.rs/std/*/std/sync/mpsc/index.html"><cide>mpsc</code></a>: Multi-producer, single-consumer queues, used for\nmessage-based communication. Can provide a lightweight\ninter-thread synchronisation mechanism, at the cost of some\nextra memory.</p>\n</li>\n<li>\n<p><a href="https://docs.rs/std/*/std/sync/mutex/struct.Mutex.html"><cide>Mutex</code></a>: Mutual Exclusion mechanism, which ensures that at\nmost one thread at a time is able to access some data.</p>\n</li>\n<li>\n<p><a href="https://docs.rs/std/*/std/sync/once/struct.Once.html"><cide>Once</code></a>: Used for thread-safe, one-time initialization of a\nglobal variable.</p>\n</li>\n<li>\n<p><a href="https://docs.rs/std/*/std/sync/rwlock/struct.RwLock.html"><cide>RwLock</code></a>: Provides a mutual exclusion mechanism which allows\nmultiple readers at the same time, while allowing only one\nwriter at a time. In some cases, this can be more efficient than\na mutex.</p>\n</li>\n</ul>\n','<per><cide class="language-rust">std::sync::mutex\n</code></pre>\n<per><cide class="language-rust">pub struct Mutex&lt;T&gt;\nwhere\n    T: ?Sized,\n</code></pre>\n<hr />\n<p>A mutual exclusion primitive useful for protecting shared data</p>\n<p>This mutex will block threads waiting for the lock to become available. The\nmutex can also be statically initialized or created via a <a href="Self::new"><cide>new</code></a>\nconstructor. Each mutex has a type parameter which represents the data that\nit is protecting. The data can only be accessed through the RAII guards\nreturned from <a href="Self::lock"><cide>lock</code></a> and <a href="Self::try_lock"><cide>try_lock</code></a>, which guarantees that the data is only\never accessed when the mutex is locked.</p>\n<h1 id="poisoning"><a class="header" href="#poisoning">Poisoning</a></h1>\n<p>The mutexes in this module implement a strategy called &quot;poisoning&quot; where a\nmutex is considered poisoned whenever a thread panics while holding the\nmutex. Once a mutex is poisoned, all other threads are unable to access the\ndata by default as it is likely tainted (some invariant is not being\nupheld).</p>\n<p>For a mutex, this means that the <a href="Self::lock"><cide>lock</code></a> and <a href="Self::try_lock"><cide>try_lock</code></a> methods return a\n<a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Result</code></a> which indicates whether a mutex has been poisoned or not. Most\nusage of a mutex will simply <a href="Result::unwrap"><cide>unwrap()</code></a> these results, propagating panics\namong threads to ensure that a possibly invalid invariant is not witnessed.</p>\n<p>A poisoned mutex, however, does not prevent all access to the underlying\ndata. The <a href="https://docs.rs/std/*/std/sync/poison/struct.PoisonError.html"><cide>PoisonError</code></a> type has an <a href="super::PoisonError::into_inner"><cide>into_inner</code></a> method which will return\nthe guard that would have otherwise been returned on a successful lock. This\nallows access to the data, despite the lock being poisoned.</p>\n<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>\n<per><cide>use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::sync::mpsc::channel;\n\nconst N: usize = 10;\n\n// Spawn a few threads to increment a shared variable (non-atomically), and\n// let the main thread know once all increments are done.\n//\n// Here we#$%re using an Arc to share memory among threads, and the data inside\n// the Arc is protected with a mutex.\nlet data = Arc::new(Mutex::new(0));\n\nlet (tx, rx) = channel();\nfor _ in 0..N {\n    let (data, tx) = (Arc::clone(&amp;data), tx.clone());\n    thread::spawn(move || {\n        // The shared state can only be accessed once the lock is held.\n        // Our non-atomic increment is safe because we#$%re the only thread\n        // which can access the shared state when the lock is held.\n        //\n        // We unwrap() the return value to assert that we are not expecting\n        // threads to ever fail while holding the lock.\n        let mut data = data.lock().unwrap();\n        *data += 1;\n        if *data == N {\n            tx.send(()).unwrap();\n        }\n        // the lock is unlocked here when `data` goes out of scope.\n    });\n}\n\nrx.recv().unwrap();\n</code></pre>\n<p>To recover from a poisoned mutex:</p>\n<per><cide>use std::sync::{Arc, Mutex};\nuse std::thread;\n\nlet lock = Arc::new(Mutex::new(0_u32));\nlet lock2 = Arc::clone(&amp;lock);\n\nlet _ = thread::spawn(move || -&gt; () {\n    // This thread will acquire the mutex first, unwrapping the result of\n    // `lock` because the lock has not been poisoned.\n    let _guard = lock2.lock().unwrap();\n\n    // This panic while holding the lock (`_guard` is in scope) will poison\n    // the mutex.\n    panic!();\n}).join();\n\n// The lock is poisoned by this point, but the returned result can be\n// pattern matched on to return the underlying guard on both branches.\nlet mut guard = match lock.lock() {\n    Ok(guard) =&gt; guard,\n    Err(poisoned) =&gt; poisoned.into_inner(),\n};\n\n*guard += 1;\n</code></pre>\n<p>It is sometimes necessary to manually drop the mutex guard to unlock it\nsooner than the end of the enclosing scope.</p>\n<per><cide>use std::sync::{Arc, Mutex};\nuse std::thread;\n\nconst N: usize = 3;\n\nlet data_mutex = Arc::new(Mutex::new(vec![1, 2, 3, 4]));\nlet res_mutex = Arc::new(Mutex::new(0));\n\nlet mut threads = Vec::with_capacity(N);\n(0..N).for_each(|_| {\n    let data_mutex_clone = Arc::clone(&amp;data_mutex);\n    let res_mutex_clone = Arc::clone(&amp;res_mutex);\n\n    threads.push(thread::spawn(move || {\n        let mut data = data_mutex_clone.lock().unwrap();\n        // This is the result of some important and long-ish work.\n        let result = data.iter().fold(0, |acc, x| acc + x * 2);\n        data.push(result);\n        drop(data);\n        *res_mutex_clone.lock().unwrap() += result;\n    }));\n});\n\nlet mut data = data_mutex.lock().unwrap();\n// This is the result of some important and long-ish work.\nlet result = data.iter().fold(0, |acc, x| acc + x * 2);\ndata.push(result);\n// We drop the `data` explicitly because it#$%s not necessary anymore and the\n// thread still has work to do. This allow other threads to start working on\n// the data immediately, without waiting for the rest of the unrelated work\n// to be done here.\n//\n// It#$%s even more important here than in the threads because we `.join` the\n// threads after that. If we had not dropped the mutex guard, a thread could\n// be waiting forever for it, causing a deadlock.\ndrop(data);\n// Here the mutex guard is not assigned to a variable and so, even if the\n// scope does not end after this line, the mutex is still released: there is\n// no deadlock.\n*res_mutex.lock().unwrap() += result;\n\nthreads.into_iter().for_each(|thread| {\n    thread\n        .join()\n        .expect(&quot;The thread creating or execution failed !&quot;)\n});\n\nassert_eq!(*res_mutex.lock().unwrap(), 800);\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn main()\n</code></pre>\n','<per><cide class="language-rust">let m: Mutex&lt;i32&gt;\n</code></pre>\n','<per><cide class="language-rust">std::sync::mutex::Mutex\n</code></pre>\n<per><cide class="language-rust">pub fn new(t: T) -&gt; Mutex&lt;T&gt;\n</code></pre>\n<hr />\n<p>Creates a new mutex in an unlocked state ready for use.</p>\n<h1 id="examples-1"><a class="header" href="#examples-1">Examples</a></h1>\n<per><cide>use std::sync::Mutex;\n\nlet mutex = Mutex::new(0);\n</code></pre>\n','<per><cide class="language-rust">let mut num: MutexGuard&lt;i32&gt;\n</code></pre>\n','<per><cide class="language-rust">std::sync::mutex::Mutex\n</code></pre>\n<per><cide class="language-rust">pub fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;#$%_, T&gt;&gt;\n</code></pre>\n<hr />\n<p>Acquires a mutex, blocking the current thread until it is able to do so.</p>\n<p>This function will block the local thread until it is available to acquire\nthe mutex. Upon returning, the thread is the only thread with the lock\nheld. An RAII guard is returned to allow scoped unlock of the lock. When\nthe guard goes out of scope, the mutex will be unlocked.</p>\n<p>The exact behavior on locking a mutex in the thread which already holds\nthe lock is left unspecified. However, this function will not return on\nthe second call (it might panic or deadlock, for example).</p>\n<h1 id="errors"><a class="header" href="#errors">Errors</a></h1>\n<p>If another user of this mutex panicked while holding the mutex, then\nthis call will return an error once the mutex is acquired.</p>\n<h1 id="panics"><a class="header" href="#panics">Panics</a></h1>\n<p>This function might panic when called if the lock is already held by\nthe current thread.</p>\n<h1 id="examples-2"><a class="header" href="#examples-2">Examples</a></h1>\n<per><cide>use std::sync::{Arc, Mutex};\nuse std::thread;\n\nlet mutex = Arc::new(Mutex::new(0));\nlet c_mutex = Arc::clone(&amp;mutex);\n\nthread::spawn(move || {\n    *c_mutex.lock().unwrap() = 10;\n}).join().expect(&quot;thread::spawn failed&quot;);\nassert_eq!(*mutex.lock().unwrap(), 10);\n</code></pre>\n','<per><cide class="language-rust">core::result::Result\n</code></pre>\n<per><cide class="language-rust">pub fn unwrap(self) -&gt; T\n</code></pre>\n<hr />\n<p>Returns the contained <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Ok</code></a> value, consuming the <cide>self</code> value.</p>\n<p>Because this function may panic, its use is generally discouraged.\nInstead, prefer to use pattern matching and handle the <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Err</code></a>\ncase explicitly, or call <a href="Result::unwrap_or"><cide>unwrap_or</code></a>, <a href="Result::unwrap_or_else"><cide>unwrap_or_else</code></a>, or\n<a href="Result::unwrap_or_default"><cide>unwrap_or_default</code></a>.</p>\n<h1 id="panics-1"><a class="header" href="#panics-1">Panics</a></h1>\n<p>Panics if the value is an <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Err</code></a>, with a panic message provided by the\n<a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Err</code></a>#$%s value.</p>\n<h1 id="examples-3"><a class="header" href="#examples-3">Examples</a></h1>\n<p>Basic usage:</p>\n<per><cide>let x: Result&lt;u32, &amp;str&gt; = Ok(2);\nassert_eq!(x.unwrap(), 2);\n</code></pre>\n<per><cide class="language-should_panic">let x: Result&lt;u32, &amp;str&gt; = Err(&quot;emergency failure&quot;);\nx.unwrap(); // panics with `emergency failure`\n</code></pre>\n','<per><cide class="language-rust">std\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! println\n</code></pre>\n<hr />\n<p>Prints to the standard output, with a newline.</p>\n<p>On all platforms, the newline is the LINE FEED character (<cide>\n</code>/<cide>U+000A</code>) alone\n(no additional CARRIAGE RETURN (<cide>\r</code>/<cide>U+000D</code>)).</p>\n<p>Use the <a href="%60format!%60"><cide>format!</code></a> syntax to write data to the standard output.\nSee <a href="crate::fmt"><cide>std::fmt</code></a> for more information.</p>\n<p>Use <cide>println!</code> only for the primary output of your program. Use\n<a href="%60eprintln!%60"><cide>eprintln!</code></a> instead to print error and progress messages.</p>\n<h1 id="panics-2"><a class="header" href="#panics-2">Panics</a></h1>\n<p>Panics if writing to <a href="crate::io::stdout"><cide>io::stdout</code></a> fails.</p>\n<h1 id="examples-4"><a class="header" href="#examples-4">Examples</a></h1>\n<per><cide>println!(); // prints just a newline\nprintln!(&quot;hello there!&quot;);\nprintln!(&quot;format {} arguments&quot;, &quot;some&quot;);\n</code></pre>\n','<per><cide class="language-rust">std\n</code></pre>\n<per><cide class="language-rust">mod thread\n</code></pre>\n<hr />\n<p>Native threads.</p>\n<h2 id="the-threading-model"><a class="header" href="#the-threading-model">The threading model</a></h2>\n<p>An executing Rust program consists of a collection of native OS threads,\neach with their own stack and local state. Threads can be named, and\nprovide some built-in support for low-level synchronization.</p>\n<p>Communication between threads can be done through\n<a href="https://docs.rs/std/*/std/sync/mpsc/index.html">channels</a>, Rust#$%s message-passing types, along with <a href="https://docs.rs/std/*/std/sync/index.html">other forms of thread\nsynchronization</a> and shared-memory data\nstructures. In particular, types that are guaranteed to be\nthreadsafe are easily shared between threads using the\natomically-reference-counted container, <a href="https://docs.rs/alloc/*/alloc/sync/struct.Arc.html"><cide>Arc</code></a>.</p>\n<p>Fatal logic errors in Rust cause <em>thread panic</em>, during which\na thread will unwind the stack, running destructors and freeing\nowned resources. While not meant as a #$%try/catch#$% mechanism, panics\nin Rust can nonetheless be caught (unless compiling with <cide>panic=abort</code>) with\n<a href="https://docs.rs/std/*/std/panic/fn.catch_unwind.html"><cide>catch_unwind</code></a> and recovered\nfrom, or alternatively be resumed with\n<a href="https://docs.rs/std/*/std/panic/fn.resume_unwind.html"><cide>resume_unwind</code></a>. If the panic\nis not caught the thread will exit, but the panic may optionally be\ndetected from a different thread with <a href="JoinHandle::join"><cide>join</code></a>. If the main thread panics\nwithout the panic being caught, the application will exit with a\nnon-zero exit code.</p>\n<p>When the main thread of a Rust program terminates, the entire program shuts\ndown, even if other threads are still running. However, this module provides\nconvenient facilities for automatically waiting for the termination of a\nchild thread (i.e., join).</p>\n<h2 id="spawning-a-thread"><a class="header" href="#spawning-a-thread">Spawning a thread</a></h2>\n<p>A new thread can be spawned using the <a href="https://docs.rs/std/*/std/thread/fn.spawn.html"><cide>thread::spawn</code></a> function:</p>\n<per><cide class="language-rust">use std::thread;\n\nthread::spawn(move || {\n    // some work here\n});\n</code></pre>\n<p>In this example, the spawned thread is &quot;detached&quot; from the current\nthread. This means that it can outlive its parent (the thread that spawned\nit), unless this parent is the main thread.</p>\n<p>The parent thread can also wait on the completion of the child\nthread; a call to <a href="https://docs.rs/std/*/std/thread/fn.spawn.html"><cide>spawn</code></a> produces a <a href="https://docs.rs/std/*/std/thread/struct.JoinHandle.html"><cide>JoinHandle</code></a>, which provides\na <cide>join</code> method for waiting:</p>\n<per><cide class="language-rust">use std::thread;\n\nlet child = thread::spawn(move || {\n    // some work here\n});\n// some work here\nlet res = child.join();\n</code></pre>\n<p>The <a href="JoinHandle::join"><cide>join</code></a> method returns a <a href="https://docs.rs/std/*/std/thread/type.Result.html"><cide>thread::Result</code></a> containing <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Ok</code></a> of the final\nvalue produced by the child thread, or <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Err</code></a> of the value given to\na call to <a href="https://docs.rs/core/*/core/macro.panic.html"><cide>panic</code></a> if the child panicked.</p>\n<h2 id="configuring-threads"><a class="header" href="#configuring-threads">Configuring threads</a></h2>\n<p>A new thread can be configured before it is spawned via the <a href="https://docs.rs/std/*/std/thread/struct.Builder.html"><cide>Builder</code></a> type,\nwhich currently allows you to set the name and stack size for the child thread:</p>\n<per><cide class="language-rust"># #![allow(unused_must_use)]\nuse std::thread;\n\nthread::Builder::new().name(&quot;child1&quot;.to_string()).spawn(move || {\n    println!(&quot;Hello, world!&quot;);\n});\n</code></pre>\n<h2 id="the-cidethread-type"><a class="header" href="#the-cidethread-type">The <cide>Thread</code> type</a></h2>\n<p>Threads are represented via the <a href="https://docs.rs/std/*/std/thread/struct.Thread.html"><cide>Thread</code></a> type, which you can get in one of\ntwo ways:</p>\n<ul>\n<li>By spawning a new thread, e.g., using the <a href="https://docs.rs/std/*/std/thread/fn.spawn.html"><cide>thread::spawn</code></a>\nfunction, and calling <a href="%60JoinHandle::thread%60"><cide>thread</code></a> on the <a href="https://docs.rs/std/*/std/thread/struct.JoinHandle.html"><cide>JoinHandle</code></a>.</li>\n<li>By requesting the current thread, using the <a href="https://docs.rs/std/*/std/thread/fn.current.html"><cide>thread::current</code></a> function.</li>\n</ul>\n<p>The <a href="https://docs.rs/std/*/std/thread/fn.current.html"><cide>thread::current</code></a> function is available even for threads not spawned\nby the APIs of this module.</p>\n<h2 id="thread-local-storage"><a class="header" href="#thread-local-storage">Thread-local storage</a></h2>\n<p>This module also provides an implementation of thread-local storage for Rust\nprograms. Thread-local storage is a method of storing data into a global\nvariable that each thread in the program will have its own copy of.\nThreads do not share this data, so accesses do not need to be synchronized.</p>\n<p>A thread-local key owns the value it contains and will destroy the value when the\nthread exits. It is created with the <a href="https://docs.rs/std/*/std/macro.thread_local.html"><cide>thread_local</code></a> macro and can contain any\nvalue that is <cide>#$%static</code> (no borrowed pointers). It provides an accessor function,\n<a href="LocalKey::with"><cide>with</code></a>, that yields a shared reference to the value to the specified\nclosure. Thread-local keys allow only shared access to values, as there would be no\nway to guarantee uniqueness if mutable borrows were allowed. Most values\nwill want to make use of some form of <strong>interior mutability</strong> through the\n<a href="https://docs.rs/core/*/core/cell/struct.Cell.html"><cide>Cell</code></a> or <a href="https://docs.rs/core/*/core/cell/struct.RefCell.html"><cide>RefCell</code></a> types.</p>\n<h2 id="naming-threads"><a class="header" href="#naming-threads">Naming threads</a></h2>\n<p>Threads are able to have associated names for identification purposes. By default, spawned\nthreads are unnamed. To specify a name for a thread, build the thread with <a href="https://docs.rs/std/*/std/thread/struct.Builder.html"><cide>Builder</code></a> and pass\nthe desired thread name to <a href="%60Builder::name%60"><cide>Builder::name</code></a>. To retrieve the thread name from within the\nthread, use <a href="%60Thread::name%60"><cide>Thread::name</code></a>. A couple examples of where the name of a thread gets used:</p>\n<ul>\n<li>If a panic occurs in a named thread, the thread name will be printed in the panic message.</li>\n<li>The thread name is provided to the OS where applicable (e.g., <cide>pthread_setname_np</code> in\nunix-like platforms).</li>\n</ul>\n<h2 id="stack-size"><a class="header" href="#stack-size">Stack size</a></h2>\n<p>The default stack size for spawned threads is 2 MiB, though this particular stack size is\nsubject to change in the future. There are two ways to manually specify the stack size for\nspawned threads:</p>\n<ul>\n<li>Build the thread with <a href="https://docs.rs/std/*/std/thread/struct.Builder.html"><cide>Builder</code></a> and pass the desired stack size to <a href="%60Builder::stack_size%60"><cide>Builder::stack_size</code></a>.</li>\n<li>Set the <cide>RUST_MIN_STACK</code> environment variable to an integer representing the desired stack\nsize (in bytes). Note that setting <a href="%60Builder::stack_size%60"><cide>Builder::stack_size</code></a> will override this.</li>\n</ul>\n<p>Note that the stack size of the main thread is <em>not</em> determined by Rust.</p>\n','<per><cide class="language-rust">let counter: Mutex&lt;i32&gt;\n</code></pre>\n','<per><cide class="language-rust">let mut handles: Vec&lt;JoinHandle&lt;()&gt;, Global&gt;\n</code></pre>\n','<per><cide class="language-rust">alloc\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! vec\n</code></pre>\n<hr />\n<p>Creates a <a href="crate::vec::Vec"><cide>Vec</code></a> containing the arguments.</p>\n<p><cide>vec!</code> allows <cide>Vec</code>s to be defined with the same syntax as array expressions.\nThere are two forms of this macro:</p>\n<ul>\n<li>Create a <a href="crate::vec::Vec"><cide>Vec</code></a> containing a given list of elements:</li>\n</ul>\n<per><cide>let v = vec![1, 2, 3];\nassert_eq!(v[0], 1);\nassert_eq!(v[1], 2);\nassert_eq!(v[2], 3);\n</code></pre>\n<ul>\n<li>Create a <a href="crate::vec::Vec"><cide>Vec</code></a> from a given element and size:</li>\n</ul>\n<per><cide>let v = vec![1; 3];\nassert_eq!(v, [1, 1, 1]);\n</code></pre>\n<p>Note that unlike array expressions this syntax supports all elements\nwhich implement <a href="%60Clone%60"><cide>Clone</code></a> and the number of elements doesn#$%t have to be\na constant.</p>\n<p>This will use <cide>clone</code> to duplicate an expression, so one should be careful\nusing this with types having a nonstandard <cide>Clone</code> implementation. For\nexample, <cide>vec![Rc::new(1); 5]</code> will create a vector of five references\nto the same boxed integer value, not five references pointing to independently\nboxed integers.</p>\n<p>Also, note that <cide>vec![expr; 0]</code> is allowed, and produces an empty vector.\nThis will still evaluate <cide>expr</code>, however, and immediately drop the resulting value, so\nbe mindful of side effects.</p>\n','<per><cide class="language-rust">let handle: JoinHandle&lt;()&gt;\n</code></pre>\n','<per><cide class="language-rust">std::thread\n</code></pre>\n<per><cide class="language-rust">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;\nwhere\n    F: FnOnce&lt;(), Output = T&gt; + Send + #$%static,\n    T: Send + #$%static,\n</code></pre>\n<hr />\n<p>Spawns a new thread, returning a <a href="https://docs.rs/std/*/std/thread/struct.JoinHandle.html"><cide>JoinHandle</code></a> for it.</p>\n<p>The join handle will implicitly <em>detach</em> the child thread upon being\ndropped. In this case, the child thread may outlive the parent (unless\nthe parent thread is the main thread; the whole process is terminated when\nthe main thread finishes). Additionally, the join handle provides a <a href="JoinHandle::join"><cide>join</code></a>\nmethod that can be used to join the child thread. If the child thread\npanics, <a href="JoinHandle::join"><cide>join</code></a> will return an <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Err</code></a> containing the argument given to\n<a href="https://docs.rs/core/*/core/macro.panic.html"><cide>panic</code></a>.</p>\n<p>This will create a thread using default parameters of <a href="https://docs.rs/std/*/std/thread/struct.Builder.html"><cide>Builder</code></a>, if you\nwant to specify the stack size or the name of the thread, use this API\ninstead.</p>\n<p>As you can see in the signature of <cide>spawn</code> there are two constraints on\nboth the closure given to <cide>spawn</code> and its return value, let#$%s explain them:</p>\n<ul>\n<li>The <cide>#$%static</code> constraint means that the closure and its return value\nmust have a lifetime of the whole program execution. The reason for this\nis that threads can <cide>detach</code> and outlive the lifetime they have been\ncreated in.\nIndeed if the thread, and by extension its return value, can outlive their\ncaller, we need to make sure that they will be valid afterwards, and since\nwe <em>can#$%t</em> know when it will return we need to have them valid as long as\npossible, that is until the end of the program, hence the <cide>#$%static</code>\nlifetime.</li>\n<li>The <a href="https://docs.rs/core/*/core/marker/trait.Send.html"><cide>Send</code></a> constraint is because the closure will need to be passed\n<em>by value</em> from the thread where it is spawned to the new thread. Its\nreturn value will need to be passed from the new thread to the thread\nwhere it is <cide>join</code>ed.\nAs a reminder, the <a href="https://docs.rs/core/*/core/marker/trait.Send.html"><cide>Send</code></a> marker trait expresses that it is safe to be\npassed from thread to thread. <a href="https://docs.rs/core/*/core/marker/trait.Sync.html"><cide>Sync</code></a> expresses that it is safe to have a\nreference be passed from thread to thread.</li>\n</ul>\n<h1 id="panics-3"><a class="header" href="#panics-3">Panics</a></h1>\n<p>Panics if the OS fails to create a thread; use <a href="%60Builder::spawn%60"><cide>Builder::spawn</code></a>\nto recover from such errors.</p>\n<h1 id="examples-5"><a class="header" href="#examples-5">Examples</a></h1>\n<p>Creating a thread.</p>\n<per><cide>use std::thread;\n\nlet handler = thread::spawn(|| {\n    // thread code\n});\n\nhandler.join().unwrap();\n</code></pre>\n<p>As mentioned in the module documentation, threads are usually made to\ncommunicate using <a href="https://docs.rs/std/*/std/sync/mpsc/index.html"><cide>channels</code></a>, here is how it usually looks.</p>\n<p>This example also shows how to use <cide>move</code>, in order to give ownership\nof values to a thread.</p>\n<per><cide>use std::thread;\nuse std::sync::mpsc::channel;\n\nlet (tx, rx) = channel();\n\nlet sender = thread::spawn(move || {\n    tx.send(&quot;Hello, thread&quot;.to_owned())\n        .expect(&quot;Unable to send on channel&quot;);\n});\n\nlet receiver = thread::spawn(move || {\n    let value = rx.recv().expect(&quot;Unable to receive from channel&quot;);\n    println!(&quot;{}&quot;, value);\n});\n\nsender.join().expect(&quot;The sender thread has panicked&quot;);\nreceiver.join().expect(&quot;The receiver thread has panicked&quot;);\n</code></pre>\n<p>A thread can also return a value through its <a href="https://docs.rs/std/*/std/thread/struct.JoinHandle.html"><cide>JoinHandle</code></a>, you can use\nthis to make asynchronous computations (futures might be more appropriate\nthough).</p>\n<per><cide>use std::thread;\n\nlet computation = thread::spawn(|| {\n    // Some expensive computation.\n    42\n});\n\nlet result = computation.join().unwrap();\nprintln!(&quot;{}&quot;, result);\n</code></pre>\n','<per><cide class="language-rust">alloc::vec::Vec\n</code></pre>\n<per><cide class="language-rust">pub fn push(&amp;mut self, value: T)\n</code></pre>\n<hr />\n<p>Appends an element to the back of a collection.</p>\n<h1 id="panics-4"><a class="header" href="#panics-4">Panics</a></h1>\n<p>Panics if the new capacity exceeds <cide>isize::MAX</code> bytes.</p>\n<h1 id="examples-6"><a class="header" href="#examples-6">Examples</a></h1>\n<per><cide>let mut vec = vec![1, 2];\nvec.push(3);\nassert_eq!(vec, [1, 2, 3]);\n</code></pre>\n','<per><cide class="language-rust">handle: JoinHandle&lt;()&gt;\n</code></pre>\n','<per><cide class="language-rust">std::thread::JoinHandle\n</code></pre>\n<per><cide class="language-rust">pub fn join(self) -&gt; Result&lt;T&gt;\n</code></pre>\n<hr />\n<p>Waits for the associated thread to finish.</p>\n<p>In terms of <a href="https://docs.rs/core/*/core/sync/atomic/index.html">atomic memory orderings</a>,  the completion of the associated\nthread synchronizes with this function returning. In other words, all\noperations performed by that thread are ordered before all\noperations that happen after <cide>join</code> returns.</p>\n<p>If the child thread panics, <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Err</code></a> is returned with the parameter given\nto <a href="https://docs.rs/core/*/core/macro.panic.html"><cide>panic</code></a>.</p>\n<h1 id="panics-5"><a class="header" href="#panics-5">Panics</a></h1>\n<p>This function may panic on some platforms if a thread attempts to join\nitself or otherwise may create a deadlock with joining threads.</p>\n<h1 id="examples-7"><a class="header" href="#examples-7">Examples</a></h1>\n<per><cide>use std::thread;\n\nlet builder = thread::Builder::new();\n\nlet join_handle: thread::JoinHandle&lt;_&gt; = builder.spawn(|| {\n    // some work here\n}).unwrap();\njoin_handle.join().expect(&quot;Couldn#$%t join on the associated thread&quot;);\n</code></pre>\n','<per><cide class="language-rust">alloc\n</code></pre>\n<per><cide class="language-rust">mod rc\n</code></pre>\n<hr />\n<p>Single-threaded reference-counting pointers. #$%Rc#$% stands for #$%Reference\nCounted#$%.</p>\n<p>The type <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc&lt;T&gt;</code></a> provides shared ownership of a value of type <cide>T</code>,\nallocated in the heap. Invoking <a href="https://docs.rs/core/*/core/clone/trait.Clone.html#tymethod.clone"><cide>clone</code></a> on <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a> produces a new\npointer to the same allocation in the heap. When the last <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a> pointer to a\ngiven allocation is destroyed, the value stored in that allocation (often\nreferred to as &quot;inner value&quot;) is also dropped.</p>\n<p>Shared references in Rust disallow mutation by default, and <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a>\nis no exception: you cannot generally obtain a mutable reference to\nsomething inside an <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a>. If you need mutability, put a <a href="https://docs.rs/core/*/core/cell/struct.Cell.html"><cide>Cell</code></a>\nor <a href="https://docs.rs/core/*/core/cell/struct.RefCell.html"><cide>RefCell</code></a> inside the <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a>; see <a href="core::cell#introducing-mutability-inside-of-something-immutable">an example of mutability\ninside an <cide>Rc</code></a>.</p>\n<p><a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a> uses non-atomic reference counting. This means that overhead is very\nlow, but an <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a> cannot be sent between threads, and consequently <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a>\ndoes not implement <a href="https://docs.rs/core/*/core/marker/trait.Send.html"><cide>Send</code></a>. As a result, the Rust compiler\nwill check <em>at compile time</em> that you are not sending <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a>s between\nthreads. If you need multi-threaded, atomic reference counting, use\n<a href="https://docs.rs/alloc/*/alloc/sync/struct.Arc.html"><cide>sync::Arc</code></a>.</p>\n<p>The <a href="Rc::downgrade"><cide>downgrade</code></a> method can be used to create a non-owning\n<a href="https://docs.rs/alloc/*/alloc/rc/struct.Weak.html"><cide>Weak</code></a> pointer. A <a href="https://docs.rs/alloc/*/alloc/rc/struct.Weak.html"><cide>Weak</code></a> pointer can be <a href="Weak::upgrade"><cide>upgrade</code></a>d\nto an <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a>, but this will return <a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>None</code></a> if the value stored in the allocation has\nalready been dropped. In other words, <cide>Weak</code> pointers do not keep the value\ninside the allocation alive; however, they <em>do</em> keep the allocation\n(the backing store for the inner value) alive.</p>\n<p>A cycle between <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a> pointers will never be deallocated. For this reason,\n<a href="https://docs.rs/alloc/*/alloc/rc/struct.Weak.html"><cide>Weak</code></a> is used to break cycles. For example, a tree could have strong\n<a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a> pointers from parent nodes to children, and <a href="https://docs.rs/alloc/*/alloc/rc/struct.Weak.html"><cide>Weak</code></a> pointers from\nchildren back to their parents.</p>\n<p><cide>Rc&lt;T&gt;</code> automatically dereferences to <cide>T</code> (via the <a href="https://docs.rs/core/*/core/ops/deref/trait.Deref.html"><cide>Deref</code></a> trait),\nso you can call <cide>T</code>#$%s methods on a value of type <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc&lt;T&gt;</code></a>. To avoid name\nclashes with <cide>T</code>#$%s methods, the methods of <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc&lt;T&gt;</code></a> itself are associated\nfunctions, called using <a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">fully qualified syntax</a>:</p>\n<per><cide>use std::rc::Rc;\n\nlet my_rc = Rc::new(());\nRc::downgrade(&amp;my_rc);\n</code></pre>\n<p><cide>Rc&lt;T&gt;</code>#$%s implementations of traits like <cide>Clone</code> may also be called using\nfully qualified syntax. Some people prefer to use fully qualified syntax,\nwhile others prefer using method-call syntax.</p>\n<per><cide>use std::rc::Rc;\n\nlet rc = Rc::new(());\n// Method-call syntax\nlet rc2 = rc.clone();\n// Fully qualified syntax\nlet rc3 = Rc::clone(&amp;rc);\n</code></pre>\n<p><a href="https://docs.rs/alloc/*/alloc/rc/struct.Weak.html"><cide>Weak&lt;T&gt;</code></a> does not auto-dereference to <cide>T</code>, because the inner value may have\nalready been dropped.</p>\n<h1 id="cloning-references"><a class="header" href="#cloning-references">Cloning references</a></h1>\n<p>Creating a new reference to the same allocation as an existing reference counted pointer\nis done using the <cide>Clone</code> trait implemented for <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc&lt;T&gt;</code></a> and <a href="https://docs.rs/alloc/*/alloc/rc/struct.Weak.html"><cide>Weak&lt;T&gt;</code></a>.</p>\n<per><cide>use std::rc::Rc;\n\nlet foo = Rc::new(vec![1.0, 2.0, 3.0]);\n// The two syntaxes below are equivalent.\nlet a = foo.clone();\nlet b = Rc::clone(&amp;foo);\n// a and b both point to the same memory location as foo.\n</code></pre>\n<p>The <cide>Rc::clone(&amp;from)</code> syntax is the most idiomatic because it conveys more explicitly\nthe meaning of the code. In the example above, this syntax makes it easier to see that\nthis code is creating a new reference rather than copying the whole content of foo.</p>\n<h1 id="examples-8"><a class="header" href="#examples-8">Examples</a></h1>\n<p>Consider a scenario where a set of <cide>Gadget</code>s are owned by a given <cide>Owner</code>.\nWe want to have our <cide>Gadget</code>s point to their <cide>Owner</code>. We can#$%t do this with\nunique ownership, because more than one gadget may belong to the same\n<cide>Owner</code>. <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a> allows us to share an <cide>Owner</code> between multiple <cide>Gadget</code>s,\nand have the <cide>Owner</code> remain allocated as long as any <cide>Gadget</code> points at it.</p>\n<per><cide>use std::rc::Rc;\n\nstruct Owner {\n    name: String,\n    // ...other fields\n}\n\nstruct Gadget {\n    id: i32,\n    owner: Rc&lt;Owner&gt;,\n    // ...other fields\n}\n\nfn main() {\n    // Create a reference-counted `Owner`.\n    let gadget_owner: Rc&lt;Owner&gt; = Rc::new(\n        Owner {\n            name: &quot;Gadget Man&quot;.to_string(),\n        }\n    );\n\n    // Create `Gadget`s belonging to `gadget_owner`. Cloning the `Rc&lt;Owner&gt;`\n    // gives us a new pointer to the same `Owner` allocation, incrementing\n    // the reference count in the process.\n    let gadget1 = Gadget {\n        id: 1,\n        owner: Rc::clone(&amp;gadget_owner),\n    };\n    let gadget2 = Gadget {\n        id: 2,\n        owner: Rc::clone(&amp;gadget_owner),\n    };\n\n    // Dispose of our local variable `gadget_owner`.\n    drop(gadget_owner);\n\n    // Despite dropping `gadget_owner`, we#$%re still able to print out the name\n    // of the `Owner` of the `Gadget`s. This is because we#$%ve only dropped a\n    // single `Rc&lt;Owner&gt;`, not the `Owner` it points to. As long as there are\n    // other `Rc&lt;Owner&gt;` pointing at the same `Owner` allocation, it will remain\n    // live. The field projection `gadget1.owner.name` works because\n    // `Rc&lt;Owner&gt;` automatically dereferences to `Owner`.\n    println!(&quot;Gadget {} owned by {}&quot;, gadget1.id, gadget1.owner.name);\n    println!(&quot;Gadget {} owned by {}&quot;, gadget2.id, gadget2.owner.name);\n\n    // At the end of the function, `gadget1` and `gadget2` are destroyed, and\n    // with them the last counted references to our `Owner`. Gadget Man now\n    // gets destroyed as well.\n}\n</code></pre>\n<p>If our requirements change, and we also need to be able to traverse from\n<cide>Owner</code> to <cide>Gadget</code>, we will run into problems. An <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a> pointer from <cide>Owner</code>\nto <cide>Gadget</code> introduces a cycle. This means that their\nreference counts can never reach 0, and the allocation will never be destroyed:\na memory leak. In order to get around this, we can use <a href="https://docs.rs/alloc/*/alloc/rc/struct.Weak.html"><cide>Weak</code></a>\npointers.</p>\n<p>Rust actually makes it somewhat difficult to produce this loop in the first\nplace. In order to end up with two values that point at each other, one of\nthem needs to be mutable. This is difficult because <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a> enforces\nmemory safety by only giving out shared references to the value it wraps,\nand these don#$%t allow direct mutation. We need to wrap the part of the\nvalue we wish to mutate in a <a href="https://docs.rs/core/*/core/cell/struct.RefCell.html"><cide>RefCell</code></a>, which provides <em>interior\nmutability</em>: a method to achieve mutability through a shared reference.\n<a href="https://docs.rs/core/*/core/cell/struct.RefCell.html"><cide>RefCell</code></a> enforces Rust#$%s borrowing rules at runtime.</p>\n<per><cide>use std::rc::Rc;\nuse std::rc::Weak;\nuse std::cell::RefCell;\n\nstruct Owner {\n    name: String,\n    gadgets: RefCell&lt;Vec&lt;Weak&lt;Gadget&gt;&gt;&gt;,\n    // ...other fields\n}\n\nstruct Gadget {\n    id: i32,\n    owner: Rc&lt;Owner&gt;,\n    // ...other fields\n}\n\nfn main() {\n    // Create a reference-counted `Owner`. Note that we#$%ve put the `Owner`#$%s\n    // vector of `Gadget`s inside a `RefCell` so that we can mutate it through\n    // a shared reference.\n    let gadget_owner: Rc&lt;Owner&gt; = Rc::new(\n        Owner {\n            name: &quot;Gadget Man&quot;.to_string(),\n            gadgets: RefCell::new(vec![]),\n        }\n    );\n\n    // Create `Gadget`s belonging to `gadget_owner`, as before.\n    let gadget1 = Rc::new(\n        Gadget {\n            id: 1,\n            owner: Rc::clone(&amp;gadget_owner),\n        }\n    );\n    let gadget2 = Rc::new(\n        Gadget {\n            id: 2,\n            owner: Rc::clone(&amp;gadget_owner),\n        }\n    );\n\n    // Add the `Gadget`s to their `Owner`.\n    {\n        let mut gadgets = gadget_owner.gadgets.borrow_mut();\n        gadgets.push(Rc::downgrade(&amp;gadget1));\n        gadgets.push(Rc::downgrade(&amp;gadget2));\n\n        // `RefCell` dynamic borrow ends here.\n    }\n\n    // Iterate over our `Gadget`s, printing their details out.\n    for gadget_weak in gadget_owner.gadgets.borrow().iter() {\n\n        // `gadget_weak` is a `Weak&lt;Gadget&gt;`. Since `Weak` pointers can#$%t\n        // guarantee the allocation still exists, we need to call\n        // `upgrade`, which returns an `Option&lt;Rc&lt;Gadget&gt;&gt;`.\n        //\n        // In this case we know the allocation still exists, so we simply\n        // `unwrap` the `Option`. In a more complicated program, you might\n        // need graceful error handling for a `None` result.\n\n        let gadget = gadget_weak.upgrade().unwrap();\n        println!(&quot;Gadget {} owned by {}&quot;, gadget.id, gadget.owner.name);\n    }\n\n    // At the end of the function, `gadget_owner`, `gadget1`, and `gadget2`\n    // are destroyed. There are now no strong (`Rc`) pointers to the\n    // gadgets, so they are destroyed. This zeroes the reference count on\n    // Gadget Man, so he gets destroyed as well.\n}\n</code></pre>\n','<per><cide class="language-rust">alloc::rc\n</code></pre>\n<per><cide class="language-rust">pub struct Rc&lt;T&gt;\nwhere\n    T: ?Sized,\n</code></pre>\n<hr />\n<p>A single-threaded reference-counting pointer. #$%Rc#$% stands for #$%Reference\nCounted#$%.</p>\n<p>See the <a href="https://docs.rs/alloc/*/alloc/rc/index.html">module-level documentation</a> for more details.</p>\n<p>The inherent methods of <cide>Rc</code> are all associated functions, which means\nthat you have to call them as e.g., <a href="Rc::get_mut"><cide>Rc::get_mut(&amp;mut value)</code></a> instead of\n<cide>value.get_mut()</code>. This avoids conflicts with methods of the inner type <cide>T</code>.</p>\n','<per><cide class="language-rust">let counter: Rc&lt;Mutex&lt;i32&gt;&gt;\n</code></pre>\n','<per><cide class="language-rust">alloc::rc::Rc\n</code></pre>\n<per><cide class="language-rust">pub fn new(value: T) -&gt; Rc&lt;T&gt;\n</code></pre>\n<hr />\n<p>Constructs a new <cide>Rc&lt;T&gt;</code>.</p>\n<h1 id="examples-9"><a class="header" href="#examples-9">Examples</a></h1>\n<per><cide>use std::rc::Rc;\n\nlet five = Rc::new(5);\n</code></pre>\n','<per><cide class="language-rust">core::clone::Clone\n</code></pre>\n<per><cide class="language-rust">pub fn clone(&amp;self) -&gt; Self\n</code></pre>\n<hr />\n<p>Returns a copy of the value.</p>\n<h1 id="examples-10"><a class="header" href="#examples-10">Examples</a></h1>\n<per><cide># #![allow(noop_method_call)]\nlet hello = &quot;Hello&quot;; // &amp;str implements Clone\n\nassert_eq!(&quot;Hello&quot;, hello.clone());\n</code></pre>\n','<per><cide class="language-rust">alloc::sync\n</code></pre>\n<per><cide class="language-rust">pub struct Arc&lt;T&gt;\nwhere\n    T: ?Sized,\n</code></pre>\n<hr />\n<p>A thread-safe reference-counting pointer. #$%Arc#$% stands for #$%Atomically\nReference Counted#$%.</p>\n<p>The type <cide>Arc&lt;T&gt;</code> provides shared ownership of a value of type <cide>T</code>,\nallocated in the heap. Invoking <a href="https://docs.rs/core/*/core/clone/trait.Clone.html#tymethod.clone"><cide>clone</code></a> on <cide>Arc</code> produces\na new <cide>Arc</code> instance, which points to the same allocation on the heap as the\nsource <cide>Arc</code>, while increasing a reference count. When the last <cide>Arc</code>\npointer to a given allocation is destroyed, the value stored in that allocation (often\nreferred to as &quot;inner value&quot;) is also dropped.</p>\n<p>Shared references in Rust disallow mutation by default, and <cide>Arc</code> is no\nexception: you cannot generally obtain a mutable reference to something\ninside an <cide>Arc</code>. If you need to mutate through an <cide>Arc</code>, use\n<a href="https://docs.rs/alloc/*/std/sync/struct.Mutex.html"><cide>Mutex</code></a>, <a href="https://docs.rs/alloc/*/std/sync/struct.RwLock.html"><cide>RwLock</code></a>, or one of the <a href="https://docs.rs/core/*/core/sync/atomic/index.html"><cide>Atomic</code></a>\ntypes.</p>\n<h2 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h2>\n<p>Unlike <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc&lt;T&gt;</code></a>, <cide>Arc&lt;T&gt;</code> uses atomic operations for its reference\ncounting. This means that it is thread-safe. The disadvantage is that\natomic operations are more expensive than ordinary memory accesses. If you\nare not sharing reference-counted allocations between threads, consider using\n<a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc&lt;T&gt;</code></a> for lower overhead. <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc&lt;T&gt;</code></a> is a safe default, because the\ncompiler will catch any attempt to send an <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc&lt;T&gt;</code></a> between threads.\nHowever, a library might choose <cide>Arc&lt;T&gt;</code> in order to give library consumers\nmore flexibility.</p>\n<p><cide>Arc&lt;T&gt;</code> will implement <a href="https://docs.rs/core/*/core/marker/trait.Send.html"><cide>Send</code></a> and <a href="https://docs.rs/core/*/core/marker/trait.Sync.html"><cide>Sync</code></a> as long as the <cide>T</code> implements\n<a href="https://docs.rs/core/*/core/marker/trait.Send.html"><cide>Send</code></a> and <a href="https://docs.rs/core/*/core/marker/trait.Sync.html"><cide>Sync</code></a>. Why can#$%t you put a non-thread-safe type <cide>T</code> in an\n<cide>Arc&lt;T&gt;</code> to make it thread-safe? This may be a bit counter-intuitive at\nfirst: after all, isn#$%t the point of <cide>Arc&lt;T&gt;</code> thread safety? The key is\nthis: <cide>Arc&lt;T&gt;</code> makes it thread safe to have multiple ownership of the same\ndata, but it  doesn#$%t add thread safety to its data. Consider\n<cide>Arc&lt;</code><a href="https://docs.rs/core/*/core/cell/struct.RefCell.html"><cide>RefCell&lt;T&gt;</code></a><cide>&gt;</code>. <a href="https://docs.rs/core/*/core/cell/struct.RefCell.html"><cide>RefCell&lt;T&gt;</code></a> isn#$%t <a href="https://docs.rs/core/*/core/marker/trait.Sync.html"><cide>Sync</code></a>, and if <cide>Arc&lt;T&gt;</code> was always\n<a href="https://docs.rs/core/*/core/marker/trait.Send.html"><cide>Send</code></a>, <cide>Arc&lt;</code><a href="https://docs.rs/core/*/core/cell/struct.RefCell.html"><cide>RefCell&lt;T&gt;</code></a><cide>&gt;</code> would be as well. But then we#$%d have a problem:\n<a href="https://docs.rs/core/*/core/cell/struct.RefCell.html"><cide>RefCell&lt;T&gt;</code></a> is not thread safe; it keeps track of the borrowing count using\nnon-atomic operations.</p>\n<p>In the end, this means that you may need to pair <cide>Arc&lt;T&gt;</code> with some sort of\n<a href="https://docs.rs/alloc/*/std/sync/index.html"><cide>std::sync</code></a> type, usually <a href="https://docs.rs/alloc/*/std/sync/struct.Mutex.html"><cide>Mutex&lt;T&gt;</code></a>.</p>\n<h2 id="breaking-cycles-with-cideweak"><a class="header" href="#breaking-cycles-with-cideweak">Breaking cycles with <cide>Weak</code></a></h2>\n<p>The <a href="Arc::downgrade"><cide>downgrade</code></a> method can be used to create a non-owning\n<a href="https://docs.rs/alloc/*/alloc/sync/struct.Weak.html"><cide>Weak</code></a> pointer. A <a href="https://docs.rs/alloc/*/alloc/sync/struct.Weak.html"><cide>Weak</code></a> pointer can be <a href="Weak::upgrade"><cide>upgrade</code></a>d\nto an <cide>Arc</code>, but this will return <a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>None</code></a> if the value stored in the allocation has\nalready been dropped. In other words, <cide>Weak</code> pointers do not keep the value\ninside the allocation alive; however, they <em>do</em> keep the allocation\n(the backing store for the value) alive.</p>\n<p>A cycle between <cide>Arc</code> pointers will never be deallocated. For this reason,\n<a href="https://docs.rs/alloc/*/alloc/sync/struct.Weak.html"><cide>Weak</code></a> is used to break cycles. For example, a tree could have\nstrong <cide>Arc</code> pointers from parent nodes to children, and <a href="https://docs.rs/alloc/*/alloc/sync/struct.Weak.html"><cide>Weak</code></a>\npointers from children back to their parents.</p>\n<h1 id="cloning-references-1"><a class="header" href="#cloning-references-1">Cloning references</a></h1>\n<p>Creating a new reference from an existing reference-counted pointer is done using the\n<cide>Clone</code> trait implemented for <a href="https://docs.rs/alloc/*/alloc/sync/struct.Arc.html"><cide>Arc&lt;T&gt;</code></a> and <a href="https://docs.rs/alloc/*/alloc/sync/struct.Weak.html"><cide>Weak&lt;T&gt;</code></a>.</p>\n<per><cide>use std::sync::Arc;\nlet foo = Arc::new(vec![1.0, 2.0, 3.0]);\n// The two syntaxes below are equivalent.\nlet a = foo.clone();\nlet b = Arc::clone(&amp;foo);\n// a, b, and foo are all Arcs that point to the same memory location\n</code></pre>\n<h2 id="cidederef-behavior"><a class="header" href="#cidederef-behavior"><cide>Deref</code> behavior</a></h2>\n<p><cide>Arc&lt;T&gt;</code> automatically dereferences to <cide>T</code> (via the <a href="https://docs.rs/core/*/core/ops/deref/trait.Deref.html"><cide>Deref</code></a> trait),\nso you can call <cide>T</code>#$%s methods on a value of type <cide>Arc&lt;T&gt;</code>. To avoid name\nclashes with <cide>T</code>#$%s methods, the methods of <cide>Arc&lt;T&gt;</code> itself are associated\nfunctions, called using <a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">fully qualified syntax</a>:</p>\n<per><cide>use std::sync::Arc;\n\nlet my_arc = Arc::new(());\nArc::downgrade(&amp;my_arc);\n</code></pre>\n<p><cide>Arc&lt;T&gt;</code>#$%s implementations of traits like <cide>Clone</code> may also be called using\nfully qualified syntax. Some people prefer to use fully qualified syntax,\nwhile others prefer using method-call syntax.</p>\n<per><cide>use std::sync::Arc;\n\nlet arc = Arc::new(());\n// Method-call syntax\nlet arc2 = arc.clone();\n// Fully qualified syntax\nlet arc3 = Arc::clone(&amp;arc);\n</code></pre>\n<p><a href="https://docs.rs/alloc/*/alloc/sync/struct.Weak.html"><cide>Weak&lt;T&gt;</code></a> does not auto-dereference to <cide>T</code>, because the inner value may have\nalready been dropped.</p>\n<h1 id="examples-11"><a class="header" href="#examples-11">Examples</a></h1>\n<p>Sharing some immutable data between threads:</p>\n<per><cide class="language-no_run">use std::sync::Arc;\nuse std::thread;\n\nlet five = Arc::new(5);\n\nfor _ in 0..10 {\n    let five = Arc::clone(&amp;five);\n\n    thread::spawn(move || {\n        println!(&quot;{:?}&quot;, five);\n    });\n}\n</code></pre>\n<p>Sharing a mutable <a href="https://docs.rs/core/*/core/sync/atomic/struct.AtomicUsize.html"><cide>AtomicUsize</code></a>:</p>\n<per><cide class="language-no_run">use std::sync::Arc;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::thread;\n\nlet val = Arc::new(AtomicUsize::new(5));\n\nfor _ in 0..10 {\n    let val = Arc::clone(&amp;val);\n\n    thread::spawn(move || {\n        let v = val.fetch_add(1, Ordering::SeqCst);\n        println!(&quot;{:?}&quot;, v);\n    });\n}\n</code></pre>\n<p>See the <a href="crate::rc#examples"><cide>rc</code> documentation</a> for more examples of reference\ncounting in general.</p>\n','<per><cide class="language-rust">let counter: Arc&lt;Mutex&lt;i32&gt;&gt;\n</code></pre>\n','<per><cide class="language-rust">alloc::sync::Arc\n</code></pre>\n<per><cide class="language-rust">pub fn new(data: T) -&gt; Arc&lt;T&gt;\n</code></pre>\n<hr />\n<p>Constructs a new <cide>Arc&lt;T&gt;</code>.</p>\n<h1 id="examples-12"><a class="header" href="#examples-12">Examples</a></h1>\n<per><cide>use std::sync::Arc;\n\nlet five = Arc::new(5);\n</code></pre>\n',].map((x)=>x.replaceAll('#$%', "'").replaceAll('<per', '<pre').replaceAll('<cide', '<code'));
    window.onload = () => {
        console.log("hello");
        tippy('.ra', {
            content: (x) => {
                const div = document.createElement('div');
                div.innerHTML = hoverData[x.dataset.hover];
                div.className = 'hover-holder';
                div.querySelectorAll('code').forEach((y) => y.innerHTML = hljs.highlight('rust', y.innerText).value);
                return div;
            },
            allowHTML: true,
            delay: [200, 0],
            interactive: true,
            maxWidth: '80vw',
            appendTo: document.querySelector('.content'),
        });
    };
</script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="ch16-02-message-passing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="ch16-04-extensible-concurrency-sync-and-send.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="ch16-02-message-passing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="ch16-04-extensible-concurrency-sync-and-send.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="ferris.js"></script>
        
        
    </body>
</html>
