<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Processing a Series of Items with Iterators - The Rust Programming Language</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="ferris.css">
                <link rel="stylesheet" href="theme/2018-edition.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References and Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> The Slice Type</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> How to Write Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlling How Tests Are Run</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html" class="active"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.inlay-hint, .inlay-hint * {
    border-radius: .4em;
}

.light .inlay-hint, .rust .inlay-hint {
    background-color: #dcc;
    color: #777;
}

.ayu .inlay-hint, .navy .inlay-hint, .coal .inlay-hint {
    background-color: #444;
    color: #999;
}

.inlay-hint {
    font-size: 0.8em;
    user-select: none;
}
.hover-holder {
    max-height: 40vh;
    overflow: auto;
}

.tippy-content {
    background-color: var(--bg);
    color: var(--fg);
}
</style>## Processing a Series of Items with Iterators
<p>The iterator pattern allows you to perform some task on a sequence of items in
turn. An iterator is responsible for the logic of iterating over each item and
determining when the sequence has finished. When you use iterators, you don’t
have to reimplement that logic yourself.</p>
<p>In Rust, iterators are <em>lazy</em>, meaning they have no effect until you call
methods that consume the iterator to use it up. For example, the code in
Listing 13-13 creates an iterator over the items in the vector <code>v1</code> by calling
the <code>iter</code> method defined on <code>Vec&lt;T&gt;</code>. This code by itself doesn’t do anything
useful.</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">fn main() {
</span>    let <span class="ra" data-hover="1">v1</span><span class="inlay-hint">: Vec&lt;i32&gt;</span> = <span class="ra" data-hover="2">vec</span>![1, 2, 3];

    let <span class="ra" data-hover="3">v1_iter</span><span class="inlay-hint">: Iter&lt;i32&gt;</span> = <span class="ra" data-hover="1">v1</span>.<span class="ra" data-hover="4">iter</span>();
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-13: Creating an iterator</span></p>
<p>Once we’ve created an iterator, we can use it in a variety of ways. In Listing
3-5 in Chapter 3, we used iterators with <code>for</code> loops to execute some code on
each item, although we glossed over what the call to <code>iter</code> did until now.</p>
<p>The example in Listing 13-14 separates the creation of the iterator from the
use of the iterator in the <code>for</code> loop. The iterator is stored in the <code>v1_iter</code>
variable, and no iteration takes place at that time. When the <code>for</code> loop is
called using the iterator in <code>v1_iter</code>, each element in the iterator is used in
one iteration of the loop, which prints out each value.</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">fn main() {
</span>    let <span class="ra" data-hover="1">v1</span><span class="inlay-hint">: Vec&lt;i32&gt;</span> = <span class="ra" data-hover="2">vec</span>![1, 2, 3];

    let <span class="ra" data-hover="3">v1_iter</span><span class="inlay-hint">: Iter&lt;i32&gt;</span> = <span class="ra" data-hover="1">v1</span>.<span class="ra" data-hover="4">iter</span>();

    for <span class="ra" data-hover="5">val</span><span class="inlay-hint">: &amp;i32</span> in <span class="ra" data-hover="3">v1_iter</span> {
        <span class="ra" data-hover="6">println</span>!("Got: {}", <span class="ra" data-hover="5">val</span>);
    }
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-14: Using an iterator in a <code>for</code> loop</span></p>
<p>In languages that don’t have iterators provided by their standard libraries,
you would likely write this same functionality by starting a variable at index
0, using that variable to index into the vector to get a value, and
incrementing the variable value in a loop until it reached the total number of
items in the vector.</p>
<p>Iterators handle all that logic for you, cutting down on repetitive code you
could potentially mess up. Iterators give you more flexibility to use the same
logic with many different kinds of sequences, not just data structures you can
index into, like vectors. Let’s examine how iterators do that.</p>
<h3 id="the-iterator-trait-and-the-next-method"><a class="header" href="#the-iterator-trait-and-the-next-method">The <code>Iterator</code> Trait and the <code>next</code> Method</a></h3>
<p>All iterators implement a trait named <code>Iterator</code> that is defined in the
standard library. The definition of the trait looks like this:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait <span class="ra" data-hover="7">Iterator</span> {
    type <span class="ra" data-hover="8">Item</span>;

    fn <span class="ra" data-hover="9">next</span>(&amp;mut <span class="ra" data-hover="10">self</span>) -&gt; <span class="ra" data-hover="11">Option</span>&lt;<span class="ra" data-hover="12">Self</span>::<span class="ra" data-hover="8">Item</span>&gt;;

    // methods with default implementations elided
}
<span class="boring">}
</span>
</code></pre></pre>
<p>Notice this definition uses some new syntax: <code>type Item</code> and <code>Self::Item</code>,
which are defining an <em>associated type</em> with this trait. We’ll talk about
associated types in depth in Chapter 19. For now, all you need to know is that
this code says implementing the <code>Iterator</code> trait requires that you also define
an <code>Item</code> type, and this <code>Item</code> type is used in the return type of the <code>next</code>
method. In other words, the <code>Item</code> type will be the type returned from the
iterator.</p>
<p>The <code>Iterator</code> trait only requires implementors to define one method: the
<code>next</code> method, which returns one item of the iterator at a time wrapped in
<code>Some</code> and, when iteration is over, returns <code>None</code>.</p>
<p>We can call the <code>next</code> method on iterators directly; Listing 13-15 demonstrates
what values are returned from repeated calls to <code>next</code> on the iterator created
from the vector.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[<span class="ra" data-hover="13">test</span>]
    fn <span class="ra" data-hover="14">iterator_demonstration</span>() {
        let <span class="ra" data-hover="1">v1</span><span class="inlay-hint">: Vec&lt;i32&gt;</span> = <span class="ra" data-hover="2">vec</span>![1, 2, 3];

        let mut <span class="ra" data-hover="15">v1_iter</span><span class="inlay-hint">: Iter&lt;i32&gt;</span> = <span class="ra" data-hover="1">v1</span>.<span class="ra" data-hover="4">iter</span>();

        <span class="ra" data-hover="16">assert_eq</span>!(<span class="ra" data-hover="15">v1_iter</span>.<span class="ra" data-hover="17">next</span>(), <span class="ra" data-hover="18">Some</span>(&amp;1));
        <span class="ra" data-hover="16">assert_eq</span>!(<span class="ra" data-hover="15">v1_iter</span>.<span class="ra" data-hover="17">next</span>(), <span class="ra" data-hover="18">Some</span>(&amp;2));
        <span class="ra" data-hover="16">assert_eq</span>!(<span class="ra" data-hover="15">v1_iter</span>.<span class="ra" data-hover="17">next</span>(), <span class="ra" data-hover="18">Some</span>(&amp;3));
        <span class="ra" data-hover="16">assert_eq</span>!(<span class="ra" data-hover="15">v1_iter</span>.<span class="ra" data-hover="17">next</span>(), <span class="ra" data-hover="19">None</span>);
    }
<span class="boring">}
</span><span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-15: Calling the <code>next</code> method on an
iterator</span></p>
<p>Note that we needed to make <code>v1_iter</code> mutable: calling the <code>next</code> method on an
iterator changes internal state that the iterator uses to keep track of where
it is in the sequence. In other words, this code <em>consumes</em>, or uses up, the
iterator. Each call to <code>next</code> eats up an item from the iterator. We didn’t need
to make <code>v1_iter</code> mutable when we used a <code>for</code> loop because the loop took
ownership of <code>v1_iter</code> and made it mutable behind the scenes.</p>
<p>Also note that the values we get from the calls to <code>next</code> are immutable
references to the values in the vector. The <code>iter</code> method produces an iterator
over immutable references. If we want to create an iterator that takes
ownership of <code>v1</code> and returns owned values, we can call <code>into_iter</code> instead of
<code>iter</code>. Similarly, if we want to iterate over mutable references, we can call
<code>iter_mut</code> instead of <code>iter</code>.</p>
<h3 id="methods-that-consume-the-iterator"><a class="header" href="#methods-that-consume-the-iterator">Methods that Consume the Iterator</a></h3>
<p>The <code>Iterator</code> trait has a number of different methods with default
implementations provided by the standard library; you can find out about these
methods by looking in the standard library API documentation for the <code>Iterator</code>
trait. Some of these methods call the <code>next</code> method in their definition, which
is why you’re required to implement the <code>next</code> method when implementing the
<code>Iterator</code> trait.</p>
<p>Methods that call <code>next</code> are called <em>consuming adaptors</em>, because calling them
uses up the iterator. One example is the <code>sum</code> method, which takes ownership of
the iterator and iterates through the items by repeatedly calling <code>next</code>, thus
consuming the iterator. As it iterates through, it adds each item to a running
total and returns the total when iteration is complete. Listing 13-16 has a
test illustrating a use of the <code>sum</code> method:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[<span class="ra" data-hover="13">test</span>]
    fn <span class="ra" data-hover="20">iterator_sum</span>() {
        let <span class="ra" data-hover="1">v1</span><span class="inlay-hint">: Vec&lt;i32&gt;</span> = <span class="ra" data-hover="2">vec</span>![1, 2, 3];

        let <span class="ra" data-hover="3">v1_iter</span><span class="inlay-hint">: Iter&lt;i32&gt;</span> = <span class="ra" data-hover="1">v1</span>.<span class="ra" data-hover="4">iter</span>();

        let <span class="ra" data-hover="21">total</span>: <span class="ra" data-hover="22">i32</span> = <span class="ra" data-hover="3">v1_iter</span>.<span class="ra" data-hover="23">sum</span>();

        <span class="ra" data-hover="16">assert_eq</span>!(<span class="ra" data-hover="21">total</span>, 6);
    }
<span class="boring">}
</span><span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-16: Calling the <code>sum</code> method to get the total
of all items in the iterator</span></p>
<p>We aren’t allowed to use <code>v1_iter</code> after the call to <code>sum</code> because <code>sum</code> takes
ownership of the iterator we call it on.</p>
<h3 id="methods-that-produce-other-iterators"><a class="header" href="#methods-that-produce-other-iterators">Methods that Produce Other Iterators</a></h3>
<p>Other methods defined on the <code>Iterator</code> trait, known as <em>iterator adaptors</em>,
allow you to change iterators into different kinds of iterators. You can chain
multiple calls to iterator adaptors to perform complex actions in a readable
way. But because all iterators are lazy, you have to call one of the consuming
adaptor methods to get results from calls to iterator adaptors.</p>
<p>Listing 13-17 shows an example of calling the iterator adaptor method <code>map</code>,
which takes a closure to call on each item to produce a new iterator. The
closure here creates a new iterator in which each item from the vector has been
incremented by 1. However, this code produces a warning:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">fn main() {
</span>    let <span class="ra" data-hover="1">v1</span>: <span class="ra" data-hover="24">Vec</span>&lt;<span class="ra" data-hover="22">i32</span>&gt; = <span class="ra" data-hover="2">vec</span>![1, 2, 3];

    <span class="ra" data-hover="1">v1</span>.<span class="ra" data-hover="4">iter</span>().<span class="ra" data-hover="25">map</span>(|<span class="ra" data-hover="26">x</span><span class="inlay-hint">: &amp;i32</span>| <span class="ra" data-hover="26">x</span> + 1);
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-17: Calling the iterator adaptor <code>map</code> to
create a new iterator</span></p>
<p>The warning we get is this:</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

warning: `iterators` (bin &quot;iterators&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>The code in Listing 13-17 doesn’t do anything; the closure we’ve specified
never gets called. The warning reminds us why: iterator adaptors are lazy, and
we need to consume the iterator here.</p>
<p>To fix this and consume the iterator, we’ll use the <code>collect</code> method, which we
used in Chapter 12 with <code>env::args</code> in Listing 12-1. This method consumes the
iterator and collects the resulting values into a collection data type.</p>
<p>In Listing 13-18, we collect the results of iterating over the iterator that’s
returned from the call to <code>map</code> into a vector. This vector will end up
containing each item from the original vector incremented by 1.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">fn main() {
</span>    let <span class="ra" data-hover="1">v1</span>: <span class="ra" data-hover="24">Vec</span>&lt;<span class="ra" data-hover="22">i32</span>&gt; = <span class="ra" data-hover="2">vec</span>![1, 2, 3];

    let <span class="ra" data-hover="27">v2</span>: <span class="ra" data-hover="24">Vec</span>&lt;_&gt; = <span class="ra" data-hover="1">v1</span>.<span class="ra" data-hover="4">iter</span>().<span class="ra" data-hover="25">map</span>(|<span class="ra" data-hover="26">x</span><span class="inlay-hint">: &amp;i32</span>| <span class="ra" data-hover="26">x</span> + 1).<span class="ra" data-hover="28">collect</span>();

    <span class="ra" data-hover="16">assert_eq</span>!(<span class="ra" data-hover="27">v2</span>, <span class="ra" data-hover="2">vec</span>![2, 3, 4]);
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-18: Calling the <code>map</code> method to create a new
iterator and then calling the <code>collect</code> method to consume the new iterator and
create a vector</span></p>
<p>Because <code>map</code> takes a closure, we can specify any operation we want to perform
on each item. This is a great example of how closures let you customize some
behavior while reusing the iteration behavior that the <code>Iterator</code> trait
provides.</p>
<h3 id="using-closures-that-capture-their-environment"><a class="header" href="#using-closures-that-capture-their-environment">Using Closures that Capture Their Environment</a></h3>
<p>Now that we’ve introduced iterators, we can demonstrate a common use of
closures that capture their environment by using the <code>filter</code> iterator adaptor.
The <code>filter</code> method on an iterator takes a closure that takes each item from
the iterator and returns a Boolean. If the closure returns <code>true</code>, the value
will be included in the iterator produced by <code>filter</code>. If the closure returns
<code>false</code>, the value won’t be included in the resulting iterator.</p>
<p>In Listing 13-19, we use <code>filter</code> with a closure that captures the <code>shoe_size</code>
variable from its environment to iterate over a collection of <code>Shoe</code> struct
instances. It will return only shoes that are the specified size.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[<span class="ra" data-hover="29">derive</span>(PartialEq, <span class="ra" data-hover="30">Debug</span>)]
struct <span class="ra" data-hover="31">Shoe</span> {
    <span class="ra" data-hover="32">size</span>: <span class="ra" data-hover="33">u32</span>,
    <span class="ra" data-hover="34">style</span>: <span class="ra" data-hover="35">String</span>,
}

fn <span class="ra" data-hover="36">shoes_in_size</span>(<span class="ra" data-hover="37">shoes</span>: <span class="ra" data-hover="24">Vec</span>&lt;<span class="ra" data-hover="31">Shoe</span>&gt;, <span class="ra" data-hover="38">shoe_size</span>: <span class="ra" data-hover="33">u32</span>) -&gt; <span class="ra" data-hover="24">Vec</span>&lt;<span class="ra" data-hover="31">Shoe</span>&gt; {
    <span class="ra" data-hover="37">shoes</span>.<span class="ra" data-hover="39">into_iter</span>().<span class="ra" data-hover="40">filter</span>(|<span class="ra" data-hover="41">s</span><span class="inlay-hint">: &amp;Shoe</span>| <span class="ra" data-hover="41">s</span>.<span class="ra" data-hover="32">size</span> == <span class="ra" data-hover="38">shoe_size</span>).<span class="ra" data-hover="28">collect</span>()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[<span class="ra" data-hover="13">test</span>]
    fn <span class="ra" data-hover="42">filters_by_size</span>() {
        let <span class="ra" data-hover="43">shoes</span><span class="inlay-hint">: Vec&lt;Shoe&gt;</span> = <span class="ra" data-hover="2">vec</span>![
            <span class="ra" data-hover="31">Shoe</span> {
                <span class="ra" data-hover="32">size</span>: 10,
                <span class="ra" data-hover="34">style</span>: <span class="ra" data-hover="35">String</span>::<span class="ra" data-hover="44">from</span>("sneaker"),
            },
            <span class="ra" data-hover="31">Shoe</span> {
                <span class="ra" data-hover="32">size</span>: 13,
                <span class="ra" data-hover="34">style</span>: <span class="ra" data-hover="35">String</span>::<span class="ra" data-hover="44">from</span>("sandal"),
            },
            <span class="ra" data-hover="31">Shoe</span> {
                <span class="ra" data-hover="32">size</span>: 10,
                <span class="ra" data-hover="34">style</span>: <span class="ra" data-hover="35">String</span>::<span class="ra" data-hover="44">from</span>("boot"),
            },
        ];

        let <span class="ra" data-hover="45">in_my_size</span><span class="inlay-hint">: Vec&lt;Shoe&gt;</span> = <span class="ra" data-hover="36">shoes_in_size</span>(<span class="ra" data-hover="43">shoes</span>, <span class="inlay-hint">shoe_size: </span>10);

        <span class="ra" data-hover="16">assert_eq</span>!(
            <span class="ra" data-hover="45">in_my_size</span>,
            <span class="ra" data-hover="2">vec</span>![
                <span class="ra" data-hover="31">Shoe</span> {
                    <span class="ra" data-hover="32">size</span>: 10,
                    <span class="ra" data-hover="34">style</span>: <span class="ra" data-hover="35">String</span>::<span class="ra" data-hover="44">from</span>("sneaker")
                },
                <span class="ra" data-hover="31">Shoe</span> {
                    <span class="ra" data-hover="32">size</span>: 10,
                    <span class="ra" data-hover="34">style</span>: <span class="ra" data-hover="35">String</span>::<span class="ra" data-hover="44">from</span>("boot")
                },
            ]
        );
    }
}
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-19: Using the <code>filter</code> method with a closure
that captures <code>shoe_size</code></span></p>
<p>The <code>shoes_in_size</code> function takes ownership of a vector of shoes and a shoe
size as parameters. It returns a vector containing only shoes of the specified
size.</p>
<p>In the body of <code>shoes_in_size</code>, we call <code>into_iter</code> to create an iterator
that takes ownership of the vector. Then we call <code>filter</code> to adapt that
iterator into a new iterator that only contains elements for which the closure
returns <code>true</code>.</p>
<p>The closure captures the <code>shoe_size</code> parameter from the environment and
compares the value with each shoe’s size, keeping only shoes of the size
specified. Finally, calling <code>collect</code> gathers the values returned by the
adapted iterator into a vector that’s returned by the function.</p>
<p>The test shows that when we call <code>shoes_in_size</code>, we get back only shoes
that have the same size as the value we specified.</p>
<h3 id="creating-our-own-iterators-with-the-iterator-trait"><a class="header" href="#creating-our-own-iterators-with-the-iterator-trait">Creating Our Own Iterators with the <code>Iterator</code> Trait</a></h3>
<p>We’ve shown that you can create an iterator by calling <code>iter</code>, <code>into_iter</code>, or
<code>iter_mut</code> on a vector. You can create iterators from the other collection
types in the standard library, such as hash map. You can also create iterators
that do anything you want by implementing the <code>Iterator</code> trait on your own
types. As previously mentioned, the only method you’re required to provide a
definition for is the <code>next</code> method. Once you’ve done that, you can use all
other methods that have default implementations provided by the <code>Iterator</code>
trait!</p>
<p>To demonstrate, let’s create an iterator that will only ever count from 1 to 5.
First, we’ll create a struct to hold some values. Then we’ll make this struct
into an iterator by implementing the <code>Iterator</code> trait and using the values in
that implementation.</p>
<p>Listing 13-20 has the definition of the <code>Counter</code> struct and an associated
<code>new</code> function to create instances of <code>Counter</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct <span class="ra" data-hover="46">Counter</span> {
    <span class="ra" data-hover="47">count</span>: <span class="ra" data-hover="33">u32</span>,
}

impl <span class="ra" data-hover="46">Counter</span> {
    fn <span class="ra" data-hover="48">new</span>() -&gt; <span class="ra" data-hover="46">Counter</span> {
        <span class="ra" data-hover="46">Counter</span> { <span class="ra" data-hover="47">count</span>: 0 }
    }
}
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-20: Defining the <code>Counter</code> struct and a <code>new</code>
function that creates instances of <code>Counter</code> with an initial value of 0 for
<code>count</code></span></p>
<p>The <code>Counter</code> struct has one field named <code>count</code>. This field holds a <code>u32</code>
value that will keep track of where we are in the process of iterating from 1
to 5. The <code>count</code> field is private because we want the implementation of
<code>Counter</code> to manage its value. The <code>new</code> function enforces the behavior of
always starting new instances with a value of 0 in the <code>count</code> field.</p>
<p>Next, we’ll implement the <code>Iterator</code> trait for our <code>Counter</code> type by defining
the body of the <code>next</code> method to specify what we want to happen when this
iterator is used, as shown in Listing 13-21:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -> Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl <span class="ra" data-hover="49">Iterator</span> for <span class="ra" data-hover="46">Counter</span> {
    type <span class="ra" data-hover="50">Item</span> = <span class="ra" data-hover="33">u32</span>;

    fn <span class="ra" data-hover="51">next</span>(&amp;mut <span class="ra" data-hover="52">self</span>) -&gt; <span class="ra" data-hover="11">Option</span>&lt;<span class="ra" data-hover="46">Self</span>::<span class="ra" data-hover="53">Item</span>&gt; {
        if <span class="ra" data-hover="52">self</span>.<span class="ra" data-hover="47">count</span> &lt; 5 {
            <span class="ra" data-hover="52">self</span>.<span class="ra" data-hover="47">count</span> += 1;
            <span class="ra" data-hover="18">Some</span>(<span class="ra" data-hover="52">self</span>.<span class="ra" data-hover="47">count</span>)
        } else {
            <span class="ra" data-hover="19">None
        }
    }
}
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-21: Implementing the <code>Iterator</code> trait on our
<code>Counter</code> struct</span></p>
<p>We set the associated <code>Item</code> type for our iterator to <code>u32</code>, meaning the
iterator will return <code>u32</code> values. Again, don’t worry about associated types
yet, we’ll cover them in Chapter 19.</p>
<p>We want our iterator to add 1 to the current state, so we initialized <code>count</code>
to 0 so it would return 1 first. If the value of <code>count</code> is less than 5, <code>next</code>
will increment <code>count</code> and return the current value wrapped in <code>Some</code>. Once
<code>count</code> is 5, our iterator will stop incrementing <code>count</code> and always return
<code>None</code>.</p>
<h4 id="using-our-counter-iterators-next-method"><a class="header" href="#using-our-counter-iterators-next-method">Using Our <code>Counter</code> Iterator’s <code>next</code> Method</a></h4>
<p>Once we’ve implemented the <code>Iterator</code> trait, we have an iterator! Listing 13-22
shows a test demonstrating that we can use the iterator functionality of our
<code>Counter</code> struct by calling the <code>next</code> method on it directly, just as we did
with the iterator created from a vector in Listing 13-15.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -> Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Counter {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&mut self) -> Option<Self::Item> {
</span><span class="boring">        if self.count < 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[<span class="ra" data-hover="13">test</span>]
    fn <span class="ra" data-hover="54">calling_next_directly</span>() {
        let mut <span class="ra" data-hover="55">counter</span> = <span class="ra" data-hover="46">Counter</span>::new();

        <span class="ra" data-hover="16">assert_eq</span>!(<span class="ra" data-hover="55">counter</span>.<span class="ra" data-hover="17">next</span>(), <span class="ra" data-hover="18">Some</span>(1));
        <span class="ra" data-hover="16">assert_eq</span>!(<span class="ra" data-hover="55">counter</span>.<span class="ra" data-hover="17">next</span>(), <span class="ra" data-hover="18">Some</span>(2));
        <span class="ra" data-hover="16">assert_eq</span>!(<span class="ra" data-hover="55">counter</span>.<span class="ra" data-hover="17">next</span>(), <span class="ra" data-hover="18">Some</span>(3));
        <span class="ra" data-hover="16">assert_eq</span>!(<span class="ra" data-hover="55">counter</span>.<span class="ra" data-hover="17">next</span>(), <span class="ra" data-hover="18">Some</span>(4));
        <span class="ra" data-hover="16">assert_eq</span>!(<span class="ra" data-hover="55">counter</span>.<span class="ra" data-hover="17">next</span>(), <span class="ra" data-hover="18">Some</span>(5));
        <span class="ra" data-hover="16">assert_eq</span>!(<span class="ra" data-hover="55">counter</span>.<span class="ra" data-hover="17">next</span>(), <span class="ra" data-hover="19">None</span>);
    }
<span class="boring">}
</span><span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-22: Testing the functionality of the <code>next</code>
method implementation</span></p>
<p>This test creates a new <code>Counter</code> instance in the <code>counter</code> variable and then
calls <code>next</code> repeatedly, verifying that we have implemented the behavior we
want this iterator to have: returning the values from 1 to 5.</p>
<h4 id="using-other-iterator-trait-methods"><a class="header" href="#using-other-iterator-trait-methods">Using Other <code>Iterator</code> Trait Methods</a></h4>
<p>We implemented the <code>Iterator</code> trait by defining the <code>next</code> method, so we
can now use any <code>Iterator</code> trait method’s default implementations as defined in
the standard library, because they all use the <code>next</code> method’s functionality.</p>
<p>For example, if for some reason we wanted to take the values produced by an
instance of <code>Counter</code>, pair them with values produced by another <code>Counter</code>
instance after skipping the first value, multiply each pair together, keep only
those results that are divisible by 3, and add all the resulting values
together, we could do so, as shown in the test in Listing 13-23:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -> Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Counter {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&mut self) -> Option<Self::Item> {
</span><span class="boring">        if self.count < 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn calling_next_directly() {
</span><span class="boring">        let mut counter = Counter::new();
</span><span class="boring">
</span><span class="boring">        assert_eq!(counter.next(), Some(1));
</span><span class="boring">        assert_eq!(counter.next(), Some(2));
</span><span class="boring">        assert_eq!(counter.next(), Some(3));
</span><span class="boring">        assert_eq!(counter.next(), Some(4));
</span><span class="boring">        assert_eq!(counter.next(), Some(5));
</span><span class="boring">        assert_eq!(counter.next(), None);
</span><span class="boring">    }
</span><span class="boring">
</span>    #[<span class="ra" data-hover="13">test</span>]
    fn <span class="ra" data-hover="56">using_other_iterator_trait_methods</span>() {
        let <span class="ra" data-hover="57">sum</span>: <span class="ra" data-hover="33">u32</span> = <span class="ra" data-hover="46">Counter</span>::new()
            .<span class="ra" data-hover="58">zip</span>(<span class="ra" data-hover="46">Counter</span>::new().<span class="ra" data-hover="59">skip</span>(1))
            .<span class="ra" data-hover="25">map</span>(|(<span class="ra" data-hover="60">a</span>, <span class="ra" data-hover="61">b</span>)| <span class="ra" data-hover="60">a</span> * <span class="ra" data-hover="61">b</span>)
            .<span class="ra" data-hover="40">filter</span>(|<span class="ra" data-hover="62">x</span><span class="inlay-hint">: &amp;{unknown}</span>| <span class="ra" data-hover="62">x</span> % 3 == 0)
            .<span class="ra" data-hover="23">sum</span>();
        <span class="ra" data-hover="16">assert_eq</span>!(18, <span class="ra" data-hover="57">sum</span>);
    }
<span class="boring">}
</span><span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-23: Using a variety of <code>Iterator</code> trait
methods on our <code>Counter</code> iterator</span></p>
<p>Note that <code>zip</code> produces only four pairs; the theoretical fifth pair <code>(5, None)</code> is never produced because <code>zip</code> returns <code>None</code> when either of its input
iterators return <code>None</code>.</p>
<p>All of these method calls are possible because we specified how the <code>next</code>
method works, and the standard library provides default implementations for
other methods that call <code>next</code>.</p>
<script src="https://unpkg.com/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
<script src="https://unpkg.com/tippy.js@6.3.2/dist/tippy-bundle.umd.min.js" integrity="sha384-vApKv6LkBdPwmt/fNiQrBCVCZvuniXpG0b5UZhVrGAq1zXdZRSsPcWjGdVxkZJtX" crossorigin="anonymous"></script>
<script>
    const hoverData = ['<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn main()\n</code></pre>\n','<per><cide class="language-rust">let v1: Vec&lt;i32, Global&gt;\n</code></pre>\n','<per><cide class="language-rust">alloc\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! vec\n</code></pre>\n<hr />\n<p>Creates a <a href="crate::vec::Vec"><cide>Vec</code></a> containing the arguments.</p>\n<p><cide>vec!</code> allows <cide>Vec</code>s to be defined with the same syntax as array expressions.\nThere are two forms of this macro:</p>\n<ul>\n<li>Create a <a href="crate::vec::Vec"><cide>Vec</code></a> containing a given list of elements:</li>\n</ul>\n<per><cide>let v = vec![1, 2, 3];\nassert_eq!(v[0], 1);\nassert_eq!(v[1], 2);\nassert_eq!(v[2], 3);\n</code></pre>\n<ul>\n<li>Create a <a href="crate::vec::Vec"><cide>Vec</code></a> from a given element and size:</li>\n</ul>\n<per><cide>let v = vec![1; 3];\nassert_eq!(v, [1, 1, 1]);\n</code></pre>\n<p>Note that unlike array expressions this syntax supports all elements\nwhich implement <a href="%60Clone%60"><cide>Clone</code></a> and the number of elements doesn#$%t have to be\na constant.</p>\n<p>This will use <cide>clone</code> to duplicate an expression, so one should be careful\nusing this with types having a nonstandard <cide>Clone</code> implementation. For\nexample, <cide>vec![Rc::new(1); 5]</code> will create a vector of five references\nto the same boxed integer value, not five references pointing to independently\nboxed integers.</p>\n<p>Also, note that <cide>vec![expr; 0]</code> is allowed, and produces an empty vector.\nThis will still evaluate <cide>expr</code>, however, and immediately drop the resulting value, so\nbe mindful of side effects.</p>\n','<per><cide class="language-rust">let v1_iter: Iter&lt;i32&gt;\n</code></pre>\n','<per><cide class="language-rust">core::slice\n</code></pre>\n<per><cide class="language-rust">pub fn iter(&amp;self) -&gt; Iter&lt;#$%_, T&gt;\n</code></pre>\n<hr />\n<p>Returns an iterator over the slice.</p>\n<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>\n<per><cide>let x = &amp;[1, 2, 4];\nlet mut iterator = x.iter();\n\nassert_eq!(iterator.next(), Some(&amp;1));\nassert_eq!(iterator.next(), Some(&amp;2));\nassert_eq!(iterator.next(), Some(&amp;4));\nassert_eq!(iterator.next(), None);\n</code></pre>\n','<per><cide class="language-rust">val: &amp;i32\n</code></pre>\n','<per><cide class="language-rust">std\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! println\n</code></pre>\n<hr />\n<p>Prints to the standard output, with a newline.</p>\n<p>On all platforms, the newline is the LINE FEED character (<cide>\n</code>/<cide>U+000A</code>) alone\n(no additional CARRIAGE RETURN (<cide>\r</code>/<cide>U+000D</code>)).</p>\n<p>Use the <a href="%60format!%60"><cide>format!</code></a> syntax to write data to the standard output.\nSee <a href="crate::fmt"><cide>std::fmt</code></a> for more information.</p>\n<p>Use <cide>println!</code> only for the primary output of your program. Use\n<a href="%60eprintln!%60"><cide>eprintln!</code></a> instead to print error and progress messages.</p>\n<h1 id="panics"><a class="header" href="#panics">Panics</a></h1>\n<p>Panics if writing to <a href="crate::io::stdout"><cide>io::stdout</code></a> fails.</p>\n<h1 id="examples-1"><a class="header" href="#examples-1">Examples</a></h1>\n<per><cide>println!(); // prints just a newline\nprintln!(&quot;hello there!&quot;);\nprintln!(&quot;format {} arguments&quot;, &quot;some&quot;);\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">pub trait Iterator\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">pub type Item\n</code></pre>\n','<per><cide class="language-rust">playcrate::Iterator\n</code></pre>\n<per><cide class="language-rust">pub fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;\n</code></pre>\n','<per><cide class="language-rust">self: &amp;mut Self\n</code></pre>\n','<per><cide class="language-rust">core::option\n</code></pre>\n<per><cide class="language-rust">pub enum Option&lt;T&gt;\n</code></pre>\n<hr />\n<p>The <cide>Option</code> type. See <a href="https://docs.rs/core/*/core/option/index.html">the module level documentation</a> for more.</p>\n','<per><cide class="language-rust">Self: ?Sized\n</code></pre>\n','<per><cide class="language-rust">core\n</code></pre>\n<per><cide class="language-rust">pub macro test\n</code></pre>\n<hr />\n<p>Attribute macro applied to a function to turn it into a unit test.</p>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn iterator_demonstration()\n</code></pre>\n','<per><cide class="language-rust">let mut v1_iter: Iter&lt;i32&gt;\n</code></pre>\n','<per><cide class="language-rust">core\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! assert_eq\n</code></pre>\n<hr />\n<p>Asserts that two expressions are equal to each other (using <a href="%60PartialEq%60"><cide>PartialEq</code></a>).</p>\n<p>On panic, this macro will print the values of the expressions with their\ndebug representations.</p>\n<p>Like <a href="%60assert!%60"><cide>assert!</code></a>, this macro has a second form, where a custom\npanic message can be provided.</p>\n<h1 id="examples-2"><a class="header" href="#examples-2">Examples</a></h1>\n<per><cide>let a = 3;\nlet b = 1 + 2;\nassert_eq!(a, b);\n\nassert_eq!(a, b, &quot;we are testing addition with {} and {}&quot;, a, b);\n</code></pre>\n','<per><cide class="language-rust">core::iter::traits::iterator::Iterator\n</code></pre>\n<per><cide class="language-rust">pub fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;\n</code></pre>\n<hr />\n<p>Advances the iterator and returns the next value.</p>\n<p>Returns <a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>None</code></a> when iteration is finished. Individual iterator\nimplementations may choose to resume iteration, and so calling <cide>next()</code>\nagain may or may not eventually start returning <a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>Some(Item)</code></a> again at some\npoint.</p>\n<h1 id="examples-3"><a class="header" href="#examples-3">Examples</a></h1>\n<p>Basic usage:</p>\n<per><cide>let a = [1, 2, 3];\n\nlet mut iter = a.iter();\n\n// A call to next() returns the next value...\nassert_eq!(Some(&amp;1), iter.next());\nassert_eq!(Some(&amp;2), iter.next());\nassert_eq!(Some(&amp;3), iter.next());\n\n// ... and then None once it#$%s over.\nassert_eq!(None, iter.next());\n\n// More calls may or may not return `None`. Here, they always will.\nassert_eq!(None, iter.next());\nassert_eq!(None, iter.next());\n</code></pre>\n','<per><cide class="language-rust">core::option::Option\n</code></pre>\n<per><cide class="language-rust">Some(T)\n</code></pre>\n<hr />\n<p>Some value <cide>T</code></p>\n','<per><cide class="language-rust">core::option::Option\n</code></pre>\n<per><cide class="language-rust">None\n</code></pre>\n<hr />\n<p>No value</p>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn iterator_sum()\n</code></pre>\n','<per><cide class="language-rust">let total: i32\n</code></pre>\n','<per><cide class="language-rust">i32\n</code></pre>\n<hr />\n<p>The 32-bit signed integer type.</p>\n','<per><cide class="language-rust">core::iter::traits::iterator::Iterator\n</code></pre>\n<per><cide class="language-rust">pub fn sum&lt;S&gt;(self) -&gt; S\nwhere\n    Self: Sized,\n    S: Sum&lt;Self::Item&gt;,\n</code></pre>\n<hr />\n<p>Sums the elements of an iterator.</p>\n<p>Takes each element, adds them together, and returns the result.</p>\n<p>An empty iterator returns the zero value of the type.</p>\n<h1 id="panics-1"><a class="header" href="#panics-1">Panics</a></h1>\n<p>When calling <cide>sum()</code> and a primitive integer type is being returned, this\nmethod will panic if the computation overflows and debug assertions are\nenabled.</p>\n<h1 id="examples-4"><a class="header" href="#examples-4">Examples</a></h1>\n<p>Basic usage:</p>\n<per><cide>let a = [1, 2, 3];\nlet sum: i32 = a.iter().sum();\n\nassert_eq!(sum, 6);\n</code></pre>\n','<per><cide class="language-rust">alloc::vec\n</code></pre>\n<per><cide class="language-rust">pub struct Vec&lt;T, A = Global&gt;\nwhere\n    A: Allocator,\n</code></pre>\n<hr />\n<p>A contiguous growable array type, written as <cide>Vec&lt;T&gt;</code> and pronounced #$%vector#$%.</p>\n<h1 id="examples-5"><a class="header" href="#examples-5">Examples</a></h1>\n<per><cide>let mut vec = Vec::new();\nvec.push(1);\nvec.push(2);\n\nassert_eq!(vec.len(), 2);\nassert_eq!(vec[0], 1);\n\nassert_eq!(vec.pop(), Some(2));\nassert_eq!(vec.len(), 1);\n\nvec[0] = 7;\nassert_eq!(vec[0], 7);\n\nvec.extend([1, 2, 3].iter().copied());\n\nfor x in &amp;vec {\n    println!(&quot;{}&quot;, x);\n}\nassert_eq!(vec, [7, 1, 2, 3]);\n</code></pre>\n<p>The <a href="https://docs.rs/alloc/*/alloc/macro.vec.html"><cide>vec</code></a> macro is provided to make initialization more convenient:</p>\n<per><cide>let mut vec = vec![1, 2, 3];\nvec.push(4);\nassert_eq!(vec, [1, 2, 3, 4]);\n</code></pre>\n<p>It can also initialize each element of a <cide>Vec&lt;T&gt;</code> with a given value.\nThis may be more efficient than performing allocation and initialization\nin separate steps, especially when initializing a vector of zeros:</p>\n<per><cide>let vec = vec![0; 5];\nassert_eq!(vec, [0, 0, 0, 0, 0]);\n\n// The following is equivalent, but potentially slower:\nlet mut vec = Vec::with_capacity(5);\nvec.resize(5, 0);\nassert_eq!(vec, [0, 0, 0, 0, 0]);\n</code></pre>\n<p>For more information, see\n<a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html#capacity-and-reallocation">Capacity and Reallocation</a>.</p>\n<p>Use a <cide>Vec&lt;T&gt;</code> as an efficient stack:</p>\n<per><cide>let mut stack = Vec::new();\n\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\nwhile let Some(top) = stack.pop() {\n    // Prints 3, 2, 1\n    println!(&quot;{}&quot;, top);\n}\n</code></pre>\n<h1 id="indexing"><a class="header" href="#indexing">Indexing</a></h1>\n<p>The <cide>Vec</code> type allows to access values by index, because it implements the\n<a href="https://docs.rs/core/*/core/ops/index/trait.Index.html"><cide>Index</code></a> trait. An example will be more explicit:</p>\n<per><cide>let v = vec![0, 2, 4, 6];\nprintln!(&quot;{}&quot;, v[1]); // it will display #$%2#$%\n</code></pre>\n<p>However be careful: if you try to access an index which isn#$%t in the <cide>Vec</code>,\nyour software will panic! You cannot do this:</p>\n<per><cide class="language-should_panic">let v = vec![0, 2, 4, 6];\nprintln!(&quot;{}&quot;, v[6]); // it will panic!\n</code></pre>\n<p>Use <a href="https://docs.rs/alloc/*/std/vec/struct.Vec.html#method.get"><cide>get</code></a> and <a href="https://docs.rs/alloc/*/std/vec/struct.Vec.html#method.get_mut"><cide>get_mut</code></a> if you want to check whether the index is in\nthe <cide>Vec</code>.</p>\n<h1 id="slicing"><a class="header" href="#slicing">Slicing</a></h1>\n<p>A <cide>Vec</code> can be mutable. On the other hand, slices are read-only objects.\nTo get a <a href="https://docs.rs/core/*/core/slice/index.html">slice</a>, use <a href="%60&amp;%60"><cide>&amp;</code></a>. Example:</p>\n<per><cide>fn read_slice(slice: &amp;[usize]) {\n    // ...\n}\n\nlet v = vec![0, 1];\nread_slice(&amp;v);\n\n// ... and that#$%s all!\n// you can also do it like this:\nlet u: &amp;[usize] = &amp;v;\n// or like this:\nlet u: &amp;[_] = &amp;v;\n</code></pre>\n<p>In Rust, it#$%s more common to pass slices as arguments rather than vectors\nwhen you just want to provide read access. The same goes for <a href="https://docs.rs/alloc/*/alloc/string/struct.String.html"><cide>String</code></a> and\n<a href="type@str"><cide>&amp;str</code></a>.</p>\n<h1 id="capacity-and-reallocation"><a class="header" href="#capacity-and-reallocation">Capacity and reallocation</a></h1>\n<p>The capacity of a vector is the amount of space allocated for any future\nelements that will be added onto the vector. This is not to be confused with\nthe <em>length</em> of a vector, which specifies the number of actual elements\nwithin the vector. If a vector#$%s length exceeds its capacity, its capacity\nwill automatically be increased, but its elements will have to be\nreallocated.</p>\n<p>For example, a vector with capacity 10 and length 0 would be an empty vector\nwith space for 10 more elements. Pushing 10 or fewer elements onto the\nvector will not change its capacity or cause reallocation to occur. However,\nif the vector#$%s length is increased to 11, it will have to reallocate, which\ncan be slow. For this reason, it is recommended to use <a href="%60Vec::with_capacity%60"><cide>Vec::with_capacity</code></a>\nwhenever possible to specify how big the vector is expected to get.</p>\n<h1 id="guarantees"><a class="header" href="#guarantees">Guarantees</a></h1>\n<p>Due to its incredibly fundamental nature, <cide>Vec</code> makes a lot of guarantees\nabout its design. This ensures that it#$%s as low-overhead as possible in\nthe general case, and can be correctly manipulated in primitive ways\nby unsafe code. Note that these guarantees refer to an unqualified <cide>Vec&lt;T&gt;</code>.\nIf additional type parameters are added (e.g., to support custom allocators),\noverriding their defaults may change the behavior.</p>\n<p>Most fundamentally, <cide>Vec</code> is and always will be a (pointer, capacity, length)\ntriplet. No more, no less. The order of these fields is completely\nunspecified, and you should use the appropriate methods to modify these.\nThe pointer will never be null, so this type is null-pointer-optimized.</p>\n<p>However, the pointer might not actually point to allocated memory. In particular,\nif you construct a <cide>Vec</code> with capacity 0 via <a href="%60Vec::new%60"><cide>Vec::new</code></a>, <a href="https://docs.rs/alloc/*/alloc/macro.vec.html"><cide>vec![]</code></a>,\n<a href="%60Vec::with_capacity%60"><cide>Vec::with_capacity(0)</code></a>, or by calling <a href="Vec::shrink_to_fit"><cide>shrink_to_fit</code></a>\non an empty Vec, it will not allocate memory. Similarly, if you store zero-sized\ntypes inside a <cide>Vec</code>, it will not allocate space for them. <em>Note that in this case\nthe <cide>Vec</code> might not report a <a href="Vec::capacity"><cide>capacity</code></a> of 0</em>. <cide>Vec</code> will allocate if and only\nif <a href="https://docs.rs/core/*/core/mem/fn.size_of.html"><cide>mem::size_of::&lt;T&gt;</code></a><cide>() * capacity() &gt; 0</code>. In general, <cide>Vec</code>#$%s allocation\ndetails are very subtle — if you intend to allocate memory using a <cide>Vec</code>\nand use it for something else (either to pass to unsafe code, or to build your\nown memory-backed collection), be sure to deallocate this memory by using\n<cide>from_raw_parts</code> to recover the <cide>Vec</code> and then dropping it.</p>\n<p>If a <cide>Vec</code> <em>has</em> allocated memory, then the memory it points to is on the heap\n(as defined by the allocator Rust is configured to use by default), and its\npointer points to <a href="Vec::len"><cide>len</code></a> initialized, contiguous elements in order (what\nyou would see if you coerced it to a slice), followed by <a href="Vec::capacity"><cide>capacity</code></a><cide>-</code><a href="Vec::len"><cide>len</code></a> logically uninitialized, contiguous elements.</p>\n<p>A vector containing the elements <cide>#$%a#$%</code> and <cide>#$%b#$%</code> with capacity 4 can be\nvisualized as below. The top part is the <cide>Vec</code> struct, it contains a\npointer to the head of the allocation in the heap, length and capacity.\nThe bottom part is the allocation on the heap, a contiguous memory block.</p>\n<per><cide class="language-text">            ptr      len  capacity\n       +--------+--------+--------+\n       | 0x0123 |      2 |      4 |\n       +--------+--------+--------+\n            |\n            v\nHeap   +--------+--------+--------+--------+\n       |    #$%a#$% |    #$%b#$% | uninit | uninit |\n       +--------+--------+--------+--------+\n</code></pre>\n<ul>\n<li><strong>uninit</strong> represents memory that is not initialized, see <a href="https://docs.rs/core/*/core/mem/maybe_uninit/union.MaybeUninit.html"><cide>MaybeUninit</code></a>.</li>\n<li>Note: the ABI is not stable and <cide>Vec</code> makes no guarantees about its memory\nlayout (including the order of fields).</li>\n</ul>\n<p><cide>Vec</code> will never perform a &quot;small optimization&quot; where elements are actually\nstored on the stack for two reasons:</p>\n<ul>\n<li>\n<p>It would make it more difficult for unsafe code to correctly manipulate\na <cide>Vec</code>. The contents of a <cide>Vec</code> wouldn#$%t have a stable address if it were\nonly moved, and it would be more difficult to determine if a <cide>Vec</code> had\nactually allocated memory.</p>\n</li>\n<li>\n<p>It would penalize the general case, incurring an additional branch\non every access.</p>\n</li>\n</ul>\n<p><cide>Vec</code> will never automatically shrink itself, even if completely empty. This\nensures no unnecessary allocations or deallocations occur. Emptying a <cide>Vec</code>\nand then filling it back up to the same <a href="Vec::len"><cide>len</code></a> should incur no calls to\nthe allocator. If you wish to free up unused memory, use\n<a href="Vec::shrink_to_fit"><cide>shrink_to_fit</code></a> or <a href="Vec::shrink_to"><cide>shrink_to</code></a>.</p>\n<p><a href="Vec::push"><cide>push</code></a> and <a href="Vec::insert"><cide>insert</code></a> will never (re)allocate if the reported capacity is\nsufficient. <a href="Vec::push"><cide>push</code></a> and <a href="Vec::insert"><cide>insert</code></a> <em>will</em> (re)allocate if\n<a href="Vec::len"><cide>len</code></a><cide>==</code><a href="Vec::capacity"><cide>capacity</code></a>. That is, the reported capacity is completely\naccurate, and can be relied on. It can even be used to manually free the memory\nallocated by a <cide>Vec</code> if desired. Bulk insertion methods <em>may</em> reallocate, even\nwhen not necessary.</p>\n<p><cide>Vec</code> does not guarantee any particular growth strategy when reallocating\nwhen full, nor when <a href="Vec::reserve"><cide>reserve</code></a> is called. The current strategy is basic\nand it may prove desirable to use a non-constant growth factor. Whatever\nstrategy is used will of course guarantee <em>O</em>(1) amortized <a href="Vec::push"><cide>push</code></a>.</p>\n<p><cide>vec![x; n]</code>, <cide>vec![a, b, c, d]</code>, and\n<a href="%60Vec::with_capacity%60"><cide>Vec::with_capacity(n)</code></a>, will all produce a <cide>Vec</code>\nwith exactly the requested capacity. If <a href="Vec::len"><cide>len</code></a><cide>==</code><a href="Vec::capacity"><cide>capacity</code></a>,\n(as is the case for the <a href="https://docs.rs/alloc/*/alloc/macro.vec.html"><cide>vec</code></a> macro), then a <cide>Vec&lt;T&gt;</code> can be converted to\nand from a <a href="https://docs.rs/alloc/*/alloc/boxed/struct.Box.html"><cide>Box&lt;[T]&gt;</code></a> without reallocating or moving the elements.</p>\n<p><cide>Vec</code> will not specifically overwrite any data that is removed from it,\nbut also won#$%t specifically preserve it. Its uninitialized memory is\nscratch space that it may use however it wants. It will generally just do\nwhatever is most efficient or otherwise easy to implement. Do not rely on\nremoved data to be erased for security purposes. Even if you drop a <cide>Vec</code>, its\nbuffer may simply be reused by another <cide>Vec</code>. Even if you zero a <cide>Vec</code>#$%s memory\nfirst, that might not actually happen because the optimizer does not consider\nthis a side-effect that must be preserved. There is one case which we will\nnot break, however: using <cide>unsafe</code> code to write to the excess capacity,\nand then increasing the length to match, is always valid.</p>\n<p>Currently, <cide>Vec</code> does not guarantee the order in which elements are dropped.\nThe order has changed in the past and may change again.</p>\n','<per><cide class="language-rust">core::iter::traits::iterator::Iterator\n</code></pre>\n<per><cide class="language-rust">pub fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;\nwhere\n    Self: Sized,\n    F: FnMut&lt;(Self::Item,), Output = B&gt;,\n</code></pre>\n<hr />\n<p>Takes a closure and creates an iterator which calls that closure on each\nelement.</p>\n<p><cide>map()</code> transforms one iterator into another, by means of its argument:\nsomething that implements <a href="https://docs.rs/core/*/core/ops/function/trait.FnMut.html"><cide>FnMut</code></a>. It produces a new iterator which\ncalls this closure on each element of the original iterator.</p>\n<p>If you are good at thinking in types, you can think of <cide>map()</code> like this:\nIf you have an iterator that gives you elements of some type <cide>A</code>, and\nyou want an iterator of some other type <cide>B</code>, you can use <cide>map()</code>,\npassing a closure that takes an <cide>A</code> and returns a <cide>B</code>.</p>\n<p><cide>map()</code> is conceptually similar to a <a href="https://docs.rs/core/*/core/iter/book/ch03-05-control-flow.html#looping-through-a-collection-with-for"><cide>for</code></a> loop. However, as <cide>map()</code> is\nlazy, it is best used when you#$%re already working with other iterators.\nIf you#$%re doing some sort of looping for a side effect, it#$%s considered\nmore idiomatic to use <a href="https://docs.rs/core/*/core/iter/book/ch03-05-control-flow.html#looping-through-a-collection-with-for"><cide>for</code></a> than <cide>map()</code>.</p>\n<h1 id="examples-6"><a class="header" href="#examples-6">Examples</a></h1>\n<p>Basic usage:</p>\n<per><cide>let a = [1, 2, 3];\n\nlet mut iter = a.iter().map(|x| 2 * x);\n\nassert_eq!(iter.next(), Some(2));\nassert_eq!(iter.next(), Some(4));\nassert_eq!(iter.next(), Some(6));\nassert_eq!(iter.next(), None);\n</code></pre>\n<p>If you#$%re doing some sort of side effect, prefer <a href="https://docs.rs/core/*/core/iter/book/ch03-05-control-flow.html#looping-through-a-collection-with-for"><cide>for</code></a> to <cide>map()</code>:</p>\n<per><cide># #![allow(unused_must_use)]\n// don#$%t do this:\n(0..5).map(|x| println!(&quot;{}&quot;, x));\n\n// it won#$%t even execute, as it is lazy. Rust will warn you about this.\n\n// Instead, use for:\nfor x in 0..5 {\n    println!(&quot;{}&quot;, x);\n}\n</code></pre>\n','<per><cide class="language-rust">x: &amp;i32\n</code></pre>\n','<per><cide class="language-rust">let v2: Vec&lt;i32, Global&gt;\n</code></pre>\n','<per><cide class="language-rust">core::iter::traits::iterator::Iterator\n</code></pre>\n<per><cide class="language-rust">pub fn collect&lt;B&gt;(self) -&gt; B\nwhere\n    B: FromIterator&lt;Self::Item&gt;,\n    Self: Sized,\n</code></pre>\n<hr />\n<p>Transforms an iterator into a collection.</p>\n<p><cide>collect()</code> can take anything iterable, and turn it into a relevant\ncollection. This is one of the more powerful methods in the standard\nlibrary, used in a variety of contexts.</p>\n<p>The most basic pattern in which <cide>collect()</code> is used is to turn one\ncollection into another. You take a collection, call <a href="https://docs.rs/core/*/core/iter/traits/iterator/trait.Iterator.html#tymethod.next"><cide>iter</code></a> on it,\ndo a bunch of transformations, and then <cide>collect()</code> at the end.</p>\n<p><cide>collect()</code> can also create instances of types that are not typical\ncollections. For example, a <a href="https://docs.rs/core/*/core/iter/std/string/struct.String.html"><cide>String</code></a> can be built from <a href="type@char"><cide>char</code></a>s,\nand an iterator of <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Result&lt;T, E&gt;</code></a> items can be collected\ninto <cide>Result&lt;Collection&lt;T&gt;, E&gt;</code>. See the examples below for more.</p>\n<p>Because <cide>collect()</code> is so general, it can cause problems with type\ninference. As such, <cide>collect()</code> is one of the few times you#$%ll see\nthe syntax affectionately known as the #$%turbofish#$%: <cide>::&lt;&gt;</code>. This\nhelps the inference algorithm understand specifically which collection\nyou#$%re trying to collect into.</p>\n<h1 id="examples-7"><a class="header" href="#examples-7">Examples</a></h1>\n<p>Basic usage:</p>\n<per><cide>let a = [1, 2, 3];\n\nlet doubled: Vec&lt;i32&gt; = a.iter()\n                         .map(|&amp;x| x * 2)\n                         .collect();\n\nassert_eq!(vec![2, 4, 6], doubled);\n</code></pre>\n<p>Note that we needed the <cide>: Vec&lt;i32&gt;</code> on the left-hand side. This is because\nwe could collect into, for example, a <a href="https://docs.rs/core/*/core/iter/std/collections/struct.VecDeque.html"><cide>VecDeque&lt;T&gt;</code></a> instead:</p>\n<per><cide>use std::collections::VecDeque;\n\nlet a = [1, 2, 3];\n\nlet doubled: VecDeque&lt;i32&gt; = a.iter().map(|&amp;x| x * 2).collect();\n\nassert_eq!(2, doubled[0]);\nassert_eq!(4, doubled[1]);\nassert_eq!(6, doubled[2]);\n</code></pre>\n<p>Using the #$%turbofish#$% instead of annotating <cide>doubled</code>:</p>\n<per><cide>let a = [1, 2, 3];\n\nlet doubled = a.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;();\n\nassert_eq!(vec![2, 4, 6], doubled);\n</code></pre>\n<p>Because <cide>collect()</code> only cares about what you#$%re collecting into, you can\nstill use a partial type hint, <cide>_</code>, with the turbofish:</p>\n<per><cide>let a = [1, 2, 3];\n\nlet doubled = a.iter().map(|x| x * 2).collect::&lt;Vec&lt;_&gt;&gt;();\n\nassert_eq!(vec![2, 4, 6], doubled);\n</code></pre>\n<p>Using <cide>collect()</code> to make a <a href="https://docs.rs/core/*/core/iter/std/string/struct.String.html"><cide>String</code></a>:</p>\n<per><cide>let chars = [#$%g#$%, #$%d#$%, #$%k#$%, #$%k#$%, #$%n#$%];\n\nlet hello: String = chars.iter()\n    .map(|&amp;x| x as u8)\n    .map(|x| (x + 1) as char)\n    .collect();\n\nassert_eq!(&quot;hello&quot;, hello);\n</code></pre>\n<p>If you have a list of <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Result&lt;T, E&gt;</code></a>s, you can use <cide>collect()</code> to\nsee if any of them failed:</p>\n<per><cide>let results = [Ok(1), Err(&quot;nope&quot;), Ok(3), Err(&quot;bad&quot;)];\n\nlet result: Result&lt;Vec&lt;_&gt;, &amp;str&gt; = results.iter().cloned().collect();\n\n// gives us the first error\nassert_eq!(Err(&quot;nope&quot;), result);\n\nlet results = [Ok(1), Ok(3)];\n\nlet result: Result&lt;Vec&lt;_&gt;, &amp;str&gt; = results.iter().cloned().collect();\n\n// gives us the list of answers\nassert_eq!(Ok(vec![1, 3]), result);\n</code></pre>\n','<per><cide class="language-rust">core\n</code></pre>\n<per><cide class="language-rust">pub macro derive\n</code></pre>\n<hr />\n<p>Attribute macro used to apply derive macros.</p>\n','<per><cide class="language-rust">core\n</code></pre>\n<per><cide class="language-rust">pub macro Debug\n</code></pre>\n<hr />\n<p>Derive macro generating an impl of the trait <cide>Debug</code>.</p>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">struct Shoe\n</code></pre>\n','<per><cide class="language-rust">playcrate::Shoe\n</code></pre>\n<per><cide class="language-rust">size: u32\n</code></pre>\n','<per><cide class="language-rust">u32\n</code></pre>\n<hr />\n<p>The 32-bit unsigned integer type.</p>\n','<per><cide class="language-rust">playcrate::Shoe\n</code></pre>\n<per><cide class="language-rust">style: String\n</code></pre>\n','<per><cide class="language-rust">alloc::string\n</code></pre>\n<per><cide class="language-rust">pub struct String\n</code></pre>\n<hr />\n<p>A UTF-8–encoded, growable string.</p>\n<p>The <cide>String</code> type is the most common string type that has ownership over the\ncontents of the string. It has a close relationship with its borrowed\ncounterpart, the primitive <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>.</p>\n<h1 id="examples-8"><a class="header" href="#examples-8">Examples</a></h1>\n<p>You can create a <cide>String</code> from <a href="https://docs.rs/alloc/*/alloc/str/index.html">a literal string</a> with <a href="https://docs.rs/core/*/core/convert/trait.From.html#tymethod.from"><cide>String::from</code></a>:</p>\n<per><cide>let hello = String::from(&quot;Hello, world!&quot;);\n</code></pre>\n<p>You can append a <a href="%60char%60"><cide>char</code></a> to a <cide>String</code> with the <a href="String::push"><cide>push</code></a> method, and\nappend a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a> with the <a href="String::push_str"><cide>push_str</code></a> method:</p>\n<per><cide>let mut hello = String::from(&quot;Hello, &quot;);\n\nhello.push(#$%w#$%);\nhello.push_str(&quot;orld!&quot;);\n</code></pre>\n<p>If you have a vector of UTF-8 bytes, you can create a <cide>String</code> from it with\nthe <a href="String::from_utf8"><cide>from_utf8</code></a> method:</p>\n<per><cide>// some bytes, in a vector\nlet sparkle_heart = vec![240, 159, 146, 150];\n\n// We know these bytes are valid, so we#$%ll use `unwrap()`.\nlet sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n\nassert_eq!(&quot;💖&quot;, sparkle_heart);\n</code></pre>\n<h1 id="utf-8"><a class="header" href="#utf-8">UTF-8</a></h1>\n<p><cide>String</code>s are always valid UTF-8. This has a few implications, the first of\nwhich is that if you need a non-UTF-8 string, consider <a href="https://docs.rs/alloc/*/std/ffi/struct.OsString.html"><cide>OsString</code></a>. It is\nsimilar, but without the UTF-8 constraint. The second implication is that\nyou cannot index into a <cide>String</code>:</p>\n<per><cide class="language-compile_fail,E0277">let s = &quot;hello&quot;;\n\nprintln!(&quot;The first letter of s is {}&quot;, s[0]); // ERROR!!!\n</code></pre>\n<p>Indexing is intended to be a constant-time operation, but UTF-8 encoding\ndoes not allow us to do this. Furthermore, it#$%s not clear what sort of\nthing the index should return: a byte, a codepoint, or a grapheme cluster.\nThe <a href="str::bytes"><cide>bytes</code></a> and <a href="str::chars"><cide>chars</code></a> methods return iterators over the first\ntwo, respectively.</p>\n<h1 id="deref"><a class="header" href="#deref">Deref</a></h1>\n<p><cide>String</code>s implement <a href="https://docs.rs/core/*/core/ops/deref/trait.Deref.html"><cide>Deref</code></a><cide>&lt;Target=str&gt;</code>, and so inherit all of <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>#$%s\nmethods. In addition, this means that you can pass a <cide>String</code> to a\nfunction which takes a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a> by using an ampersand (<cide>&amp;</code>):</p>\n<per><cide>fn takes_str(s: &amp;str) { }\n\nlet s = String::from(&quot;Hello&quot;);\n\ntakes_str(&amp;s);\n</code></pre>\n<p>This will create a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a> from the <cide>String</code> and pass it in. This\nconversion is very inexpensive, and so generally, functions will accept\n<a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a>s as arguments unless they need a <cide>String</code> for some specific\nreason.</p>\n<p>In certain cases Rust doesn#$%t have enough information to make this\nconversion, known as <a href="https://docs.rs/core/*/core/ops/deref/trait.Deref.html"><cide>Deref</code></a> coercion. In the following example a string\nslice <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;#$%a str</code></a> implements the trait <cide>TraitExample</code>, and the function\n<cide>example_func</code> takes anything that implements the trait. In this case Rust\nwould need to make two implicit conversions, which Rust doesn#$%t have the\nmeans to do. For that reason, the following example will not compile.</p>\n<per><cide class="language-compile_fail,E0277">trait TraitExample {}\n\nimpl&lt;#$%a&gt; TraitExample for &amp;#$%a str {}\n\nfn example_func&lt;A: TraitExample&gt;(example_arg: A) {}\n\nlet example_string = String::from(&quot;example_string&quot;);\nexample_func(&amp;example_string);\n</code></pre>\n<p>There are two options that would work instead. The first would be to\nchange the line <cide>example_func(&amp;example_string);</code> to\n<cide>example_func(example_string.as_str());</code>, using the method <a href="String::as_str"><cide>as_str()</code></a>\nto explicitly extract the string slice containing the string. The second\nway changes <cide>example_func(&amp;example_string);</code> to\n<cide>example_func(&amp;*example_string);</code>. In this case we are dereferencing a\n<cide>String</code> to a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>, then referencing the <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a> back to\n<a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a>. The second way is more idiomatic, however both work to do the\nconversion explicitly rather than relying on the implicit conversion.</p>\n<h1 id="representation"><a class="header" href="#representation">Representation</a></h1>\n<p>A <cide>String</code> is made up of three components: a pointer to some bytes, a\nlength, and a capacity. The pointer points to an internal buffer <cide>String</code>\nuses to store its data. The length is the number of bytes currently stored\nin the buffer, and the capacity is the size of the buffer in bytes. As such,\nthe length will always be less than or equal to the capacity.</p>\n<p>This buffer is always stored on the heap.</p>\n<p>You can look at these with the <a href="str::as_ptr"><cide>as_ptr</code></a>, <a href="String::len"><cide>len</code></a>, and <a href="String::capacity"><cide>capacity</code></a>\nmethods:</p>\n<per><cide>use std::mem;\n\nlet story = String::from(&quot;Once upon a time...&quot;);\n\n// Prevent automatically dropping the String#$%s data\nlet mut story = mem::ManuallyDrop::new(story);\n\nlet ptr = story.as_mut_ptr();\nlet len = story.len();\nlet capacity = story.capacity();\n\n// story has nineteen bytes\nassert_eq!(19, len);\n\n// We can re-build a String out of ptr, len, and capacity. This is all\n// unsafe because we are responsible for making sure the components are\n// valid:\nlet s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;\n\nassert_eq!(String::from(&quot;Once upon a time...&quot;), s);\n</code></pre>\n<p>If a <cide>String</code> has enough capacity, adding elements to it will not\nre-allocate. For example, consider this program:</p>\n<per><cide>let mut s = String::new();\n\nprintln!(&quot;{}&quot;, s.capacity());\n\nfor _ in 0..5 {\n    s.push_str(&quot;hello&quot;);\n    println!(&quot;{}&quot;, s.capacity());\n}\n</code></pre>\n<p>This will output the following:</p>\n<per><cide class="language-text">0\n5\n10\n20\n20\n40\n</code></pre>\n<p>At first, we have no memory allocated at all, but as we append to the\nstring, it increases its capacity appropriately. If we instead use the\n<a href="String::with_capacity"><cide>with_capacity</code></a> method to allocate the correct capacity initially:</p>\n<per><cide>let mut s = String::with_capacity(25);\n\nprintln!(&quot;{}&quot;, s.capacity());\n\nfor _ in 0..5 {\n    s.push_str(&quot;hello&quot;);\n    println!(&quot;{}&quot;, s.capacity());\n}\n</code></pre>\n<p>We end up with a different output:</p>\n<per><cide class="language-text">25\n25\n25\n25\n25\n25\n</code></pre>\n<p>Here, there#$%s no need to allocate more memory inside the loop.</p>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt;\n</code></pre>\n','<per><cide class="language-rust">shoes: Vec&lt;Shoe, Global&gt;\n</code></pre>\n','<per><cide class="language-rust">shoe_size: u32\n</code></pre>\n','<per><cide class="language-rust">core::iter::traits::collect::IntoIterator\n</code></pre>\n<per><cide class="language-rust">pub fn into_iter(self) -&gt; Self::IntoIter\n</code></pre>\n<hr />\n<p>Creates an iterator from a value.</p>\n<p>See the <a href="https://docs.rs/core/*/core/iter/index.html">module-level documentation</a> for more.</p>\n<h1 id="examples-9"><a class="header" href="#examples-9">Examples</a></h1>\n<p>Basic usage:</p>\n<per><cide>let v = vec![1, 2, 3];\nlet mut iter = v.into_iter();\n\nassert_eq!(Some(1), iter.next());\nassert_eq!(Some(2), iter.next());\nassert_eq!(Some(3), iter.next());\nassert_eq!(None, iter.next());\n</code></pre>\n','<per><cide class="language-rust">core::iter::traits::iterator::Iterator\n</code></pre>\n<per><cide class="language-rust">pub fn filter&lt;P&gt;(self, predicate: P) -&gt; Filter&lt;Self, P&gt;\nwhere\n    Self: Sized,\n    P: FnMut&lt;(&amp;Self::Item,), Output = bool&gt;,\n</code></pre>\n<hr />\n<p>Creates an iterator which uses a closure to determine if an element\nshould be yielded.</p>\n<p>Given an element the closure must return <cide>true</code> or <cide>false</code>. The returned\niterator will yield only the elements for which the closure returns\ntrue.</p>\n<h1 id="examples-10"><a class="header" href="#examples-10">Examples</a></h1>\n<p>Basic usage:</p>\n<per><cide>let a = [0i32, 1, 2];\n\nlet mut iter = a.iter().filter(|x| x.is_positive());\n\nassert_eq!(iter.next(), Some(&amp;1));\nassert_eq!(iter.next(), Some(&amp;2));\nassert_eq!(iter.next(), None);\n</code></pre>\n<p>Because the closure passed to <cide>filter()</code> takes a reference, and many\niterators iterate over references, this leads to a possibly confusing\nsituation, where the type of the closure is a double reference:</p>\n<per><cide>let a = [0, 1, 2];\n\nlet mut iter = a.iter().filter(|x| **x &gt; 1); // need two *s!\n\nassert_eq!(iter.next(), Some(&amp;2));\nassert_eq!(iter.next(), None);\n</code></pre>\n<p>It#$%s common to instead use destructuring on the argument to strip away\none:</p>\n<per><cide>let a = [0, 1, 2];\n\nlet mut iter = a.iter().filter(|&amp;x| *x &gt; 1); // both &amp; and *\n\nassert_eq!(iter.next(), Some(&amp;2));\nassert_eq!(iter.next(), None);\n</code></pre>\n<p>or both:</p>\n<per><cide>let a = [0, 1, 2];\n\nlet mut iter = a.iter().filter(|&amp;&amp;x| x &gt; 1); // two &amp;s\n\nassert_eq!(iter.next(), Some(&amp;2));\nassert_eq!(iter.next(), None);\n</code></pre>\n<p>of these layers.</p>\n<p>Note that <cide>iter.filter(f).next()</code> is equivalent to <cide>iter.find(f)</code>.</p>\n','<per><cide class="language-rust">s: &amp;Shoe\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn filters_by_size()\n</code></pre>\n','<per><cide class="language-rust">let shoes: Vec&lt;Shoe, Global&gt;\n</code></pre>\n','<per><cide class="language-rust">core::convert::From\n</code></pre>\n<per><cide class="language-rust">pub fn from(_: T) -&gt; Self\n</code></pre>\n<hr />\n<p>Performs the conversion.</p>\n','<per><cide class="language-rust">let in_my_size: Vec&lt;Shoe, Global&gt;\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">struct Counter\n</code></pre>\n','<per><cide class="language-rust">playcrate::Counter\n</code></pre>\n<per><cide class="language-rust">count: u32\n</code></pre>\n','<per><cide class="language-rust">playcrate::Counter\n</code></pre>\n<per><cide class="language-rust">fn new() -&gt; Counter\n</code></pre>\n','<per><cide class="language-rust">core::iter::traits::iterator\n</code></pre>\n<per><cide class="language-rust">pub trait Iterator\n</code></pre>\n<hr />\n<p>An interface for dealing with iterators.</p>\n<p>This is the main iterator trait. For more about the concept of iterators\ngenerally, please see the <a href="https://docs.rs/core/*/core/iter/index.html">module-level documentation</a>. In particular, you\nmay want to know how to <a href="crate::iter#implementing-iterator">implement <cide>Iterator</code></a>.</p>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">type Item = u32\n</code></pre>\n','<per><cide class="language-rust">playcrate::Counter\n</code></pre>\n<per><cide class="language-rust">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;\n</code></pre>\n','<per><cide class="language-rust">self: &amp;mut Counter\n</code></pre>\n','<per><cide class="language-rust">core::iter::traits::iterator\n</code></pre>\n<per><cide class="language-rust">pub type Item\n</code></pre>\n<hr />\n<p>The type of the elements being iterated over.</p>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn calling_next_directly()\n</code></pre>\n','<per><cide class="language-rust">let mut counter: {unknown}\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn using_other_iterator_trait_methods()\n</code></pre>\n','<per><cide class="language-rust">let sum: u32\n</code></pre>\n','<per><cide class="language-rust">core::iter::traits::iterator::Iterator\n</code></pre>\n<per><cide class="language-rust">pub fn zip&lt;U&gt;(self, other: U) -&gt; Zip&lt;Self, U::IntoIter&gt;\nwhere\n    Self: Sized,\n    U: IntoIterator,\n</code></pre>\n<hr />\n<p>#$%Zips up#$% two iterators into a single iterator of pairs.</p>\n<p><cide>zip()</code> returns a new iterator that will iterate over two other\niterators, returning a tuple where the first element comes from the\nfirst iterator, and the second element comes from the second iterator.</p>\n<p>In other words, it zips two iterators together, into a single one.</p>\n<p>If either iterator returns <a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>None</code></a>, <a href="https://docs.rs/core/*/core/iter/traits/iterator/trait.Iterator.html#tymethod.next"><cide>next</code></a> from the zipped iterator\nwill return <a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>None</code></a>. If the first iterator returns <a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>None</code></a>, <cide>zip</code> will\nshort-circuit and <cide>next</code> will not be called on the second iterator.</p>\n<h1 id="examples-11"><a class="header" href="#examples-11">Examples</a></h1>\n<p>Basic usage:</p>\n<per><cide>let a1 = [1, 2, 3];\nlet a2 = [4, 5, 6];\n\nlet mut iter = a1.iter().zip(a2.iter());\n\nassert_eq!(iter.next(), Some((&amp;1, &amp;4)));\nassert_eq!(iter.next(), Some((&amp;2, &amp;5)));\nassert_eq!(iter.next(), Some((&amp;3, &amp;6)));\nassert_eq!(iter.next(), None);\n</code></pre>\n<p>Since the argument to <cide>zip()</code> uses <a href="https://docs.rs/core/*/core/iter/traits/collect/trait.IntoIterator.html"><cide>IntoIterator</code></a>, we can pass\nanything that can be converted into an <a href="https://docs.rs/core/*/core/iter/traits/iterator/trait.Iterator.html"><cide>Iterator</code></a>, not just an\n<a href="https://docs.rs/core/*/core/iter/traits/iterator/trait.Iterator.html"><cide>Iterator</code></a> itself. For example, slices (<cide>&amp;[T]</code>) implement\n<a href="https://docs.rs/core/*/core/iter/traits/collect/trait.IntoIterator.html"><cide>IntoIterator</code></a>, and so can be passed to <cide>zip()</code> directly:</p>\n<per><cide>let s1 = &amp;[1, 2, 3];\nlet s2 = &amp;[4, 5, 6];\n\nlet mut iter = s1.iter().zip(s2);\n\nassert_eq!(iter.next(), Some((&amp;1, &amp;4)));\nassert_eq!(iter.next(), Some((&amp;2, &amp;5)));\nassert_eq!(iter.next(), Some((&amp;3, &amp;6)));\nassert_eq!(iter.next(), None);\n</code></pre>\n<p><cide>zip()</code> is often used to zip an infinite iterator to a finite one.\nThis works because the finite iterator will eventually return <a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>None</code></a>,\nending the zipper. Zipping with <cide>(0..)</code> can look a lot like <a href="https://docs.rs/core/*/core/iter/traits/iterator/trait.Iterator.html#method.enumerate"><cide>enumerate</code></a>:</p>\n<per><cide>let enumerate: Vec&lt;_&gt; = &quot;foo&quot;.chars().enumerate().collect();\n\nlet zipper: Vec&lt;_&gt; = (0..).zip(&quot;foo&quot;.chars()).collect();\n\nassert_eq!((0, #$%f#$%), enumerate[0]);\nassert_eq!((0, #$%f#$%), zipper[0]);\n\nassert_eq!((1, #$%o#$%), enumerate[1]);\nassert_eq!((1, #$%o#$%), zipper[1]);\n\nassert_eq!((2, #$%o#$%), enumerate[2]);\nassert_eq!((2, #$%o#$%), zipper[2]);\n</code></pre>\n','<per><cide class="language-rust">core::iter::traits::iterator::Iterator\n</code></pre>\n<per><cide class="language-rust">pub fn skip(self, n: usize) -&gt; Skip&lt;Self&gt;\nwhere\n    Self: Sized,\n</code></pre>\n<hr />\n<p>Creates an iterator that skips the first <cide>n</code> elements.</p>\n<p><cide>skip(n)</code> skips elements until <cide>n</code> elements are skipped or the end of the\niterator is reached (whichever happens first). After that, all the remaining\nelements are yielded. In particular, if the original iterator is too short,\nthen the returned iterator is empty.</p>\n<p>Rather than overriding this method directly, instead override the <cide>nth</code> method.</p>\n<h1 id="examples-12"><a class="header" href="#examples-12">Examples</a></h1>\n<p>Basic usage:</p>\n<per><cide>let a = [1, 2, 3];\n\nlet mut iter = a.iter().skip(2);\n\nassert_eq!(iter.next(), Some(&amp;3));\nassert_eq!(iter.next(), None);\n</code></pre>\n','<per><cide class="language-rust">a: {unknown}\n</code></pre>\n','<per><cide class="language-rust">b: {unknown}\n</code></pre>\n','<per><cide class="language-rust">x: &amp;{unknown}\n</code></pre>\n',].map((x)=>x.replaceAll('#$%', "'").replaceAll('<per', '<pre').replaceAll('<cide', '<code'));
    window.onload = () => {
        console.log("hello");
        tippy('.ra', {
            content: (x) => {
                const div = document.createElement('div');
                div.innerHTML = hoverData[x.dataset.hover];
                div.className = 'hover-holder';
                div.querySelectorAll('code').forEach((y) => y.innerHTML = hljs.highlight('rust', y.innerText).value);
                return div;
            },
            allowHTML: true,
            delay: [200, 0],
            interactive: true,
            maxWidth: '80vw',
            appendTo: document.querySelector('.content'),
        });
    };
</script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="ch13-01-closures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="ch13-03-improving-our-io-project.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="ch13-01-closures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="ch13-03-improving-our-io-project.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="ferris.js"></script>
        
        
    </body>
</html>
