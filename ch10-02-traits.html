<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Traits: Defining Shared Behavior - The Rust Programming Language</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="ferris.css">
                <link rel="stylesheet" href="theme/2018-edition.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References and Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> The Slice Type</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html" class="active"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> How to Write Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlling How Tests Are Run</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.inlay-hint, .inlay-hint * {
    border-radius: .4em;
}

.light .inlay-hint, .rust .inlay-hint {
    background-color: #dcc;
    color: #777;
}

.ayu .inlay-hint, .navy .inlay-hint, .coal .inlay-hint {
    background-color: #444;
    color: #999;
}

.inlay-hint {
    font-size: 0.8em;
    user-select: none;
}
.hover-holder {
    max-height: 40vh;
    overflow: auto;
}

.tippy-content {
    background-color: var(--bg);
    color: var(--fg);
}
</style>## Traits: Defining Shared Behavior
<p>A <em>trait</em> tells the Rust compiler about functionality a particular type has and
can share with other types. We can use traits to define shared behavior in an
abstract way. We can use trait bounds to specify that a generic type can be any
type that has certain behavior.</p>
<blockquote>
<p>Note: Traits are similar to a feature often called <em>interfaces</em> in other
languages, although with some differences.</p>
</blockquote>
<h3 id="defining-a-trait"><a class="header" href="#defining-a-trait">Defining a Trait</a></h3>
<p>A type’s behavior consists of the methods we can call on that type. Different
types share the same behavior if we can call the same methods on all of those
types. Trait definitions are a way to group method signatures together to
define a set of behaviors necessary to accomplish some purpose.</p>
<p>For example, let’s say we have multiple structs that hold various kinds and
amounts of text: a <code>NewsArticle</code> struct that holds a news story filed in a
particular location and a <code>Tweet</code> that can have at most 280 characters along
with metadata that indicates whether it was a new tweet, a retweet, or a reply
to another tweet.</p>
<p>We want to make a media aggregator library that can display summaries of data
that might be stored in a <code>NewsArticle</code> or <code>Tweet</code> instance. To do this, we
need a summary from each type, and we need to request that summary by calling a
<code>summarize</code> method on an instance. Listing 10-12 shows the definition of a
<code>Summary</code> trait that expresses this behavior.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait <span class="ra" data-hover="1">Summary</span> {
    fn <span class="ra" data-hover="2">summarize</span>(&amp;<span class="ra" data-hover="3">self</span>) -&gt; <span class="ra" data-hover="4">String</span>;
}
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 10-12: A <code>Summary</code> trait that consists of the
behavior provided by a <code>summarize</code> method</span></p>
<p>Here, we declare a trait using the <code>trait</code> keyword and then the trait’s name,
which is <code>Summary</code> in this case. Inside the curly brackets, we declare the
method signatures that describe the behaviors of the types that implement this
trait, which in this case is <code>fn summarize(&amp;self) -&gt; String</code>.</p>
<p>After the method signature, instead of providing an implementation within curly
brackets, we use a semicolon. Each type implementing this trait must provide
its own custom behavior for the body of the method. The compiler will enforce
that any type that has the <code>Summary</code> trait will have the method <code>summarize</code>
defined with this signature exactly.</p>
<p>A trait can have multiple methods in its body: the method signatures are listed
one per line and each line ends in a semicolon.</p>
<h3 id="implementing-a-trait-on-a-type"><a class="header" href="#implementing-a-trait-on-a-type">Implementing a Trait on a Type</a></h3>
<p>Now that we’ve defined the desired behavior using the <code>Summary</code> trait, we can
implement it on the types in our media aggregator. Listing 10-13 shows an
implementation of the <code>Summary</code> trait on the <code>NewsArticle</code> struct that uses the
headline, the author, and the location to create the return value of
<code>summarize</code>. For the <code>Tweet</code> struct, we define <code>summarize</code> as the username
followed by the entire text of the tweet, assuming that tweet content is
already limited to 280 characters.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&self) -> String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct <span class="ra" data-hover="5">NewsArticle</span> {
    pub <span class="ra" data-hover="6">headline</span>: <span class="ra" data-hover="4">String</span>,
    pub <span class="ra" data-hover="7">location</span>: <span class="ra" data-hover="4">String</span>,
    pub <span class="ra" data-hover="8">author</span>: <span class="ra" data-hover="4">String</span>,
    pub <span class="ra" data-hover="9">content</span>: <span class="ra" data-hover="4">String</span>,
}

impl <span class="ra" data-hover="1">Summary</span> for <span class="ra" data-hover="5">NewsArticle</span> {
    fn <span class="ra" data-hover="10">summarize</span>(&amp;<span class="ra" data-hover="11">self</span>) -&gt; <span class="ra" data-hover="4">String</span> {
        <span class="ra" data-hover="12">format</span>!("{}, by {} ({})", <span class="ra" data-hover="11">self</span>.<span class="ra" data-hover="6">headline</span>, <span class="ra" data-hover="11">self</span>.<span class="ra" data-hover="8">author</span>, <span class="ra" data-hover="11">self</span>.<span class="ra" data-hover="7">location</span>)
    }
}

pub struct <span class="ra" data-hover="13">Tweet</span> {
    pub <span class="ra" data-hover="14">username</span>: <span class="ra" data-hover="4">String</span>,
    pub <span class="ra" data-hover="15">content</span>: <span class="ra" data-hover="4">String</span>,
    pub <span class="ra" data-hover="16">reply</span>: <span class="ra" data-hover="17">bool</span>,
    pub <span class="ra" data-hover="18">retweet</span>: <span class="ra" data-hover="17">bool</span>,
}

impl <span class="ra" data-hover="1">Summary</span> for <span class="ra" data-hover="13">Tweet</span> {
    fn <span class="ra" data-hover="19">summarize</span>(&amp;<span class="ra" data-hover="20">self</span>) -&gt; <span class="ra" data-hover="4">String</span> {
        <span class="ra" data-hover="12">format</span>!("{}: {}", <span class="ra" data-hover="20">self</span>.<span class="ra" data-hover="14">username</span>, <span class="ra" data-hover="20">self</span>.<span class="ra" data-hover="15">content</span>)
    }
}
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 10-13: Implementing the <code>Summary</code> trait on the
<code>NewsArticle</code> and <code>Tweet</code> types</span></p>
<p>Implementing a trait on a type is similar to implementing regular methods. The
difference is that after <code>impl</code>, we put the trait name that we want to
implement, then use the <code>for</code> keyword, and then specify the name of the type we
want to implement the trait for. Within the <code>impl</code> block, we put the method
signatures that the trait definition has defined. Instead of adding a semicolon
after each signature, we use curly brackets and fill in the method body with
the specific behavior that we want the methods of the trait to have for the
particular type.</p>
<p>After implementing the trait, we can call the methods on instances of
<code>NewsArticle</code> and <code>Tweet</code> in the same way we call regular methods, like this:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">use chapter10::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let <span class="ra" data-hover="21">tweet</span> = Tweet {
        username: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="22">from</span>("horse_ebooks"),
        content: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="22">from</span>(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    <span class="ra" data-hover="23">println</span>!("1 new tweet: {}", <span class="ra" data-hover="21">tweet</span>.summarize());
<span class="boring">}
</span>
</code></pre></pre>
<p>This code prints <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>.</p>
<p>Note that because we defined the <code>Summary</code> trait and the <code>NewsArticle</code> and
<code>Tweet</code> types in the same <em>lib.rs</em> in Listing 10-13, they’re all in the same
scope. Let’s say this <em>lib.rs</em> is for a crate we’ve called <code>aggregator</code> and
someone else wants to use our crate’s functionality to implement the <code>Summary</code>
trait on a struct defined within their library’s scope. They would need to
bring the trait into their scope first. They would do so by specifying <code>use aggregator::Summary;</code>, which then would enable them to implement <code>Summary</code> for
their type. The <code>Summary</code> trait would also need to be a public trait for
another crate to implement it, which it is because we put the <code>pub</code> keyword
before <code>trait</code> in Listing 10-12.</p>
<p>One restriction to note with trait implementations is that we can implement a
trait on a type only if either the trait or the type is local to our crate.
For example, we can implement standard library traits like <code>Display</code> on a
custom type like <code>Tweet</code> as part of our <code>aggregator</code> crate functionality,
because the type <code>Tweet</code> is local to our <code>aggregator</code> crate. We can also
implement <code>Summary</code> on <code>Vec&lt;T&gt;</code> in our <code>aggregator</code> crate, because the
trait <code>Summary</code> is local to our <code>aggregator</code> crate.</p>
<p>But we can’t implement external traits on external types. For example, we can’t
implement the <code>Display</code> trait on <code>Vec&lt;T&gt;</code> within our <code>aggregator</code> crate,
because <code>Display</code> and <code>Vec&lt;T&gt;</code> are defined in the standard library and aren’t
local to our <code>aggregator</code> crate. This restriction is part of a property of
programs called <em>coherence</em>, and more specifically the <em>orphan rule</em>, so named
because the parent type is not present. This rule ensures that other people’s
code can’t break your code and vice versa. Without the rule, two crates could
implement the same trait for the same type, and Rust wouldn’t know which
implementation to use.</p>
<h3 id="default-implementations"><a class="header" href="#default-implementations">Default Implementations</a></h3>
<p>Sometimes it’s useful to have default behavior for some or all of the methods
in a trait instead of requiring implementations for all methods on every type.
Then, as we implement the trait on a particular type, we can keep or override
each method’s default behavior.</p>
<p>Listing 10-14 shows how to specify a default string for the <code>summarize</code> method
of the <code>Summary</code> trait instead of only defining the method signature, as we did
in Listing 10-12.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait <span class="ra" data-hover="1">Summary</span> {
    fn <span class="ra" data-hover="2">summarize</span>(&amp;<span class="ra" data-hover="3">self</span>) -&gt; <span class="ra" data-hover="4">String</span> {
        <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="22">from</span>("(Read more...)")
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&self) -> String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 10-14: Definition of a <code>Summary</code> trait with a
default implementation of the <code>summarize</code> method</span></p>
<p>To use a default implementation to summarize instances of <code>NewsArticle</code> instead
of defining a custom implementation, we specify an empty <code>impl</code> block with
<code>impl Summary for NewsArticle {}</code>.</p>
<p>Even though we’re no longer defining the <code>summarize</code> method on <code>NewsArticle</code>
directly, we’ve provided a default implementation and specified that
<code>NewsArticle</code> implements the <code>Summary</code> trait. As a result, we can still call
the <code>summarize</code> method on an instance of <code>NewsArticle</code>, like this:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">use chapter10::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let <span class="ra" data-hover="24">article</span> = NewsArticle {
        headline: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="22">from</span>("Penguins win the Stanley Cup Championship!"),
        location: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="22">from</span>("Pittsburgh, PA, USA"),
        author: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="22">from</span>("Iceburgh"),
        content: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="22">from</span>(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    <span class="ra" data-hover="23">println</span>!("New article available! {}", <span class="ra" data-hover="24">article</span>.summarize());
<span class="boring">}
</span>
</code></pre></pre>
<p>This code prints <code>New article available! (Read more...)</code>.</p>
<p>Creating a default implementation for <code>summarize</code> doesn’t require us to change
anything about the implementation of <code>Summary</code> on <code>Tweet</code> in Listing 10-13. The
reason is that the syntax for overriding a default implementation is the same
as the syntax for implementing a trait method that doesn’t have a default
implementation.</p>
<p>Default implementations can call other methods in the same trait, even if those
other methods don’t have a default implementation. In this way, a trait can
provide a lot of useful functionality and only require implementors to specify
a small part of it. For example, we could define the <code>Summary</code> trait to have a
<code>summarize_author</code> method whose implementation is required, and then define a
<code>summarize</code> method that has a default implementation that calls the
<code>summarize_author</code> method:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait <span class="ra" data-hover="1">Summary</span> {
    fn <span class="ra" data-hover="25">summarize_author</span>(&amp;<span class="ra" data-hover="3">self</span>) -&gt; <span class="ra" data-hover="4">String</span>;

    fn <span class="ra" data-hover="2">summarize</span>(&amp;<span class="ra" data-hover="3">self</span>) -&gt; <span class="ra" data-hover="4">String</span> {
        <span class="ra" data-hover="12">format</span>!("(Read more from {}...)", <span class="ra" data-hover="3">self</span>.<span class="ra" data-hover="25">summarize_author</span>())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize_author(&self) -> String {
</span><span class="boring">        format!("@{}", self.username)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span>
</code></pre></pre>
<p>To use this version of <code>Summary</code>, we only need to define <code>summarize_author</code>
when we implement the trait on a type:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&self) -> String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&self) -> String {
</span><span class="boring">        format!("(Read more from {}...)", self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl <span class="ra" data-hover="1">Summary</span> for <span class="ra" data-hover="13">Tweet</span> {
    fn <span class="ra" data-hover="26">summarize_author</span>(&amp;<span class="ra" data-hover="20">self</span>) -&gt; <span class="ra" data-hover="4">String</span> {
        <span class="ra" data-hover="12">format</span>!("@{}", <span class="ra" data-hover="20">self</span>.<span class="ra" data-hover="14">username</span>)
    }
}
<span class="boring">}
</span>
</code></pre></pre>
<p>After we define <code>summarize_author</code>, we can call <code>summarize</code> on instances of the
<code>Tweet</code> struct, and the default implementation of <code>summarize</code> will call the
definition of <code>summarize_author</code> that we’ve provided. Because we’ve implemented
<code>summarize_author</code>, the <code>Summary</code> trait has given us the behavior of the
<code>summarize</code> method without requiring us to write any more code.</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">use chapter10::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let <span class="ra" data-hover="21">tweet</span> = Tweet {
        username: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="22">from</span>("horse_ebooks"),
        content: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="22">from</span>(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    <span class="ra" data-hover="23">println</span>!("1 new tweet: {}", <span class="ra" data-hover="21">tweet</span>.summarize());
<span class="boring">}
</span>
</code></pre></pre>
<p>This code prints <code>1 new tweet: (Read more from @horse_ebooks...)</code>.</p>
<p>Note that it isn’t possible to call the default implementation from an
overriding implementation of that same method.</p>
<h3 id="traits-as-parameters"><a class="header" href="#traits-as-parameters">Traits as Parameters</a></h3>
<p>Now that you know how to define and implement traits, we can explore how to use
traits to define functions that accept many different types.</p>
<p>For example, in Listing 10-13, we implemented the <code>Summary</code> trait on the
<code>NewsArticle</code> and <code>Tweet</code> types. We can define a <code>notify</code> function that calls
the <code>summarize</code> method on its <code>item</code> parameter, which is of some type that
implements the <code>Summary</code> trait. To do this, we can use the <code>impl Trait</code>
syntax, like this:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&self) -> String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&self) -> String {
</span><span class="boring">        format!("{}, by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&self) -> String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn <span class="ra" data-hover="27">notify</span>(<span class="ra" data-hover="28">item</span>: &amp;impl <span class="ra" data-hover="1">Summary</span>) {
    <span class="ra" data-hover="23">println</span>!("Breaking news! {}", <span class="ra" data-hover="28">item</span>.<span class="ra" data-hover="2">summarize</span>());
}
<span class="boring">}
</span>
</code></pre></pre>
<p>Instead of a concrete type for the <code>item</code> parameter, we specify the <code>impl</code>
keyword and the trait name. This parameter accepts any type that implements the
specified trait. In the body of <code>notify</code>, we can call any methods on <code>item</code>
that come from the <code>Summary</code> trait, such as <code>summarize</code>. We can call <code>notify</code>
and pass in any instance of <code>NewsArticle</code> or <code>Tweet</code>. Code that calls the
function with any other type, such as a <code>String</code> or an <code>i32</code>, won’t compile
because those types don’t implement <code>Summary</code>.</p>
<h4 id="trait-bound-syntax"><a class="header" href="#trait-bound-syntax">Trait Bound Syntax</a></h4>
<p>The <code>impl Trait</code> syntax works for straightforward cases but is actually
syntax sugar for a longer form, which is called a <em>trait bound</em>; it looks like
this:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn <span class="ra" data-hover="29">notify</span>&lt;<span class="ra" data-hover="30">T</span>: Summary&gt;(<span class="ra" data-hover="31">item</span>: &amp;<span class="ra" data-hover="30">T</span>) {
    <span class="ra" data-hover="23">println</span>!("Breaking news! {}", <span class="ra" data-hover="31">item</span>.summarize());
}
<span class="boring">}
</span>
</code></pre></pre>
<p>This longer form is equivalent to the example in the previous section but is
more verbose. We place trait bounds with the declaration of the generic type
parameter after a colon and inside angle brackets.</p>
<p>The <code>impl Trait</code> syntax is convenient and makes for more concise code in simple
cases. The trait bound syntax can express more complexity in other cases. For
example, we can have two parameters that implement <code>Summary</code>. Using the <code>impl Trait</code> syntax looks like this:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn <span class="ra" data-hover="32">notify</span>(<span class="ra" data-hover="33">item1</span>: &amp;impl Summary, <span class="ra" data-hover="34">item2</span>: &amp;impl Summary) {
<span class="boring">}
</span>
</code></pre></pre>
<p>If we wanted this function to allow <code>item1</code> and <code>item2</code> to have different
types, using <code>impl Trait</code> would be appropriate (as long as both types implement
<code>Summary</code>). If we wanted to force both parameters to have the same type, that’s
only possible to express using a trait bound, like this:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn <span class="ra" data-hover="35">notify</span>&lt;<span class="ra" data-hover="30">T</span>: Summary&gt;(<span class="ra" data-hover="36">item1</span>: &amp;<span class="ra" data-hover="30">T</span>, <span class="ra" data-hover="37">item2</span>: &amp;<span class="ra" data-hover="30">T</span>) {
<span class="boring">}
</span>
</code></pre></pre>
<p>The generic type <code>T</code> specified as the type of the <code>item1</code> and <code>item2</code>
parameters constrains the function such that the concrete type of the value
passed as an argument for <code>item1</code> and <code>item2</code> must be the same.</p>
<h4 id="specifying-multiple-trait-bounds-with-the--syntax"><a class="header" href="#specifying-multiple-trait-bounds-with-the--syntax">Specifying Multiple Trait Bounds with the <code>+</code> Syntax</a></h4>
<p>We can also specify more than one trait bound. Say we wanted <code>notify</code> to use
display formatting on <code>item</code> as well as the <code>summarize</code> method: we specify in
the <code>notify</code> definition that <code>item</code> must implement both <code>Display</code> and
<code>Summary</code>. We can do so using the <code>+</code> syntax:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn <span class="ra" data-hover="38">notify</span>(<span class="ra" data-hover="39">item</span>: &amp;(impl Summary + Display)) {
<span class="boring">}
</span>
</code></pre></pre>
<p>The <code>+</code> syntax is also valid with trait bounds on generic types:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn <span class="ra" data-hover="40">notify</span>&lt;<span class="ra" data-hover="30">T</span>: Summary + Display&gt;(<span class="ra" data-hover="31">item</span>: &amp;<span class="ra" data-hover="30">T</span>) {
<span class="boring">}
</span>
</code></pre></pre>
<p>With the two trait bounds specified, the body of <code>notify</code> can call <code>summarize</code>
and use <code>{}</code> to format <code>item</code>.</p>
<h4 id="clearer-trait-bounds-with-where-clauses"><a class="header" href="#clearer-trait-bounds-with-where-clauses">Clearer Trait Bounds with <code>where</code> Clauses</a></h4>
<p>Using too many trait bounds has its downsides. Each generic has its own trait
bounds, so functions with multiple generic type parameters can contain lots of
trait bound information between the function’s name and its parameter list,
making the function signature hard to read. For this reason, Rust has alternate
syntax for specifying trait bounds inside a <code>where</code> clause after the function
signature. So instead of writing this:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn <span class="ra" data-hover="41">some_function</span>&lt;<span class="ra" data-hover="42">T</span>: Display + <span class="ra" data-hover="43">Clone</span>, <span class="ra" data-hover="44">U</span>: <span class="ra" data-hover="43">Clone</span> + <span class="ra" data-hover="45">Debug</span>&gt;(<span class="ra" data-hover="46">t</span>: &amp;<span class="ra" data-hover="42">T</span>, <span class="ra" data-hover="47">u</span>: &amp;<span class="ra" data-hover="44">U</span>) -&gt; <span class="ra" data-hover="48">i32</span> {
<span class="boring">}
</span>
</code></pre></pre>
<p>we can use a <code>where</code> clause, like this:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn <span class="ra" data-hover="41">some_function</span>&lt;<span class="ra" data-hover="42">T</span>, <span class="ra" data-hover="44">U</span>&gt;(<span class="ra" data-hover="46">t</span>: &amp;<span class="ra" data-hover="42">T</span>, <span class="ra" data-hover="47">u</span>: &amp;<span class="ra" data-hover="44">U</span>) -&gt; <span class="ra" data-hover="48">i32
    where <span class="ra" data-hover="42">T</span>: Display + <span class="ra" data-hover="43">Clone</span>,
          <span class="ra" data-hover="44">U</span>: <span class="ra" data-hover="43">Clone</span> + <span class="ra" data-hover="45">Debug
{
<span class="boring">}
</span>
</code></pre></pre>
<p>This function’s signature is less cluttered: the function name, parameter list,
and return type are close together, similar to a function without lots of trait
bounds.</p>
<h3 id="returning-types-that-implement-traits"><a class="header" href="#returning-types-that-implement-traits">Returning Types that Implement Traits</a></h3>
<p>We can also use the <code>impl Trait</code> syntax in the return position to return a
value of some type that implements a trait, as shown here:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&self) -> String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&self) -> String {
</span><span class="boring">        format!("{}, by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&self) -> String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn <span class="ra" data-hover="49">returns_summarizable</span>() -&gt; impl <span class="ra" data-hover="1">Summary</span> {
    <span class="ra" data-hover="13">Tweet</span> {
        <span class="ra" data-hover="14">username</span>: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="22">from</span>("horse_ebooks"),
        <span class="ra" data-hover="15">content</span>: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="22">from</span>(
            "of course, as you probably already know, people",
        ),
        <span class="ra" data-hover="16">reply</span>: false,
        <span class="ra" data-hover="18">retweet</span>: false,
    }
}
<span class="boring">}
</span>
</code></pre></pre>
<p>By using <code>impl Summary</code> for the return type, we specify that the
<code>returns_summarizable</code> function returns some type that implements the <code>Summary</code>
trait without naming the concrete type. In this case, <code>returns_summarizable</code>
returns a <code>Tweet</code>, but the code calling this function doesn’t know that.</p>
<p>The ability to return a type that is only specified by the trait it implements
is especially useful in the context of closures and iterators, which we cover
in Chapter 13. Closures and iterators create types that only the compiler knows
or types that are very long to specify. The <code>impl Trait</code> syntax lets you
concisely specify that a function returns some type that implements the
<code>Iterator</code> trait without needing to write out a very long type.</p>
<p>However, you can only use <code>impl Trait</code> if you’re returning a single type. For
example, this code that returns either a <code>NewsArticle</code> or a <code>Tweet</code> with the
return type specified as <code>impl Summary</code> wouldn’t work:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&self) -> String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&self) -> String {
</span><span class="boring">        format!("{}, by {} ({})", self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&self) -> String {
</span><span class="boring">        format!("{}: {}", self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn <span class="ra" data-hover="50">returns_summarizable</span>(<span class="ra" data-hover="51">switch</span>: <span class="ra" data-hover="17">bool</span>) -&gt; impl <span class="ra" data-hover="1">Summary</span> {
    if <span class="ra" data-hover="51">switch</span> {
        <span class="ra" data-hover="5">NewsArticle</span> {
            <span class="ra" data-hover="6">headline</span>: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="22">from</span>(
                "Penguins win the Stanley Cup Championship!",
            ),
            <span class="ra" data-hover="7">location</span>: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="22">from</span>("Pittsburgh, PA, USA"),
            <span class="ra" data-hover="8">author</span>: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="22">from</span>("Iceburgh"),
            <span class="ra" data-hover="9">content</span>: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="22">from</span>(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        <span class="ra" data-hover="13">Tweet</span> {
            <span class="ra" data-hover="14">username</span>: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="22">from</span>("horse_ebooks"),
            <span class="ra" data-hover="15">content</span>: <span class="ra" data-hover="4">String</span>::<span class="ra" data-hover="22">from</span>(
                "of course, as you probably already know, people",
            ),
            <span class="ra" data-hover="16">reply</span>: false,
            <span class="ra" data-hover="18">retweet</span>: false,
        }
    }
}
<span class="boring">}
</span>
</code></pre></pre>
<p>Returning either a <code>NewsArticle</code> or a <code>Tweet</code> isn’t allowed due to restrictions
around how the <code>impl Trait</code> syntax is implemented in the compiler. We’ll cover
how to write a function with this behavior in the <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“Using Trait Objects That
Allow for Values of Different
Types”</a><!--
ignore --> section of Chapter 17.</p>
<h3 id="fixing-the-largest-function-with-trait-bounds"><a class="header" href="#fixing-the-largest-function-with-trait-bounds">Fixing the <code>largest</code> Function with Trait Bounds</a></h3>
<p>Now that you know how to specify the behavior you want to use using the generic
type parameter’s bounds, let’s return to Listing 10-5 to fix the definition of
the <code>largest</code> function that uses a generic type parameter! Last time we tried
to run that code, we received this error:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {
  |             ^^^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>In the body of <code>largest</code> we wanted to compare two values of type <code>T</code> using the
greater than (<code>&gt;</code>) operator. Because that operator is defined as a default
method on the standard library trait <code>std::cmp::PartialOrd</code>, we need to specify
<code>PartialOrd</code> in the trait bounds for <code>T</code> so the <code>largest</code> function can work on
slices of any type that we can compare. We don’t need to bring <code>PartialOrd</code>
into scope because it’s in the prelude. Change the signature of <code>largest</code> to
look like this:</p>
<pre><pre class="playground"><code class="language-rust hljs">fn <span class="ra" data-hover="52">largest</span>&lt;<span class="ra" data-hover="53">T</span>: <span class="ra" data-hover="54">PartialOrd</span>&gt;(<span class="ra" data-hover="55">list</span>: &amp;[<span class="ra" data-hover="53">T</span>]) -&gt; <span class="ra" data-hover="53">T</span> {
<span class="boring">    let mut largest = list[0];
</span><span class="boring">
</span><span class="boring">    for &item in list {
</span><span class="boring">        if item > largest {
</span><span class="boring">            largest = item;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    largest
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let number_list = vec![34, 50, 25, 100, 65];
</span><span class="boring">
</span><span class="boring">    let result = largest(&number_list);
</span><span class="boring">    println!("The largest number is {}", result);
</span><span class="boring">
</span><span class="boring">    let char_list = vec!['y', 'm', 'a', 'q'];
</span><span class="boring">
</span><span class="boring">    let result = largest(&char_list);
</span><span class="boring">    println!("The largest char is {}", result);
</span><span class="boring">}
</span>
</code></pre></pre>
<p>This time when we compile the code, we get a different set of errors:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       help: consider borrowing here: `&amp;list[0]`

error[E0507]: cannot move out of a shared reference
 --&gt; src/main.rs:4:18
  |
4 |     for &amp;item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&amp;`: `item`

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10` due to 2 previous errors
</code></pre>
<p>The key line in this error is <code>cannot move out of type [T], a non-copy slice</code>.
With our non-generic versions of the <code>largest</code> function, we were only trying to
find the largest <code>i32</code> or <code>char</code>. As discussed in the <a href="ch04-01-what-is-ownership.html#stack-only-data-copy">“Stack-Only Data:
Copy”</a><!-- ignore --> section in Chapter 4, types like
<code>i32</code> and <code>char</code> that have a known size can be stored on the stack, so they
implement the <code>Copy</code> trait. But when we made the <code>largest</code> function generic,
it became possible for the <code>list</code> parameter to have types in it that don’t
implement the <code>Copy</code> trait. Consequently, we wouldn’t be able to move the
value out of <code>list[0]</code> and into the <code>largest</code> variable, resulting in this
error.</p>
<p>To call this code with only those types that implement the <code>Copy</code> trait, we can
add <code>Copy</code> to the trait bounds of <code>T</code>! Listing 10-15 shows the complete code of
a generic <code>largest</code> function that will compile as long as the types of the
values in the slice that we pass into the function implement the <code>PartialOrd</code>
<em>and</em> <code>Copy</code> traits, like <code>i32</code> and <code>char</code> do.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn <span class="ra" data-hover="63">largest</span>&lt;<span class="ra" data-hover="64">T</span>: <span class="ra" data-hover="54">PartialOrd</span> + <span class="ra" data-hover="65">Copy</span>&gt;(<span class="ra" data-hover="55">list</span>: &amp;[<span class="ra" data-hover="64">T</span>]) -&gt; <span class="ra" data-hover="64">T</span> {
    let mut <span class="ra" data-hover="56">largest</span><span class="inlay-hint">: T</span> = <span class="ra" data-hover="55">list</span>[0];

    for &amp;<span class="ra" data-hover="57">item</span><span class="inlay-hint">: T</span> in <span class="ra" data-hover="55">list</span> {
        if <span class="ra" data-hover="57">item</span> &gt; <span class="ra" data-hover="56">largest</span> {
            <span class="ra" data-hover="56">largest</span> = <span class="ra" data-hover="57">item</span>;
        }
    }

    <span class="ra" data-hover="56">largest
}

fn <span class="ra" data-hover="0">main</span>() {
    let <span class="ra" data-hover="58">number_list</span><span class="inlay-hint">: Vec&lt;i32&gt;</span> = <span class="ra" data-hover="59">vec</span>![34, 50, 25, 100, 65];

    let <span class="ra" data-hover="60">result</span><span class="inlay-hint">: i32</span> = <span class="ra" data-hover="63">largest</span>(&amp;<span class="ra" data-hover="58">number_list</span>);
    <span class="ra" data-hover="23">println</span>!("The largest number is {}", <span class="ra" data-hover="60">result</span>);

    let <span class="ra" data-hover="61">char_list</span><span class="inlay-hint">: Vec&lt;char&gt;</span> = <span class="ra" data-hover="59">vec</span>!['y', 'm', 'a', 'q'];

    let <span class="ra" data-hover="62">result</span><span class="inlay-hint">: char</span> = <span class="ra" data-hover="63">largest</span>(&amp;<span class="ra" data-hover="61">char_list</span>);
    <span class="ra" data-hover="23">println</span>!("The largest char is {}", <span class="ra" data-hover="62">result</span>);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-15: A working definition of the <code>largest</code>
function that works on any generic type that implements the <code>PartialOrd</code> and
<code>Copy</code> traits</span></p>
<p>If we don’t want to restrict the <code>largest</code> function to the types that implement
the <code>Copy</code> trait, we could specify that <code>T</code> has the trait bound <code>Clone</code> instead
of <code>Copy</code>. Then we could clone each value in the slice when we want the
<code>largest</code> function to have ownership. Using the <code>clone</code> function means we’re
potentially making more heap allocations in the case of types that own heap
data like <code>String</code>, and heap allocations can be slow if we’re working with
large amounts of data.</p>
<p>Another way we could implement <code>largest</code> is for the function to return a
reference to a <code>T</code> value in the slice. If we change the return type to <code>&amp;T</code>
instead of <code>T</code>, thereby changing the body of the function to return a
reference, we wouldn’t need the <code>Clone</code> or <code>Copy</code> trait bounds and we could
avoid heap allocations. Try implementing these alternate solutions on your own!
If you get stuck with errors having to do with lifetimes, keep reading: the
“Validating References with Lifetimes” section coming up will explain, but
lifetimes aren't required to solve these challenges.</p>
<h3 id="using-trait-bounds-to-conditionally-implement-methods"><a class="header" href="#using-trait-bounds-to-conditionally-implement-methods">Using Trait Bounds to Conditionally Implement Methods</a></h3>
<p>By using a trait bound with an <code>impl</code> block that uses generic type parameters,
we can implement methods conditionally for types that implement the specified
traits. For example, the type <code>Pair&lt;T&gt;</code> in Listing 10-16 always implements the
<code>new</code> function. But <code>Pair&lt;T&gt;</code> only implements the <code>cmp_display</code> method if its
inner type <code>T</code> implements the <code>PartialOrd</code> trait that enables comparison <em>and</em>
the <code>Display</code> trait that enables printing.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use <span class="ra" data-hover="66">std</span>::<span class="ra" data-hover="67">fmt</span>::<span class="ra" data-hover="68">Display</span>;

struct <span class="ra" data-hover="69">Pair</span>&lt;<span class="ra" data-hover="30">T</span>&gt; {
    <span class="ra" data-hover="70">x</span>: <span class="ra" data-hover="30">T</span>,
    <span class="ra" data-hover="71">y</span>: <span class="ra" data-hover="30">T</span>,
}

impl&lt;<span class="ra" data-hover="30">T</span>&gt; <span class="ra" data-hover="69">Pair</span>&lt;<span class="ra" data-hover="30">T</span>&gt; {
    fn <span class="ra" data-hover="72">new</span>(<span class="ra" data-hover="73">x</span>: <span class="ra" data-hover="30">T</span>, <span class="ra" data-hover="74">y</span>: <span class="ra" data-hover="30">T</span>) -&gt; <span class="ra" data-hover="69">Self</span> {
        <span class="ra" data-hover="69">Self</span> { x, y }
    }
}

impl&lt;<span class="ra" data-hover="75">T</span>: <span class="ra" data-hover="68">Display</span> + <span class="ra" data-hover="54">PartialOrd</span>&gt; <span class="ra" data-hover="69">Pair</span>&lt;<span class="ra" data-hover="75">T</span>&gt; {
    fn <span class="ra" data-hover="76">cmp_display</span>(&amp;<span class="ra" data-hover="77">self</span>) {
        if <span class="ra" data-hover="77">self</span>.<span class="ra" data-hover="70">x</span> &gt;= <span class="ra" data-hover="77">self</span>.<span class="ra" data-hover="71">y</span> {
            <span class="ra" data-hover="23">println</span>!("The largest member is x = {}", <span class="ra" data-hover="77">self</span>.<span class="ra" data-hover="70">x</span>);
        } else {
            <span class="ra" data-hover="23">println</span>!("The largest member is y = {}", <span class="ra" data-hover="77">self</span>.<span class="ra" data-hover="71">y</span>);
        }
    }
}
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 10-16: Conditionally implement methods on a
generic type depending on trait bounds</span></p>
<p>We can also conditionally implement a trait for any type that implements
another trait. Implementations of a trait on any type that satisfies the trait
bounds are called <em>blanket implementations</em> and are extensively used in the
Rust standard library. For example, the standard library implements the
<code>ToString</code> trait on any type that implements the <code>Display</code> trait. The <code>impl</code>
block in the standard library looks similar to this code:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;<span class="ra" data-hover="30">T</span>: Display&gt; <span class="ra" data-hover="78">ToString</span> for <span class="ra" data-hover="30">T</span> {
    // --snip--
}
<span class="boring">}
</span>
</code></pre></pre>
<p>Because the standard library has this blanket implementation, we can call the
<code>to_string</code> method defined by the <code>ToString</code> trait on any type that implements
the <code>Display</code> trait. For example, we can turn integers into their corresponding
<code>String</code> values like this because integers implement <code>Display</code>:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let <span class="ra" data-hover="79">s</span><span class="inlay-hint">: String</span> = 3.<span class="ra" data-hover="80">to_string</span>();
<span class="boring">}
</span>
</code></pre></pre>
<p>Blanket implementations appear in the documentation for the trait in the
“Implementors” section.</p>
<p>Traits and trait bounds let us write code that uses generic type parameters to
reduce duplication but also specify to the compiler that we want the generic
type to have particular behavior. The compiler can then use the trait bound
information to check that all the concrete types used with our code provide the
correct behavior. In dynamically typed languages, we would get an error at
runtime if we called a method on a type which didn’t define the method. But Rust
moves these errors to compile time so we’re forced to fix the problems before
our code is even able to run. Additionally, we don’t have to write code that
checks for behavior at runtime because we’ve already checked at compile time.
Doing so improves performance without having to give up the flexibility of
generics.</p>
<p>Another kind of generic that we’ve already been using is called <em>lifetimes</em>.
Rather than ensuring that a type has the behavior we want, lifetimes ensure
that references are valid as long as we need them to be. Let’s look at how
lifetimes do that.</p>
<script src="https://unpkg.com/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
<script src="https://unpkg.com/tippy.js@6.3.2/dist/tippy-bundle.umd.min.js" integrity="sha384-vApKv6LkBdPwmt/fNiQrBCVCZvuniXpG0b5UZhVrGAq1zXdZRSsPcWjGdVxkZJtX" crossorigin="anonymous"></script>
<script>
    const hoverData = ['<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn main()\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">pub trait Summary\n</code></pre>\n','<per><cide class="language-rust">playcrate::Summary\n</code></pre>\n<per><cide class="language-rust">pub fn summarize(&amp;self) -&gt; String\n</code></pre>\n','<per><cide class="language-rust">self: &amp;Self\n</code></pre>\n','<per><cide class="language-rust">alloc::string\n</code></pre>\n<per><cide class="language-rust">pub struct String\n</code></pre>\n<hr />\n<p>A UTF-8–encoded, growable string.</p>\n<p>The <cide>String</code> type is the most common string type that has ownership over the\ncontents of the string. It has a close relationship with its borrowed\ncounterpart, the primitive <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>.</p>\n<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>\n<p>You can create a <cide>String</code> from <a href="https://docs.rs/alloc/*/alloc/str/index.html">a literal string</a> with <a href="https://docs.rs/core/*/core/convert/trait.From.html#tymethod.from"><cide>String::from</code></a>:</p>\n<per><cide>let hello = String::from(&quot;Hello, world!&quot;);\n</code></pre>\n<p>You can append a <a href="%60char%60"><cide>char</code></a> to a <cide>String</code> with the <a href="String::push"><cide>push</code></a> method, and\nappend a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a> with the <a href="String::push_str"><cide>push_str</code></a> method:</p>\n<per><cide>let mut hello = String::from(&quot;Hello, &quot;);\n\nhello.push(#$%w#$%);\nhello.push_str(&quot;orld!&quot;);\n</code></pre>\n<p>If you have a vector of UTF-8 bytes, you can create a <cide>String</code> from it with\nthe <a href="String::from_utf8"><cide>from_utf8</code></a> method:</p>\n<per><cide>// some bytes, in a vector\nlet sparkle_heart = vec![240, 159, 146, 150];\n\n// We know these bytes are valid, so we#$%ll use `unwrap()`.\nlet sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n\nassert_eq!(&quot;💖&quot;, sparkle_heart);\n</code></pre>\n<h1 id="utf-8"><a class="header" href="#utf-8">UTF-8</a></h1>\n<p><cide>String</code>s are always valid UTF-8. This has a few implications, the first of\nwhich is that if you need a non-UTF-8 string, consider <a href="https://docs.rs/alloc/*/std/ffi/struct.OsString.html"><cide>OsString</code></a>. It is\nsimilar, but without the UTF-8 constraint. The second implication is that\nyou cannot index into a <cide>String</code>:</p>\n<per><cide class="language-compile_fail,E0277">let s = &quot;hello&quot;;\n\nprintln!(&quot;The first letter of s is {}&quot;, s[0]); // ERROR!!!\n</code></pre>\n<p>Indexing is intended to be a constant-time operation, but UTF-8 encoding\ndoes not allow us to do this. Furthermore, it#$%s not clear what sort of\nthing the index should return: a byte, a codepoint, or a grapheme cluster.\nThe <a href="str::bytes"><cide>bytes</code></a> and <a href="str::chars"><cide>chars</code></a> methods return iterators over the first\ntwo, respectively.</p>\n<h1 id="deref"><a class="header" href="#deref">Deref</a></h1>\n<p><cide>String</code>s implement <a href="https://docs.rs/core/*/core/ops/deref/trait.Deref.html"><cide>Deref</code></a><cide>&lt;Target=str&gt;</code>, and so inherit all of <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>#$%s\nmethods. In addition, this means that you can pass a <cide>String</code> to a\nfunction which takes a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a> by using an ampersand (<cide>&amp;</code>):</p>\n<per><cide>fn takes_str(s: &amp;str) { }\n\nlet s = String::from(&quot;Hello&quot;);\n\ntakes_str(&amp;s);\n</code></pre>\n<p>This will create a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a> from the <cide>String</code> and pass it in. This\nconversion is very inexpensive, and so generally, functions will accept\n<a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a>s as arguments unless they need a <cide>String</code> for some specific\nreason.</p>\n<p>In certain cases Rust doesn#$%t have enough information to make this\nconversion, known as <a href="https://docs.rs/core/*/core/ops/deref/trait.Deref.html"><cide>Deref</code></a> coercion. In the following example a string\nslice <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;#$%a str</code></a> implements the trait <cide>TraitExample</code>, and the function\n<cide>example_func</code> takes anything that implements the trait. In this case Rust\nwould need to make two implicit conversions, which Rust doesn#$%t have the\nmeans to do. For that reason, the following example will not compile.</p>\n<per><cide class="language-compile_fail,E0277">trait TraitExample {}\n\nimpl&lt;#$%a&gt; TraitExample for &amp;#$%a str {}\n\nfn example_func&lt;A: TraitExample&gt;(example_arg: A) {}\n\nlet example_string = String::from(&quot;example_string&quot;);\nexample_func(&amp;example_string);\n</code></pre>\n<p>There are two options that would work instead. The first would be to\nchange the line <cide>example_func(&amp;example_string);</code> to\n<cide>example_func(example_string.as_str());</code>, using the method <a href="String::as_str"><cide>as_str()</code></a>\nto explicitly extract the string slice containing the string. The second\nway changes <cide>example_func(&amp;example_string);</code> to\n<cide>example_func(&amp;*example_string);</code>. In this case we are dereferencing a\n<cide>String</code> to a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>, then referencing the <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a> back to\n<a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a>. The second way is more idiomatic, however both work to do the\nconversion explicitly rather than relying on the implicit conversion.</p>\n<h1 id="representation"><a class="header" href="#representation">Representation</a></h1>\n<p>A <cide>String</code> is made up of three components: a pointer to some bytes, a\nlength, and a capacity. The pointer points to an internal buffer <cide>String</code>\nuses to store its data. The length is the number of bytes currently stored\nin the buffer, and the capacity is the size of the buffer in bytes. As such,\nthe length will always be less than or equal to the capacity.</p>\n<p>This buffer is always stored on the heap.</p>\n<p>You can look at these with the <a href="str::as_ptr"><cide>as_ptr</code></a>, <a href="String::len"><cide>len</code></a>, and <a href="String::capacity"><cide>capacity</code></a>\nmethods:</p>\n<per><cide>use std::mem;\n\nlet story = String::from(&quot;Once upon a time...&quot;);\n\n// Prevent automatically dropping the String#$%s data\nlet mut story = mem::ManuallyDrop::new(story);\n\nlet ptr = story.as_mut_ptr();\nlet len = story.len();\nlet capacity = story.capacity();\n\n// story has nineteen bytes\nassert_eq!(19, len);\n\n// We can re-build a String out of ptr, len, and capacity. This is all\n// unsafe because we are responsible for making sure the components are\n// valid:\nlet s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;\n\nassert_eq!(String::from(&quot;Once upon a time...&quot;), s);\n</code></pre>\n<p>If a <cide>String</code> has enough capacity, adding elements to it will not\nre-allocate. For example, consider this program:</p>\n<per><cide>let mut s = String::new();\n\nprintln!(&quot;{}&quot;, s.capacity());\n\nfor _ in 0..5 {\n    s.push_str(&quot;hello&quot;);\n    println!(&quot;{}&quot;, s.capacity());\n}\n</code></pre>\n<p>This will output the following:</p>\n<per><cide class="language-text">0\n5\n10\n20\n20\n40\n</code></pre>\n<p>At first, we have no memory allocated at all, but as we append to the\nstring, it increases its capacity appropriately. If we instead use the\n<a href="String::with_capacity"><cide>with_capacity</code></a> method to allocate the correct capacity initially:</p>\n<per><cide>let mut s = String::with_capacity(25);\n\nprintln!(&quot;{}&quot;, s.capacity());\n\nfor _ in 0..5 {\n    s.push_str(&quot;hello&quot;);\n    println!(&quot;{}&quot;, s.capacity());\n}\n</code></pre>\n<p>We end up with a different output:</p>\n<per><cide class="language-text">25\n25\n25\n25\n25\n25\n</code></pre>\n<p>Here, there#$%s no need to allocate more memory inside the loop.</p>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">pub struct NewsArticle\n</code></pre>\n','<per><cide class="language-rust">playcrate::NewsArticle\n</code></pre>\n<per><cide class="language-rust">pub headline: String\n</code></pre>\n','<per><cide class="language-rust">playcrate::NewsArticle\n</code></pre>\n<per><cide class="language-rust">pub location: String\n</code></pre>\n','<per><cide class="language-rust">playcrate::NewsArticle\n</code></pre>\n<per><cide class="language-rust">pub author: String\n</code></pre>\n','<per><cide class="language-rust">playcrate::NewsArticle\n</code></pre>\n<per><cide class="language-rust">pub content: String\n</code></pre>\n','<per><cide class="language-rust">playcrate::NewsArticle\n</code></pre>\n<per><cide class="language-rust">fn summarize(&amp;self) -&gt; String\n</code></pre>\n','<per><cide class="language-rust">self: &amp;NewsArticle\n</code></pre>\n','<per><cide class="language-rust">alloc\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! format\n</code></pre>\n<hr />\n<p>Creates a <cide>String</code> using interpolation of runtime expressions.</p>\n<p>The first argument <cide>format!</code> receives is a format string. This must be a string\nliteral. The power of the formatting string is in the <cide>{}</code>s contained.</p>\n<p>Additional parameters passed to <cide>format!</code> replace the <cide>{}</code>s within the\nformatting string in the order given unless named or positional parameters\nare used; see <a href="../std/fmt/index.html"><cide>std::fmt</code></a> for more information.</p>\n<p>A common use for <cide>format!</code> is concatenation and interpolation of strings.\nThe same convention is used with <a href="../std/macro.print.html"><cide>print!</code></a> and <a href="core::write"><cide>write!</code></a> macros,\ndepending on the intended destination of the string.</p>\n<p>To convert a single value to a string, use the <a href="crate::string::ToString"><cide>to_string</code></a> method. This\nwill use the <a href="core::fmt::Display"><cide>Display</code></a> formatting trait.</p>\n<h1 id="panics"><a class="header" href="#panics">Panics</a></h1>\n<p><cide>format!</code> panics if a formatting trait implementation returns an error.\nThis indicates an incorrect implementation\nsince <cide>fmt::Write for String</code> never returns an error itself.</p>\n<h1 id="examples-1"><a class="header" href="#examples-1">Examples</a></h1>\n<per><cide>format!(&quot;test&quot;);\nformat!(&quot;hello {}&quot;, &quot;world!&quot;);\nformat!(&quot;x = {}, y = {y}&quot;, 10, y = 30);\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">pub struct Tweet\n</code></pre>\n','<per><cide class="language-rust">playcrate::Tweet\n</code></pre>\n<per><cide class="language-rust">pub username: String\n</code></pre>\n','<per><cide class="language-rust">playcrate::Tweet\n</code></pre>\n<per><cide class="language-rust">pub content: String\n</code></pre>\n','<per><cide class="language-rust">playcrate::Tweet\n</code></pre>\n<per><cide class="language-rust">pub reply: bool\n</code></pre>\n','<per><cide class="language-rust">bool\n</code></pre>\n<hr />\n<p>The boolean type.</p>\n<p>The <cide>bool</code> represents a value, which could only be either <cide>true</code> or <cide>false</code>. If you cast\na <cide>bool</code> into an integer, <cide>true</code> will be 1 and <cide>false</code> will be 0.</p>\n<h1 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h1>\n<p><cide>bool</code> implements various traits, such as <a href="ops::BitAnd"><cide>BitAnd</code></a>, <a href="ops::BitOr"><cide>BitOr</code></a>, <a href="ops::Not"><cide>Not</code></a>, etc.,\nwhich allow us to perform boolean operations using <cide>&amp;</code>, <cide>|</code> and <cide>!</code>.</p>\n<p><cide>if</code> requires a <cide>bool</code> value as its conditional. <a href="%60assert!%60"><cide>assert!</code></a>, which is an\nimportant macro in testing, checks whether an expression is <cide>true</code> and panics\nif it isn#$%t.</p>\n<per><cide>let bool_val = true &amp; false | false;\nassert!(!bool_val);\n</code></pre>\n<h1 id="examples-2"><a class="header" href="#examples-2">Examples</a></h1>\n<p>A trivial example of the usage of <cide>bool</code>:</p>\n<per><cide>let praise_the_borrow_checker = true;\n\n// using the `if` conditional\nif praise_the_borrow_checker {\n    println!(&quot;oh, yeah!&quot;);\n} else {\n    println!(&quot;what?!!&quot;);\n}\n\n// ... or, a match pattern\nmatch praise_the_borrow_checker {\n    true =&gt; println!(&quot;keep praising!&quot;),\n    false =&gt; println!(&quot;you should praise!&quot;),\n}\n</code></pre>\n<p>Also, since <cide>bool</code> implements the <a href="%60Copy%60"><cide>Copy</code></a> trait, we don#$%t\nhave to worry about the move semantics (just like the integer and float primitives).</p>\n<p>Now an example of <cide>bool</code> cast to integer type:</p>\n<per><cide>assert_eq!(true as i32, 1);\nassert_eq!(false as i32, 0);\n</code></pre>\n','<per><cide class="language-rust">playcrate::Tweet\n</code></pre>\n<per><cide class="language-rust">pub retweet: bool\n</code></pre>\n','<per><cide class="language-rust">playcrate::Tweet\n</code></pre>\n<per><cide class="language-rust">fn summarize(&amp;self) -&gt; String\n</code></pre>\n','<per><cide class="language-rust">self: &amp;Tweet\n</code></pre>\n','<per><cide class="language-rust">let tweet: {unknown}\n</code></pre>\n','<per><cide class="language-rust">core::convert::From\n</code></pre>\n<per><cide class="language-rust">pub fn from(_: T) -&gt; Self\n</code></pre>\n<hr />\n<p>Performs the conversion.</p>\n','<per><cide class="language-rust">std\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! println\n</code></pre>\n<hr />\n<p>Prints to the standard output, with a newline.</p>\n<p>On all platforms, the newline is the LINE FEED character (<cide>\n</code>/<cide>U+000A</code>) alone\n(no additional CARRIAGE RETURN (<cide>\r</code>/<cide>U+000D</code>)).</p>\n<p>Use the <a href="%60format!%60"><cide>format!</code></a> syntax to write data to the standard output.\nSee <a href="crate::fmt"><cide>std::fmt</code></a> for more information.</p>\n<p>Use <cide>println!</code> only for the primary output of your program. Use\n<a href="%60eprintln!%60"><cide>eprintln!</code></a> instead to print error and progress messages.</p>\n<h1 id="panics-1"><a class="header" href="#panics-1">Panics</a></h1>\n<p>Panics if writing to <a href="crate::io::stdout"><cide>io::stdout</code></a> fails.</p>\n<h1 id="examples-3"><a class="header" href="#examples-3">Examples</a></h1>\n<per><cide>println!(); // prints just a newline\nprintln!(&quot;hello there!&quot;);\nprintln!(&quot;format {} arguments&quot;, &quot;some&quot;);\n</code></pre>\n','<per><cide class="language-rust">let article: {unknown}\n</code></pre>\n','<per><cide class="language-rust">playcrate::Summary\n</code></pre>\n<per><cide class="language-rust">pub fn summarize_author(&amp;self) -&gt; String\n</code></pre>\n','<per><cide class="language-rust">playcrate::Tweet\n</code></pre>\n<per><cide class="language-rust">fn summarize_author(&amp;self) -&gt; String\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">pub fn notify(item: &amp;impl Summary)\nwhere\n    {unnamed}: Summary,\n</code></pre>\n','<per><cide class="language-rust">item: &amp;impl Summary\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">pub fn notify&lt;T&gt;(item: &amp;T)\nwhere\n    T: Summary,\n</code></pre>\n','<per><cide class="language-rust">T\n</code></pre>\n','<per><cide class="language-rust">item: &amp;T\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary)\nwhere\n    {unnamed}: Summary,\n    {unnamed}: Summary,\n</code></pre>\n','<per><cide class="language-rust">item1: &amp;impl Sized\n</code></pre>\n','<per><cide class="language-rust">item2: &amp;impl Sized\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">pub fn notify&lt;T&gt;(item1: &amp;T, item2: &amp;T)\nwhere\n    T: Summary,\n</code></pre>\n','<per><cide class="language-rust">item1: &amp;T\n</code></pre>\n','<per><cide class="language-rust">item2: &amp;T\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">pub fn notify(item: &amp;impl Summary + Display)\nwhere\n    {unnamed}: Summary + Display,\n</code></pre>\n','<per><cide class="language-rust">item: &amp;impl Sized\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">pub fn notify&lt;T&gt;(item: &amp;T)\nwhere\n    T: Summary + Display,\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32\nwhere\n    T: Display + Clone,\n    U: Clone + Debug,\n</code></pre>\n','<per><cide class="language-rust">T: Clone\n</code></pre>\n','<per><cide class="language-rust">core::clone\n</code></pre>\n<per><cide class="language-rust">pub trait Clone\nwhere\n    Self: Sized,\n</code></pre>\n<hr />\n<p>A common trait for the ability to explicitly duplicate an object.</p>\n<p>Differs from <a href="https://docs.rs/core/*/core/marker/trait.Copy.html"><cide>Copy</code></a> in that <a href="https://docs.rs/core/*/core/marker/trait.Copy.html"><cide>Copy</code></a> is implicit and an inexpensive bit-wise copy, while\n<cide>Clone</code> is always explicit and may or may not be expensive. In order to enforce\nthese characteristics, Rust does not allow you to reimplement <a href="https://docs.rs/core/*/core/marker/trait.Copy.html"><cide>Copy</code></a>, but you\nmay reimplement <cide>Clone</code> and run arbitrary code.</p>\n<p>Since <cide>Clone</code> is more general than <a href="https://docs.rs/core/*/core/marker/trait.Copy.html"><cide>Copy</code></a>, you can automatically make anything\n<a href="https://docs.rs/core/*/core/marker/trait.Copy.html"><cide>Copy</code></a> be <cide>Clone</code> as well.</p>\n<h2 id="derivable"><a class="header" href="#derivable">Derivable</a></h2>\n<p>This trait can be used with <cide>#[derive]</code> if all fields are <cide>Clone</code>. The <cide>derive</code>d\nimplementation of <a href="https://docs.rs/core/*/core/clone/trait.Clone.html#tymethod.clone"><cide>Clone</code></a> calls <a href="https://docs.rs/core/*/core/clone/trait.Clone.html#tymethod.clone"><cide>clone</code></a> on each field.</p>\n<p>For a generic struct, <cide>#[derive]</code> implements <cide>Clone</code> conditionally by adding bound <cide>Clone</code> on\ngeneric parameters.</p>\n<per><cide>// `derive` implements Clone for Reading&lt;T&gt; when T is Clone.\n#[derive(Clone)]\nstruct Reading&lt;T&gt; {\n    frequency: T,\n}\n</code></pre>\n<h2 id="how-can-i-implement-cideclone"><a class="header" href="#how-can-i-implement-cideclone">How can I implement <cide>Clone</code>?</a></h2>\n<p>Types that are <a href="https://docs.rs/core/*/core/marker/trait.Copy.html"><cide>Copy</code></a> should have a trivial implementation of <cide>Clone</code>. More formally:\nif <cide>T: Copy</code>, <cide>x: T</code>, and <cide>y: &amp;T</code>, then <cide>let x = y.clone();</code> is equivalent to <cide>let x = *y;</code>.\nManual implementations should be careful to uphold this invariant; however, unsafe code\nmust not rely on it to ensure memory safety.</p>\n<p>An example is a generic struct holding a function pointer. In this case, the\nimplementation of <cide>Clone</code> cannot be <cide>derive</code>d, but can be implemented as:</p>\n<per><cide>struct Generate&lt;T&gt;(fn() -&gt; T);\n\nimpl&lt;T&gt; Copy for Generate&lt;T&gt; {}\n\nimpl&lt;T&gt; Clone for Generate&lt;T&gt; {\n    fn clone(&amp;self) -&gt; Self {\n        *self\n    }\n}\n</code></pre>\n<h2 id="additional-implementors"><a class="header" href="#additional-implementors">Additional implementors</a></h2>\n<p>In addition to the <a href="https://docs.rs/core/*/core/clone/trait.Clone.html#implementors">implementors listed below</a>,\nthe following types also implement <cide>Clone</code>:</p>\n<ul>\n<li>Function item types (i.e., the distinct types defined for each function)</li>\n<li>Function pointer types (e.g., <cide>fn() -&gt; i32</code>)</li>\n<li>Array types, for all sizes, if the item type also implements <cide>Clone</code> (e.g., <cide>[i32; 123456]</code>)</li>\n<li>Tuple types, if each component also implements <cide>Clone</code> (e.g., <cide>()</code>, <cide>(i32, bool)</code>)</li>\n<li>Closure types, if they capture no value from the environment\nor if all such captured values implement <cide>Clone</code> themselves.\nNote that variables captured by shared reference always implement <cide>Clone</code>\n(even if the referent doesn#$%t),\nwhile variables captured by mutable reference never implement <cide>Clone</code>.</li>\n</ul>\n','<per><cide class="language-rust">U: Clone\n</code></pre>\n','<per><cide class="language-rust">core\n</code></pre>\n<per><cide class="language-rust">pub macro Debug\n</code></pre>\n<hr />\n<p>Derive macro generating an impl of the trait <cide>Debug</code>.</p>\n','<per><cide class="language-rust">t: &amp;T\n</code></pre>\n','<per><cide class="language-rust">u: &amp;U\n</code></pre>\n','<per><cide class="language-rust">i32\n</code></pre>\n<hr />\n<p>The 32-bit signed integer type.</p>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn returns_summarizable() -&gt; impl Summary\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn returns_summarizable(switch: bool) -&gt; impl Summary\n</code></pre>\n','<per><cide class="language-rust">switch: bool\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T\nwhere\n    T: PartialOrd,\n</code></pre>\n','<per><cide class="language-rust">T: PartialOrd&lt;T&gt;\n</code></pre>\n','<per><cide class="language-rust">core::cmp\n</code></pre>\n<per><cide class="language-rust">pub trait PartialOrd&lt;Rhs = Self&gt;\nwhere\n    Self: PartialEq&lt;Rhs&gt;,\n    Rhs: ?Sized,\n</code></pre>\n<hr />\n<p>Trait for values that can be compared for a sort-order.</p>\n<p>The <cide>lt</code>, <cide>le</code>, <cide>gt</code>, and <cide>ge</code> methods of this trait can be called using\nthe <cide>&lt;</code>, <cide>&lt;=</code>, <cide>&gt;</code>, and <cide>&gt;=</code> operators, respectively.</p>\n<p>The methods of this trait must be consistent with each other and with those of <cide>PartialEq</code> in\nthe following sense:</p>\n<ul>\n<li><cide>a == b</code> if and only if <cide>partial_cmp(a, b) == Some(Equal)</code>.</li>\n<li><cide>a &lt; b</code> if and only if <cide>partial_cmp(a, b) == Some(Less)</code>\n(ensured by the default implementation).</li>\n<li><cide>a &gt; b</code> if and only if <cide>partial_cmp(a, b) == Some(Greater)</code>\n(ensured by the default implementation).</li>\n<li><cide>a &lt;= b</code> if and only if <cide>a &lt; b || a == b</code>\n(ensured by the default implementation).</li>\n<li><cide>a &gt;= b</code> if and only if <cide>a &gt; b || a == b</code>\n(ensured by the default implementation).</li>\n<li><cide>a != b</code> if and only if <cide>!(a == b)</code> (already part of <cide>PartialEq</code>).</li>\n</ul>\n<p>If <a href="https://docs.rs/core/*/core/cmp/trait.Ord.html"><cide>Ord</code></a> is also implemented for <cide>Self</code> and <cide>Rhs</code>, it must also be consistent with\n<cide>partial_cmp</code> (see the documentation of that trait for the exact requirements). It#$%s\neasy to accidentally make them disagree by deriving some of the traits and manually\nimplementing others.</p>\n<p>The comparison must satisfy, for all <cide>a</code>, <cide>b</code> and <cide>c</code>:</p>\n<ul>\n<li>transitivity: <cide>a &lt; b</code> and <cide>b &lt; c</code> implies <cide>a &lt; c</code>. The same must hold for both <cide>==</code> and <cide>&gt;</code>.</li>\n<li>duality: <cide>a &lt; b</code> if and only if <cide>b &gt; a</code>.</li>\n</ul>\n<p>Note that these requirements mean that the trait itself must be implemented symmetrically and\ntransitively: if <cide>T: PartialOrd&lt;U&gt;</code> and <cide>U: PartialOrd&lt;V&gt;</code> then <cide>U: PartialOrd&lt;T&gt;</code> and <cide>T: PartialOrd&lt;V&gt;</code>.</p>\n<h2 id="corollaries"><a class="header" href="#corollaries">Corollaries</a></h2>\n<p>The following corollaries follow from the above requirements:</p>\n<ul>\n<li>irreflexivity of <cide>&lt;</code> and <cide>&gt;</code>: <cide>!(a &lt; a)</code>, <cide>!(a &gt; a)</code></li>\n<li>transitivity of <cide>&gt;</code>: if <cide>a &gt; b</code> and <cide>b &gt; c</code> then <cide>a &gt; c</code></li>\n<li>duality of <cide>partial_cmp</code>: <cide>partial_cmp(a, b) == partial_cmp(b, a).map(Ordering::reverse)</code></li>\n</ul>\n<h2 id="derivable-1"><a class="header" href="#derivable-1">Derivable</a></h2>\n<p>This trait can be used with <cide>#[derive]</code>. When <cide>derive</code>d on structs, it will produce a\nlexicographic ordering based on the top-to-bottom declaration order of the struct#$%s members.\nWhen <cide>derive</code>d on enums, variants are ordered by their top-to-bottom discriminant order.</p>\n<h2 id="how-can-i-implement-cidepartialord"><a class="header" href="#how-can-i-implement-cidepartialord">How can I implement <cide>PartialOrd</code>?</a></h2>\n<p><cide>PartialOrd</code> only requires implementation of the <a href="https://docs.rs/core/*/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp"><cide>partial_cmp</code></a> method, with the others\ngenerated from default implementations.</p>\n<p>However it remains possible to implement the others separately for types which do not have a\ntotal order. For example, for floating point numbers, <cide>NaN &lt; 0 == false</code> and <cide>NaN &gt;= 0 == false</code> (cf. IEEE 754-2008 section 5.11).</p>\n<p><cide>PartialOrd</code> requires your type to be <a href="https://docs.rs/core/*/core/cmp/trait.PartialEq.html"><cide>PartialEq</code></a>.</p>\n<p>If your type is <a href="https://docs.rs/core/*/core/cmp/trait.Ord.html"><cide>Ord</code></a>, you can implement <a href="https://docs.rs/core/*/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp"><cide>partial_cmp</code></a> by using <a href="https://docs.rs/core/*/core/cmp/trait.Ord.html#tymethod.cmp"><cide>cmp</code></a>:</p>\n<per><cide>use std::cmp::Ordering;\n\n#[derive(Eq)]\nstruct Person {\n    id: u32,\n    name: String,\n    height: u32,\n}\n\nimpl PartialOrd for Person {\n    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Person {\n    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {\n        self.height.cmp(&amp;other.height)\n    }\n}\n\nimpl PartialEq for Person {\n    fn eq(&amp;self, other: &amp;Self) -&gt; bool {\n        self.height == other.height\n    }\n}\n</code></pre>\n<p>You may also find it useful to use <a href="https://docs.rs/core/*/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp"><cide>partial_cmp</code></a> on your type#$%s fields. Here\nis an example of <cide>Person</code> types who have a floating-point <cide>height</code> field that\nis the only field to be used for sorting:</p>\n<per><cide>use std::cmp::Ordering;\n\nstruct Person {\n    id: u32,\n    name: String,\n    height: f64,\n}\n\nimpl PartialOrd for Person {\n    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {\n        self.height.partial_cmp(&amp;other.height)\n    }\n}\n\nimpl PartialEq for Person {\n    fn eq(&amp;self, other: &amp;Self) -&gt; bool {\n        self.height == other.height\n    }\n}\n</code></pre>\n<h1 id="examples-4"><a class="header" href="#examples-4">Examples</a></h1>\n<per><cide>let x : u32 = 0;\nlet y : u32 = 1;\n\nassert_eq!(x &lt; y, true);\nassert_eq!(x.lt(&amp;y), true);\n</code></pre>\n','<per><cide class="language-rust">list: &amp;[T]\n</code></pre>\n','<per><cide class="language-rust">let mut largest: T\n</code></pre>\n','<per><cide class="language-rust">item: T\n</code></pre>\n','<per><cide class="language-rust">let number_list: Vec&lt;i32, Global&gt;\n</code></pre>\n','<per><cide class="language-rust">alloc\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! vec\n</code></pre>\n<hr />\n<p>Creates a <a href="crate::vec::Vec"><cide>Vec</code></a> containing the arguments.</p>\n<p><cide>vec!</code> allows <cide>Vec</code>s to be defined with the same syntax as array expressions.\nThere are two forms of this macro:</p>\n<ul>\n<li>Create a <a href="crate::vec::Vec"><cide>Vec</code></a> containing a given list of elements:</li>\n</ul>\n<per><cide>let v = vec![1, 2, 3];\nassert_eq!(v[0], 1);\nassert_eq!(v[1], 2);\nassert_eq!(v[2], 3);\n</code></pre>\n<ul>\n<li>Create a <a href="crate::vec::Vec"><cide>Vec</code></a> from a given element and size:</li>\n</ul>\n<per><cide>let v = vec![1; 3];\nassert_eq!(v, [1, 1, 1]);\n</code></pre>\n<p>Note that unlike array expressions this syntax supports all elements\nwhich implement <a href="%60Clone%60"><cide>Clone</code></a> and the number of elements doesn#$%t have to be\na constant.</p>\n<p>This will use <cide>clone</code> to duplicate an expression, so one should be careful\nusing this with types having a nonstandard <cide>Clone</code> implementation. For\nexample, <cide>vec![Rc::new(1); 5]</code> will create a vector of five references\nto the same boxed integer value, not five references pointing to independently\nboxed integers.</p>\n<p>Also, note that <cide>vec![expr; 0]</code> is allowed, and produces an empty vector.\nThis will still evaluate <cide>expr</code>, however, and immediately drop the resulting value, so\nbe mindful of side effects.</p>\n','<per><cide class="language-rust">let result: i32\n</code></pre>\n','<per><cide class="language-rust">let char_list: Vec&lt;char, Global&gt;\n</code></pre>\n','<per><cide class="language-rust">let result: char\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T\nwhere\n    T: PartialOrd + Copy,\n</code></pre>\n','<per><cide class="language-rust">T: PartialOrd&lt;T&gt; + Copy\n</code></pre>\n','<per><cide class="language-rust">core::marker\n</code></pre>\n<per><cide class="language-rust">pub trait Copy\nwhere\n    Self: Clone,\n</code></pre>\n<hr />\n<p>Types whose values can be duplicated simply by copying bits.</p>\n<p>By default, variable bindings have #$%move semantics.#$% In other\nwords:</p>\n<per><cide>#[derive(Debug)]\nstruct Foo;\n\nlet x = Foo;\n\nlet y = x;\n\n// `x` has moved into `y`, and so cannot be used\n\n// println!(&quot;{:?}&quot;, x); // error: use of moved value\n</code></pre>\n<p>However, if a type implements <cide>Copy</code>, it instead has #$%copy semantics#$%:</p>\n<per><cide>// We can derive a `Copy` implementation. `Clone` is also required, as it#$%s\n// a supertrait of `Copy`.\n#[derive(Debug, Copy, Clone)]\nstruct Foo;\n\nlet x = Foo;\n\nlet y = x;\n\n// `y` is a copy of `x`\n\nprintln!(&quot;{:?}&quot;, x); // A-OK!\n</code></pre>\n<p>It#$%s important to note that in these two examples, the only difference is whether you\nare allowed to access <cide>x</code> after the assignment. Under the hood, both a copy and a move\ncan result in bits being copied in memory, although this is sometimes optimized away.</p>\n<h2 id="how-can-i-implement-cidecopy"><a class="header" href="#how-can-i-implement-cidecopy">How can I implement <cide>Copy</code>?</a></h2>\n<p>There are two ways to implement <cide>Copy</code> on your type. The simplest is to use <cide>derive</code>:</p>\n<per><cide>#[derive(Copy, Clone)]\nstruct MyStruct;\n</code></pre>\n<p>You can also implement <cide>Copy</code> and <cide>Clone</code> manually:</p>\n<per><cide>struct MyStruct;\n\nimpl Copy for MyStruct { }\n\nimpl Clone for MyStruct {\n    fn clone(&amp;self) -&gt; MyStruct {\n        *self\n    }\n}\n</code></pre>\n<p>There is a small difference between the two: the <cide>derive</code> strategy will also place a <cide>Copy</code>\nbound on type parameters, which isn#$%t always desired.</p>\n<h2 id="whats-the-difference-between-cidecopy-and-cideclone"><a class="header" href="#whats-the-difference-between-cidecopy-and-cideclone">What#$%s the difference between <cide>Copy</code> and <cide>Clone</code>?</a></h2>\n<p>Copies happen implicitly, for example as part of an assignment <cide>y = x</code>. The behavior of\n<cide>Copy</code> is not overloadable; it is always a simple bit-wise copy.</p>\n<p>Cloning is an explicit action, <cide>x.clone()</code>. The implementation of <a href="https://docs.rs/core/*/core/clone/trait.Clone.html"><cide>Clone</code></a> can\nprovide any type-specific behavior necessary to duplicate values safely. For example,\nthe implementation of <a href="https://docs.rs/core/*/core/clone/trait.Clone.html"><cide>Clone</code></a> for <a href="https://docs.rs/core/*/std/string/struct.String.html"><cide>String</code></a> needs to copy the pointed-to string\nbuffer in the heap. A simple bitwise copy of <a href="https://docs.rs/core/*/std/string/struct.String.html"><cide>String</code></a> values would merely copy the\npointer, leading to a double free down the line. For this reason, <a href="https://docs.rs/core/*/std/string/struct.String.html"><cide>String</code></a> is <a href="https://docs.rs/core/*/core/clone/trait.Clone.html"><cide>Clone</code></a>\nbut not <cide>Copy</code>.</p>\n<p><a href="https://docs.rs/core/*/core/clone/trait.Clone.html"><cide>Clone</code></a> is a supertrait of <cide>Copy</code>, so everything which is <cide>Copy</code> must also implement\n<a href="https://docs.rs/core/*/core/clone/trait.Clone.html"><cide>Clone</code></a>. If a type is <cide>Copy</code> then its <a href="https://docs.rs/core/*/core/clone/trait.Clone.html"><cide>Clone</code></a> implementation only needs to return <cide>*self</code>\n(see the example above).</p>\n<h2 id="when-can-my-type-be-cidecopy"><a class="header" href="#when-can-my-type-be-cidecopy">When can my type be <cide>Copy</code>?</a></h2>\n<p>A type can implement <cide>Copy</code> if all of its components implement <cide>Copy</code>. For example, this\nstruct can be <cide>Copy</code>:</p>\n<per><cide># #[allow(dead_code)]\n#[derive(Copy, Clone)]\nstruct Point {\n   x: i32,\n   y: i32,\n}\n</code></pre>\n<p>A struct can be <cide>Copy</code>, and <a href="%60i32%60"><cide>i32</code></a> is <cide>Copy</code>, therefore <cide>Point</code> is eligible to be <cide>Copy</code>.\nBy contrast, consider</p>\n<per><cide># #![allow(dead_code)]\n# struct Point;\nstruct PointList {\n    points: Vec&lt;Point&gt;,\n}\n</code></pre>\n<p>The struct <cide>PointList</code> cannot implement <cide>Copy</code>, because <a href="https://docs.rs/core/*/std/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a> is not <cide>Copy</code>. If we\nattempt to derive a <cide>Copy</code> implementation, we#$%ll get an error:</p>\n<per><cide class="language-text">the trait `Copy` may not be implemented for this type; field `points` does not implement `Copy`\n</code></pre>\n<p>Shared references (<cide>&amp;T</code>) are also <cide>Copy</code>, so a type can be <cide>Copy</code>, even when it holds\nshared references of types <cide>T</code> that are <em>not</em> <cide>Copy</code>. Consider the following struct,\nwhich can implement <cide>Copy</code>, because it only holds a <em>shared reference</em> to our non-<cide>Copy</code>\ntype <cide>PointList</code> from above:</p>\n<per><cide># #![allow(dead_code)]\n# struct PointList;\n#[derive(Copy, Clone)]\nstruct PointListWrapper&lt;#$%a&gt; {\n    point_list_ref: &amp;#$%a PointList,\n}\n</code></pre>\n<h2 id="when-cant-my-type-be-cidecopy"><a class="header" href="#when-cant-my-type-be-cidecopy">When <em>can#$%t</em> my type be <cide>Copy</code>?</a></h2>\n<p>Some types can#$%t be copied safely. For example, copying <cide>&amp;mut T</code> would create an aliased\nmutable reference. Copying <a href="https://docs.rs/core/*/std/string/struct.String.html"><cide>String</code></a> would duplicate responsibility for managing the\n<a href="https://docs.rs/core/*/std/string/struct.String.html"><cide>String</code></a>#$%s buffer, leading to a double free.</p>\n<p>Generalizing the latter case, any type implementing <a href="https://docs.rs/core/*/core/ops/drop/trait.Drop.html"><cide>Drop</code></a> can#$%t be <cide>Copy</code>, because it#$%s\nmanaging some resource besides its own <a href="https://docs.rs/core/*/core/mem/fn.size_of.html"><cide>size_of::&lt;T&gt;</code></a> bytes.</p>\n<p>If you try to implement <cide>Copy</code> on a struct or enum containing non-<cide>Copy</code> data, you will get\nthe error <a href="https://docs.rs/core/*/error-index.html#E0204">E0204</a>.</p>\n<h2 id="when-should-my-type-be-cidecopy"><a class="header" href="#when-should-my-type-be-cidecopy">When <em>should</em> my type be <cide>Copy</code>?</a></h2>\n<p>Generally speaking, if your type <em>can</em> implement <cide>Copy</code>, it should. Keep in mind, though,\nthat implementing <cide>Copy</code> is part of the public API of your type. If the type might become\nnon-<cide>Copy</code> in the future, it could be prudent to omit the <cide>Copy</code> implementation now, to\navoid a breaking API change.</p>\n<h2 id="additional-implementors-1"><a class="header" href="#additional-implementors-1">Additional implementors</a></h2>\n<p>In addition to the <a href="https://docs.rs/core/*/core/marker/trait.Copy.html#implementors">implementors listed below</a>,\nthe following types also implement <cide>Copy</code>:</p>\n<ul>\n<li>Function item types (i.e., the distinct types defined for each function)</li>\n<li>Function pointer types (e.g., <cide>fn() -&gt; i32</code>)</li>\n<li>Array types, for all sizes, if the item type also implements <cide>Copy</code> (e.g., <cide>[i32; 123456]</code>)</li>\n<li>Tuple types, if each component also implements <cide>Copy</code> (e.g., <cide>()</code>, <cide>(i32, bool)</code>)</li>\n<li>Closure types, if they capture no value from the environment\nor if all such captured values implement <cide>Copy</code> themselves.\nNote that variables captured by shared reference always implement <cide>Copy</code>\n(even if the referent doesn#$%t),\nwhile variables captured by mutable reference never implement <cide>Copy</code>.</li>\n</ul>\n','<per><cide class="language-rust">extern crate std\n</code></pre>\n<hr />\n<h1 id="the-rust-standard-library"><a class="header" href="#the-rust-standard-library">The Rust Standard Library</a></h1>\n<p>The Rust Standard Library is the foundation of portable Rust software, a\nset of minimal and battle-tested shared abstractions for the <a href="https://crates.io">broader Rust\necosystem</a>. It offers core types, like <a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a> and\n<a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>Option&lt;T&gt;</code></a>, library-defined <a href="https://docs.rs/std/*/std/index.html#primitives">operations on language\nprimitives</a>, <a href="https://docs.rs/std/*/std/index.html#macros">standard macros</a>, <a href="https://docs.rs/std/*/std/io/index.html">I/O</a> and\n<a href="https://docs.rs/std/*/std/thread/index.html">multithreading</a>, among <a href="https://docs.rs/std/*/std/index.html#what-is-in-the-standard-library-documentation">many other things</a>.</p>\n<p><cide>std</code> is available to all Rust crates by default. Therefore, the\nstandard library can be accessed in <a href="https://docs.rs/std/*/book/ch07-02-defining-modules-to-control-scope-and-privacy.html"><cide>use</code></a> statements through the path\n<cide>std</code>, as in <a href="https://docs.rs/std/*/std/env/index.html"><cide>use std::env</code></a>.</p>\n<h1 id="how-to-read-this-documentation"><a class="header" href="#how-to-read-this-documentation">How to read this documentation</a></h1>\n<p>If you already know the name of what you are looking for, the fastest way to\nfind it is to use the <!-- raw HTML omitted -->search\nbar<!-- raw HTML omitted --> at the top of the page.</p>\n<p>Otherwise, you may want to jump to one of these useful sections:</p>\n<ul>\n<li><a href="https://docs.rs/std/*/std/index.html#modules"><cide>std::*</code> modules</a></li>\n<li><a href="https://docs.rs/std/*/std/index.html#primitives">Primitive types</a></li>\n<li><a href="https://docs.rs/std/*/std/index.html#macros">Standard macros</a></li>\n<li><a href="https://docs.rs/std/*/std/prelude/index.html">The Rust Prelude</a></li>\n</ul>\n<p>If this is your first time, the documentation for the standard library is\nwritten to be casually perused. Clicking on interesting things should\ngenerally lead you to interesting places. Still, there are important bits\nyou don#$%t want to miss, so read on for a tour of the standard library and\nits documentation!</p>\n<p>Once you are familiar with the contents of the standard library you may\nbegin to find the verbosity of the prose distracting. At this stage in your\ndevelopment you may want to press the <cide>[-]</code> button near the top of the\npage to collapse it into a more skimmable view.</p>\n<p>While you are looking at that <cide>[-]</code> button also notice the <cide>[src]</code>\nbutton. Rust#$%s API documentation comes with the source code and you are\nencouraged to read it. The standard library source is generally high\nquality and a peek behind the curtains is often enlightening.</p>\n<h1 id="what-is-in-the-standard-library-documentation"><a class="header" href="#what-is-in-the-standard-library-documentation">What is in the standard library documentation?</a></h1>\n<p>First of all, The Rust Standard Library is divided into a number of focused\nmodules, <a href="https://docs.rs/std/*/std/index.html#modules">all listed further down this page</a>. These modules are\nthe bedrock upon which all of Rust is forged, and they have mighty names\nlike <a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>std::slice</code></a> and <a href="https://docs.rs/core/*/core/cmp/index.html"><cide>std::cmp</code></a>. Modules#$% documentation typically\nincludes an overview of the module along with examples, and are a smart\nplace to start familiarizing yourself with the library.</p>\n<p>Second, implicit methods on <a href="https://docs.rs/std/*/book/ch03-02-data-types.html">primitive types</a> are documented here. This can\nbe a source of confusion for two reasons:</p>\n<ol>\n<li>While primitives are implemented by the compiler, the standard library\nimplements methods directly on the primitive types (and it is the only\nlibrary that does so), which are <a href="https://docs.rs/std/*/std/index.html#primitives">documented in the section on\nprimitives</a>.</li>\n<li>The standard library exports many modules <em>with the same name as\nprimitive types</em>. These define additional items related to the primitive\ntype, but not the all-important methods.</li>\n</ol>\n<p>So for example there is a <a href="primitive::i32">page for the primitive type\n<cide>i32</code></a> that lists all the methods that can be called on\n32-bit integers (very useful), and there is a <a href="https://docs.rs/core/*/core/i32/index.html">page for the module\n<cide>std::i32</code></a> that documents the constant values <a href="https://docs.rs/core/*/core/i32/const.MIN.html"><cide>MIN</code></a> and <a href="https://docs.rs/core/*/core/i32/const.MAX.html"><cide>MAX</code></a> (rarely\nuseful).</p>\n<p>Note the documentation for the primitives <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a> and <a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>[T]</code></a> (also\ncalled #$%slice#$%). Many method calls on <a href="https://docs.rs/alloc/*/alloc/string/struct.String.html"><cide>String</code></a> and <a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a> are actually\ncalls to methods on <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a> and <a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>[T]</code></a> respectively, via <a href="https://docs.rs/std/*/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods">deref\ncoercions</a>.</p>\n<p>Third, the standard library defines <a href="https://docs.rs/std/*/std/prelude/index.html">The Rust Prelude</a>, a small collection\nof items - mostly traits - that are imported into every module of every\ncrate. The traits in the prelude are pervasive, making the prelude\ndocumentation a good entry point to learning about the library.</p>\n<p>And finally, the standard library exports a number of standard macros, and\n<a href="https://docs.rs/std/*/std/index.html#macros">lists them on this page</a> (technically, not all of the standard\nmacros are defined by the standard library - some are defined by the\ncompiler - but they are documented here the same). Like the prelude, the\nstandard macros are imported by default into all crates.</p>\n<h1 id="contributing-changes-to-the-documentation"><a class="header" href="#contributing-changes-to-the-documentation">Contributing changes to the documentation</a></h1>\n<p>Check out the rust contribution guidelines <a href="https://rustc-dev-guide.rust-lang.org/contributing.html#writing-documentation">here</a>.\nThe source for this documentation can be found on\n<a href="https://github.com/rust-lang/rust">GitHub</a>.\nTo contribute changes, make sure you read the guidelines first, then submit\npull-requests for your suggested changes.</p>\n<p>Contributions are appreciated! If you see a part of the docs that can be\nimproved, submit a PR, or chat with us first on <a href="https://discord.gg/rust-lang">Discord</a>\n#docs.</p>\n<h1 id="a-tour-of-the-rust-standard-library"><a class="header" href="#a-tour-of-the-rust-standard-library">A Tour of The Rust Standard Library</a></h1>\n<p>The rest of this crate documentation is dedicated to pointing out notable\nfeatures of The Rust Standard Library.</p>\n<h2 id="containers-and-collections"><a class="header" href="#containers-and-collections">Containers and collections</a></h2>\n<p>The <a href="https://docs.rs/core/*/core/option/index.html"><cide>option</code></a> and <a href="https://docs.rs/core/*/core/result/index.html"><cide>result</code></a> modules define optional and error-handling\ntypes, <a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>Option&lt;T&gt;</code></a> and <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Result&lt;T, E&gt;</code></a>. The <a href="https://docs.rs/core/*/core/iter/index.html"><cide>iter</code></a> module defines\nRust#$%s iterator trait, <a href="https://docs.rs/core/*/core/iter/traits/iterator/trait.Iterator.html"><cide>Iterator</code></a>, which works with the <a href="https://docs.rs/std/*/book/ch03-05-control-flow.html#looping-through-a-collection-with-for"><cide>for</code></a> loop to\naccess collections.</p>\n<p>The standard library exposes three common ways to deal with contiguous\nregions of memory:</p>\n<ul>\n<li><a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a> - A heap-allocated <em>vector</em> that is resizable at runtime.</li>\n<li><a href="https://docs.rs/core/*/core/array/index.html"><cide>[T; N]</code></a> - An inline <em>array</em> with a fixed size at compile time.</li>\n<li><a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>[T]</code></a> - A dynamically sized <em>slice</em> into any other kind of contiguous\nstorage, whether heap-allocated or not.</li>\n</ul>\n<p>Slices can only be handled through some kind of <em>pointer</em>, and as such come\nin many flavors such as:</p>\n<ul>\n<li><cide>&amp;[T]</code> - <em>shared slice</em></li>\n<li><cide>&amp;mut [T]</code> - <em>mutable slice</em></li>\n<li><a href="https://docs.rs/alloc/*/alloc/boxed/index.html"><cide>Box&lt;[T]&gt;</code></a> - <em>owned slice</em></li>\n</ul>\n<p><a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>, a UTF-8 string slice, is a primitive type, and the standard library\ndefines many methods for it. Rust <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>s are typically accessed as\nimmutable references: <cide>&amp;str</code>. Use the owned <a href="https://docs.rs/alloc/*/alloc/string/struct.String.html"><cide>String</code></a> for building and\nmutating strings.</p>\n<p>For converting to strings use the <a href="https://docs.rs/alloc/*/alloc/macro.format.html"><cide>format</code></a> macro, and for converting from\nstrings use the <a href="https://docs.rs/core/*/core/str/traits/trait.FromStr.html"><cide>FromStr</code></a> trait.</p>\n<p>Data may be shared by placing it in a reference-counted box or the <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a>\ntype, and if further contained in a <a href="https://docs.rs/core/*/core/cell/struct.Cell.html"><cide>Cell</code></a> or <a href="https://docs.rs/core/*/core/cell/struct.RefCell.html"><cide>RefCell</code></a>, may be mutated\nas well as shared. Likewise, in a concurrent setting it is common to pair an\natomically-reference-counted box, <a href="https://docs.rs/alloc/*/alloc/sync/struct.Arc.html"><cide>Arc</code></a>, with a <a href="https://docs.rs/std/*/std/sync/mutex/struct.Mutex.html"><cide>Mutex</code></a> to get the same\neffect.</p>\n<p>The <a href="https://docs.rs/std/*/std/collections/index.html"><cide>collections</code></a> module defines maps, sets, linked lists and other\ntypical collection types, including the common <a href="https://docs.rs/std/*/std/collections/hash/map/struct.HashMap.html"><cide>HashMap&lt;K, V&gt;</code></a>.</p>\n<h2 id="platform-abstractions-and-io"><a class="header" href="#platform-abstractions-and-io">Platform abstractions and I/O</a></h2>\n<p>Besides basic data types, the standard library is largely concerned with\nabstracting over differences in common platforms, most notably Windows and\nUnix derivatives.</p>\n<p>Common types of I/O, including <a href="https://docs.rs/std/*/std/fs/struct.File.html">files</a>, <a href="https://docs.rs/std/*/std/net/tcp/struct.TcpStream.html">TCP</a>, <a href="https://docs.rs/std/*/std/net/udp/struct.UdpSocket.html">UDP</a>, are defined in the\n<a href="https://docs.rs/std/*/std/io/index.html"><cide>io</code></a>, <a href="https://docs.rs/std/*/std/fs/index.html"><cide>fs</code></a>, and <a href="https://docs.rs/std/*/std/net/index.html"><cide>net</code></a> modules.</p>\n<p>The <a href="https://docs.rs/std/*/std/thread/index.html"><cide>thread</code></a> module contains Rust#$%s threading abstractions. <a href="https://docs.rs/std/*/std/sync/index.html"><cide>sync</code></a>\ncontains further primitive shared memory types, including <a href="https://docs.rs/core/*/core/sync/atomic/index.html"><cide>atomic</code></a> and\n<a href="https://docs.rs/std/*/std/sync/mpsc/index.html"><cide>mpsc</code></a>, which contains the channel types for message passing.</p>\n','<per><cide class="language-rust">alloc\n</code></pre>\n<per><cide class="language-rust">mod fmt\n</code></pre>\n<hr />\n<p>Utilities for formatting and printing <cide>String</code>s.</p>\n<p>This module contains the runtime support for the <a href="https://docs.rs/alloc/*/alloc/macro.format.html"><cide>format</code></a> syntax extension.\nThis macro is implemented in the compiler to emit calls to this module in\norder to format arguments at runtime into strings.</p>\n<h1 id="usage"><a class="header" href="#usage">Usage</a></h1>\n<p>The <a href="https://docs.rs/alloc/*/alloc/macro.format.html"><cide>format</code></a> macro is intended to be familiar to those coming from C#$%s\n<cide>printf</code>/<cide>fprintf</code> functions or Python#$%s <cide>str.format</code> function.</p>\n<p>Some examples of the <a href="https://docs.rs/alloc/*/alloc/macro.format.html"><cide>format</code></a> extension are:</p>\n<per><cide>format!(&quot;Hello&quot;);                 // =&gt; &quot;Hello&quot;\nformat!(&quot;Hello, {}!&quot;, &quot;world&quot;);   // =&gt; &quot;Hello, world!&quot;\nformat!(&quot;The number is {}&quot;, 1);   // =&gt; &quot;The number is 1&quot;\nformat!(&quot;{:?}&quot;, (3, 4));          // =&gt; &quot;(3, 4)&quot;\nformat!(&quot;{value}&quot;, value=4);      // =&gt; &quot;4&quot;\nformat!(&quot;{} {}&quot;, 1, 2);           // =&gt; &quot;1 2&quot;\nformat!(&quot;{:04}&quot;, 42);             // =&gt; &quot;0042&quot; with leading zeros\nformat!(&quot;{:#?}&quot;, (100, 200));     // =&gt; &quot;(\n                                  //       100,\n                                  //       200,\n                                  //     )&quot;\n</code></pre>\n<p>From these, you can see that the first argument is a format string. It is\nrequired by the compiler for this to be a string literal; it cannot be a\nvariable passed in (in order to perform validity checking). The compiler\nwill then parse the format string and determine if the list of arguments\nprovided is suitable to pass to this format string.</p>\n<p>To convert a single value to a string, use the <a href="https://docs.rs/alloc/*/alloc/string/trait.ToString.html"><cide>to_string</code></a> method. This\nwill use the <a href="https://docs.rs/core/*/core/fmt/trait.Display.html"><cide>Display</code></a> formatting trait.</p>\n<h2 id="positional-parameters"><a class="header" href="#positional-parameters">Positional parameters</a></h2>\n<p>Each formatting argument is allowed to specify which value argument it#$%s\nreferencing, and if omitted it is assumed to be &quot;the next argument&quot;. For\nexample, the format string <cide>{} {} {}</code> would take three parameters, and they\nwould be formatted in the same order as they#$%re given. The format string\n<cide>{2} {1} {0}</code>, however, would format arguments in reverse order.</p>\n<p>Things can get a little tricky once you start intermingling the two types of\npositional specifiers. The &quot;next argument&quot; specifier can be thought of as an\niterator over the argument. Each time a &quot;next argument&quot; specifier is seen,\nthe iterator advances. This leads to behavior like this:</p>\n<per><cide>format!(&quot;{1} {} {0} {}&quot;, 1, 2); // =&gt; &quot;2 1 1 2&quot;\n</code></pre>\n<p>The internal iterator over the argument has not been advanced by the time\nthe first <cide>{}</code> is seen, so it prints the first argument. Then upon reaching\nthe second <cide>{}</code>, the iterator has advanced forward to the second argument.\nEssentially, parameters that explicitly name their argument do not affect\nparameters that do not name an argument in terms of positional specifiers.</p>\n<p>A format string is required to use all of its arguments, otherwise it is a\ncompile-time error. You may refer to the same argument more than once in the\nformat string.</p>\n<h2 id="named-parameters"><a class="header" href="#named-parameters">Named parameters</a></h2>\n<p>Rust itself does not have a Python-like equivalent of named parameters to a\nfunction, but the <a href="https://docs.rs/alloc/*/alloc/macro.format.html"><cide>format</code></a> macro is a syntax extension that allows it to\nleverage named parameters. Named parameters are listed at the end of the\nargument list and have the syntax:</p>\n<per><cide class="language-text">identifier #$%=#$% expression\n</code></pre>\n<p>For example, the following <a href="https://docs.rs/alloc/*/alloc/macro.format.html"><cide>format</code></a> expressions all use named argument:</p>\n<per><cide>format!(&quot;{argument}&quot;, argument = &quot;test&quot;);   // =&gt; &quot;test&quot;\nformat!(&quot;{name} {}&quot;, 1, name = 2);          // =&gt; &quot;2 1&quot;\nformat!(&quot;{a} {c} {b}&quot;, a=&quot;a&quot;, b=#$%b#$%, c=3);  // =&gt; &quot;a 3 b&quot;\n</code></pre>\n<p>It is not valid to put positional parameters (those without names) after\narguments that have names. Like with positional parameters, it is not\nvalid to provide named parameters that are unused by the format string.</p>\n<h1 id="formatting-parameters"><a class="header" href="#formatting-parameters">Formatting Parameters</a></h1>\n<p>Each argument being formatted can be transformed by a number of formatting\nparameters (corresponding to <cide>format_spec</code> in <a href="https://docs.rs/alloc/*/alloc/fmt/index.html#syntax">the syntax</a>). These\nparameters affect the string representation of what#$%s being formatted.</p>\n<h2 id="width"><a class="header" href="#width">Width</a></h2>\n<per><cide>// All of these print &quot;Hello x    !&quot;\nprintln!(&quot;Hello {:5}!&quot;, &quot;x&quot;);\nprintln!(&quot;Hello {:1$}!&quot;, &quot;x&quot;, 5);\nprintln!(&quot;Hello {1:0$}!&quot;, 5, &quot;x&quot;);\nprintln!(&quot;Hello {:width$}!&quot;, &quot;x&quot;, width = 5);\n</code></pre>\n<p>This is a parameter for the &quot;minimum width&quot; that the format should take up.\nIf the value#$%s string does not fill up this many characters, then the\npadding specified by fill/alignment will be used to take up the required\nspace (see below).</p>\n<p>The value for the width can also be provided as a <a href="%60usize%60"><cide>usize</code></a> in the list of\nparameters by adding a postfix <cide>$</code>, indicating that the second argument is\na <a href="%60usize%60"><cide>usize</code></a> specifying the width.</p>\n<p>Referring to an argument with the dollar syntax does not affect the &quot;next\nargument&quot; counter, so it#$%s usually a good idea to refer to arguments by\nposition, or use named arguments.</p>\n<h2 id="fillalignment"><a class="header" href="#fillalignment">Fill/Alignment</a></h2>\n<per><cide>assert_eq!(format!(&quot;Hello {:&lt;5}!&quot;, &quot;x&quot;),  &quot;Hello x    !&quot;);\nassert_eq!(format!(&quot;Hello {:-&lt;5}!&quot;, &quot;x&quot;), &quot;Hello x----!&quot;);\nassert_eq!(format!(&quot;Hello {:^5}!&quot;, &quot;x&quot;),  &quot;Hello   x  !&quot;);\nassert_eq!(format!(&quot;Hello {:&gt;5}!&quot;, &quot;x&quot;),  &quot;Hello     x!&quot;);\n</code></pre>\n<p>The optional fill character and alignment is provided normally in conjunction with the\n<a href="https://docs.rs/alloc/*/alloc/fmt/index.html#width"><cide>width</code></a> parameter. It must be defined before <cide>width</code>, right after the <cide>:</code>.\nThis indicates that if the value being formatted is smaller than\n<cide>width</code> some extra characters will be printed around it.\nFilling comes in the following variants for different alignments:</p>\n<ul>\n<li><cide>[fill]&lt;</code> - the argument is left-aligned in <cide>width</code> columns</li>\n<li><cide>[fill]^</code> - the argument is center-aligned in <cide>width</code> columns</li>\n<li><cide>[fill]&gt;</code> - the argument is right-aligned in <cide>width</code> columns</li>\n</ul>\n<p>The default <a href="https://docs.rs/alloc/*/alloc/fmt/index.html#fillalignment">fill/alignment</a> for non-numerics is a space and\nleft-aligned. The\ndefault for numeric formatters is also a space character but with right-alignment. If\nthe <cide>0</code> flag (see below) is specified for numerics, then the implicit fill character is\n<cide>0</code>.</p>\n<p>Note that alignment may not be implemented by some types. In particular, it\nis not generally implemented for the <cide>Debug</code> trait.  A good way to ensure\npadding is applied is to format your input, then pad this resulting string\nto obtain your output:</p>\n<per><cide>println!(&quot;Hello {:^15}!&quot;, format!(&quot;{:?}&quot;, Some(&quot;hi&quot;))); // =&gt; &quot;Hello   Some(&quot;hi&quot;)   !&quot;\n</code></pre>\n<h2 id="signcidecide0"><a class="header" href="#signcidecide0">Sign/<cide>#</code>/<cide>0</code></a></h2>\n<per><cide>assert_eq!(format!(&quot;Hello {:+}!&quot;, 5), &quot;Hello +5!&quot;);\nassert_eq!(format!(&quot;{:#x}!&quot;, 27), &quot;0x1b!&quot;);\nassert_eq!(format!(&quot;Hello {:05}!&quot;, 5),  &quot;Hello 00005!&quot;);\nassert_eq!(format!(&quot;Hello {:05}!&quot;, -5), &quot;Hello -0005!&quot;);\nassert_eq!(format!(&quot;{:#010x}!&quot;, 27), &quot;0x0000001b!&quot;);\n</code></pre>\n<p>These are all flags altering the behavior of the formatter.</p>\n<ul>\n<li><cide>+</code> - This is intended for numeric types and indicates that the sign\nshould always be printed. Positive signs are never printed by\ndefault, and the negative sign is only printed by default for signed values.\nThis flag indicates that the correct sign (<cide>+</code> or <cide>-</code>) should always be printed.</li>\n<li><cide>-</code> - Currently not used</li>\n<li><cide>#</code> - This flag indicates that the &quot;alternate&quot; form of printing should\nbe used. The alternate forms are:\n<ul>\n<li><cide>#?</code> - pretty-print the <a href="https://docs.rs/core/*/core/fmt/trait.Debug.html"><cide>Debug</code></a> formatting (adds linebreaks and indentation)</li>\n<li><cide>#x</code> - precedes the argument with a <cide>0x</code></li>\n<li><cide>#X</code> - precedes the argument with a <cide>0x</code></li>\n<li><cide>#b</code> - precedes the argument with a <cide>0b</code></li>\n<li><cide>#o</code> - precedes the argument with a <cide>0o</code></li>\n</ul>\n</li>\n<li><cide>0</code> - This is used to indicate for integer formats that the padding to <cide>width</code> should\nboth be done with a <cide>0</code> character as well as be sign-aware. A format\nlike <cide>{:08}</code> would yield <cide>00000001</code> for the integer <cide>1</code>, while the\nsame format would yield <cide>-0000001</code> for the integer <cide>-1</code>. Notice that\nthe negative version has one fewer zero than the positive version.\nNote that padding zeros are always placed after the sign (if any)\nand before the digits. When used together with the <cide>#</code> flag, a similar\nrule applies: padding zeros are inserted after the prefix but before\nthe digits. The prefix is included in the total width.</li>\n</ul>\n<h2 id="precision"><a class="header" href="#precision">Precision</a></h2>\n<p>For non-numeric types, this can be considered a &quot;maximum width&quot;. If the resulting string is\nlonger than this width, then it is truncated down to this many characters and that truncated\nvalue is emitted with proper <cide>fill</code>, <cide>alignment</code> and <cide>width</code> if those parameters are set.</p>\n<p>For integral types, this is ignored.</p>\n<p>For floating-point types, this indicates how many digits after the decimal point should be\nprinted.</p>\n<p>There are three possible ways to specify the desired <cide>precision</code>:</p>\n<ol>\n<li>\n<p>An integer <cide>.N</code>:</p>\n<p>the integer <cide>N</code> itself is the precision.</p>\n</li>\n<li>\n<p>An integer or name followed by dollar sign <cide>.N$</code>:</p>\n<p>use format <em>argument</em> <cide>N</code> (which must be a <cide>usize</code>) as the precision.</p>\n</li>\n<li>\n<p>An asterisk <cide>.*</code>:</p>\n<p><cide>.*</code> means that this <cide>{...}</code> is associated with <em>two</em> format inputs rather than one: the\nfirst input holds the <cide>usize</code> precision, and the second holds the value to print. Note that\nin this case, if one uses the format string <cide>{&lt;arg&gt;:&lt;spec&gt;.*}</code>, then the <cide>&lt;arg&gt;</code> part refers\nto the <em>value</em> to print, and the <cide>precision</code> must come in the input preceding <cide>&lt;arg&gt;</code>.</p>\n</li>\n</ol>\n<p>For example, the following calls all print the same thing <cide>Hello x is 0.01000</code>:</p>\n<per><cide>// Hello {arg 0 (&quot;x&quot;)} is {arg 1 (0.01) with precision specified inline (5)}\nprintln!(&quot;Hello {0} is {1:.5}&quot;, &quot;x&quot;, 0.01);\n\n// Hello {arg 1 (&quot;x&quot;)} is {arg 2 (0.01) with precision specified in arg 0 (5)}\nprintln!(&quot;Hello {1} is {2:.0$}&quot;, 5, &quot;x&quot;, 0.01);\n\n// Hello {arg 0 (&quot;x&quot;)} is {arg 2 (0.01) with precision specified in arg 1 (5)}\nprintln!(&quot;Hello {0} is {2:.1$}&quot;, &quot;x&quot;, 5, 0.01);\n\n// Hello {next arg (&quot;x&quot;)} is {second of next two args (0.01) with precision\n//                          specified in first of next two args (5)}\nprintln!(&quot;Hello {} is {:.*}&quot;,    &quot;x&quot;, 5, 0.01);\n\n// Hello {next arg (&quot;x&quot;)} is {arg 2 (0.01) with precision\n//                          specified in its predecessor (5)}\nprintln!(&quot;Hello {} is {2:.*}&quot;,   &quot;x&quot;, 5, 0.01);\n\n// Hello {next arg (&quot;x&quot;)} is {arg &quot;number&quot; (0.01) with precision specified\n//                          in arg &quot;prec&quot; (5)}\nprintln!(&quot;Hello {} is {number:.prec$}&quot;, &quot;x&quot;, prec = 5, number = 0.01);\n</code></pre>\n<p>While these:</p>\n<per><cide>println!(&quot;{}, `{name:.*}` has 3 fractional digits&quot;, &quot;Hello&quot;, 3, name=1234.56);\nprintln!(&quot;{}, `{name:.*}` has 3 characters&quot;, &quot;Hello&quot;, 3, name=&quot;1234.56&quot;);\nprintln!(&quot;{}, `{name:&gt;8.*}` has 3 right-aligned characters&quot;, &quot;Hello&quot;, 3, name=&quot;1234.56&quot;);\n</code></pre>\n<p>print three significantly different things:</p>\n<per><cide class="language-text">Hello, `1234.560` has 3 fractional digits\nHello, `123` has 3 characters\nHello, `     123` has 3 right-aligned characters\n</code></pre>\n<h2 id="localization"><a class="header" href="#localization">Localization</a></h2>\n<p>In some programming languages, the behavior of string formatting functions\ndepends on the operating system#$%s locale setting. The format functions\nprovided by Rust#$%s standard library do not have any concept of locale and\nwill produce the same results on all systems regardless of user\nconfiguration.</p>\n<p>For example, the following code will always print <cide>1.5</code> even if the system\nlocale uses a decimal separator other than a dot.</p>\n<per><cide>println!(&quot;The value is {}&quot;, 1.5);\n</code></pre>\n<h1 id="escaping"><a class="header" href="#escaping">Escaping</a></h1>\n<p>The literal characters <cide>{</code> and <cide>}</code> may be included in a string by preceding\nthem with the same character. For example, the <cide>{</code> character is escaped with\n<cide>{{</code> and the <cide>}</code> character is escaped with <cide>}}</code>.</p>\n<per><cide>assert_eq!(format!(&quot;Hello {{}}&quot;), &quot;Hello {}&quot;);\nassert_eq!(format!(&quot;{{ Hello&quot;), &quot;{ Hello&quot;);\n</code></pre>\n<h1 id="syntax"><a class="header" href="#syntax">Syntax</a></h1>\n<p>To summarize, here you can find the full grammar of format strings.\nThe syntax for the formatting language used is drawn from other languages,\nso it should not be too alien. Arguments are formatted with Python-like\nsyntax, meaning that arguments are surrounded by <cide>{}</code> instead of the C-like\n<cide>%</code>. The actual grammar for the formatting syntax is:</p>\n<per><cide class="language-text">format_string := text [ maybe_format text ] *\nmaybe_format := #$%{#$% #$%{#$% | #$%}#$% #$%}#$% | format\nformat := #$%{#$% [ argument ] [ #$%:#$% format_spec ] #$%}#$%\nargument := integer | identifier\n\nformat_spec := [[fill]align][sign][#$%##$%][#$%0#$%][width][#$%.#$% precision]type\nfill := character\nalign := #$%&lt;#$% | #$%^#$% | #$%&gt;#$%\nsign := #$%+#$% | #$%-#$%\nwidth := count\nprecision := count | #$%*#$%\ntype := #$%#$% | #$%?#$% | #$%x?#$% | #$%X?#$% | identifier\ncount := parameter | integer\nparameter := argument #$%$#$%\n</code></pre>\n<p>In the above grammar, <cide>text</code> may not contain any <cide>#$%{#$%</code> or <cide>#$%}#$%</code> characters.</p>\n<h1 id="formatting-traits"><a class="header" href="#formatting-traits">Formatting traits</a></h1>\n<p>When requesting that an argument be formatted with a particular type, you\nare actually requesting that an argument ascribes to a particular trait.\nThis allows multiple actual types to be formatted via <cide>{:x}</code> (like <a href="%60i8%60"><cide>i8</code></a> as\nwell as <a href="%60isize%60"><cide>isize</code></a>). The current mapping of types to traits is:</p>\n<ul>\n<li><em>nothing</em> ⇒ <a href="https://docs.rs/core/*/core/fmt/trait.Display.html"><cide>Display</code></a></li>\n<li><cide>?</code> ⇒ <a href="https://docs.rs/core/*/core/fmt/trait.Debug.html"><cide>Debug</code></a></li>\n<li><cide>x?</code> ⇒ <a href="https://docs.rs/core/*/core/fmt/trait.Debug.html"><cide>Debug</code></a> with lower-case hexadecimal integers</li>\n<li><cide>X?</code> ⇒ <a href="https://docs.rs/core/*/core/fmt/trait.Debug.html"><cide>Debug</code></a> with upper-case hexadecimal integers</li>\n<li><cide>o</code> ⇒ <a href="https://docs.rs/core/*/core/fmt/trait.Octal.html"><cide>Octal</code></a></li>\n<li><cide>x</code> ⇒ <a href="https://docs.rs/core/*/core/fmt/trait.LowerHex.html"><cide>LowerHex</code></a></li>\n<li><cide>X</code> ⇒ <a href="https://docs.rs/core/*/core/fmt/trait.UpperHex.html"><cide>UpperHex</code></a></li>\n<li><cide>p</code> ⇒ <a href="https://docs.rs/core/*/core/fmt/trait.Pointer.html"><cide>Pointer</code></a></li>\n<li><cide>b</code> ⇒ <a href="https://docs.rs/core/*/core/fmt/trait.Binary.html"><cide>Binary</code></a></li>\n<li><cide>e</code> ⇒ <a href="https://docs.rs/core/*/core/fmt/trait.LowerExp.html"><cide>LowerExp</code></a></li>\n<li><cide>E</code> ⇒ <a href="https://docs.rs/core/*/core/fmt/trait.UpperExp.html"><cide>UpperExp</code></a></li>\n</ul>\n<p>What this means is that any type of argument which implements the\n<a href="https://docs.rs/core/*/core/fmt/trait.Binary.html"><cide>fmt::Binary</code></a> trait can then be formatted with <cide>{:b}</code>. Implementations\nare provided for these traits for a number of primitive types by the\nstandard library as well. If no format is specified (as in <cide>{}</code> or <cide>{:6}</code>),\nthen the format trait used is the <a href="https://docs.rs/core/*/core/fmt/trait.Display.html"><cide>Display</code></a> trait.</p>\n<p>When implementing a format trait for your own type, you will have to\nimplement a method of the signature:</p>\n<per><cide># #![allow(dead_code)]\n# use std::fmt;\n# struct Foo; // our custom type\n# impl fmt::Display for Foo {\nfn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n# write!(f, &quot;testing, testing&quot;)\n# } }\n</code></pre>\n<p>Your type will be passed as <cide>self</code> by-reference, and then the function\nshould emit output into the <cide>f.buf</code> stream. It is up to each format trait\nimplementation to correctly adhere to the requested formatting parameters.\nThe values of these parameters will be listed in the fields of the\n<a href="https://docs.rs/core/*/core/fmt/struct.Formatter.html"><cide>Formatter</code></a> struct. In order to help with this, the <a href="https://docs.rs/core/*/core/fmt/struct.Formatter.html"><cide>Formatter</code></a> struct also\nprovides some helper methods.</p>\n<p>Additionally, the return value of this function is <a href="https://docs.rs/core/*/core/fmt/type.Result.html"><cide>fmt::Result</code></a> which is a\ntype alias of <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Result</code></a><cide>&lt;(), </code><a href="https://docs.rs/core/*/core/fmt/struct.Error.html"><cide>std::fmt::Error</code></a><cide>&gt;</code>. Formatting implementations\nshould ensure that they propagate errors from the <a href="https://docs.rs/core/*/core/fmt/struct.Formatter.html"><cide>Formatter</code></a> (e.g., when\ncalling <a href="https://docs.rs/core/*/core/macro.write.html"><cide>write</code></a>). However, they should never return errors spuriously. That\nis, a formatting implementation must and may only return an error if the\npassed-in <a href="https://docs.rs/core/*/core/fmt/struct.Formatter.html"><cide>Formatter</code></a> returns an error. This is because, contrary to what\nthe function signature might suggest, string formatting is an infallible\noperation. This function only returns a result because writing to the\nunderlying stream might fail and it must provide a way to propagate the fact\nthat an error has occurred back up the stack.</p>\n<p>An example of implementing the formatting traits would look\nlike:</p>\n<per><cide>use std::fmt;\n\n#[derive(Debug)]\nstruct Vector2D {\n    x: isize,\n    y: isize,\n}\n\nimpl fmt::Display for Vector2D {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        // The `f` value implements the `Write` trait, which is what the\n        // write! macro is expecting. Note that this formatting ignores the\n        // various flags provided to format strings.\n        write!(f, &quot;({}, {})&quot;, self.x, self.y)\n    }\n}\n\n// Different traits allow different forms of output of a type. The meaning\n// of this format is to print the magnitude of a vector.\nimpl fmt::Binary for Vector2D {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        let magnitude = (self.x * self.x + self.y * self.y) as f64;\n        let magnitude = magnitude.sqrt();\n\n        // Respect the formatting flags by using the helper method\n        // `pad_integral` on the Formatter object. See the method\n        // documentation for details, and the function `pad` can be used\n        // to pad strings.\n        let decimals = f.precision().unwrap_or(3);\n        let string = format!(&quot;{:.*}&quot;, decimals, magnitude);\n        f.pad_integral(true, &quot;&quot;, &amp;string)\n    }\n}\n\nfn main() {\n    let myvector = Vector2D { x: 3, y: 4 };\n\n    println!(&quot;{}&quot;, myvector);       // =&gt; &quot;(3, 4)&quot;\n    println!(&quot;{:?}&quot;, myvector);     // =&gt; &quot;Vector2D {x: 3, y:4}&quot;\n    println!(&quot;{:10.3b}&quot;, myvector); // =&gt; &quot;     5.000&quot;\n}\n</code></pre>\n<h3 id="cidefmtdisplay-vs-cidefmtdebug"><a class="header" href="#cidefmtdisplay-vs-cidefmtdebug"><cide>fmt::Display</code> vs <cide>fmt::Debug</code></a></h3>\n<p>These two formatting traits have distinct purposes:</p>\n<ul>\n<li><a href="https://docs.rs/core/*/core/fmt/trait.Display.html"><cide>fmt::Display</code></a> implementations assert that the type can be faithfully\nrepresented as a UTF-8 string at all times. It is <strong>not</strong> expected that\nall types implement the <a href="https://docs.rs/core/*/core/fmt/trait.Display.html"><cide>Display</code></a> trait.</li>\n<li><a href="https://docs.rs/core/*/core/fmt/trait.Debug.html"><cide>fmt::Debug</code></a> implementations should be implemented for <strong>all</strong> public types.\nOutput will typically represent the internal state as faithfully as possible.\nThe purpose of the <a href="https://docs.rs/core/*/core/fmt/trait.Debug.html"><cide>Debug</code></a> trait is to facilitate debugging Rust code. In\nmost cases, using <cide>#[derive(Debug)]</code> is sufficient and recommended.</li>\n</ul>\n<p>Some examples of the output from both traits:</p>\n<per><cide>assert_eq!(format!(&quot;{} {:?}&quot;, 3, 4), &quot;3 4&quot;);\nassert_eq!(format!(&quot;{} {:?}&quot;, #$%a#$%, #$%b#$%), &quot;a #$%b#$%&quot;);\nassert_eq!(format!(&quot;{} {:?}&quot;, &quot;foo\n&quot;, &quot;bar\n&quot;), &quot;foo\n \&quot;bar\\n\&quot;&quot;);\n</code></pre>\n<h1 id="related-macros"><a class="header" href="#related-macros">Related macros</a></h1>\n<p>There are a number of related macros in the <a href="https://docs.rs/alloc/*/alloc/macro.format.html"><cide>format</code></a> family. The ones that\nare currently implemented are:</p>\n<per><cide class="language-ignore">format!      // described above\nwrite!       // first argument is a &amp;mut io::Write, the destination\nwriteln!     // same as write but appends a newline\nprint!       // the format string is printed to the standard output\nprintln!     // same as print but appends a newline\neprint!      // the format string is printed to the standard error\neprintln!    // same as eprint but appends a newline\nformat_args! // described below.\n</code></pre>\n<h3 id="cidewrite"><a class="header" href="#cidewrite"><cide>write!</code></a></h3>\n<p>This and <a href="https://docs.rs/core/*/core/macro.writeln.html"><cide>writeln</code></a> are two macros which are used to emit the format string\nto a specified stream. This is used to prevent intermediate allocations of\nformat strings and instead directly write the output. Under the hood, this\nfunction is actually invoking the <a href="https://docs.rs/alloc/*/std/io/trait.Write.html#method.write_fmt"><cide>write_fmt</code></a> function defined on the\n<a href="https://docs.rs/alloc/*/std/io/trait.Write.html"><cide>std::io::Write</code></a> trait. Example usage is:</p>\n<per><cide># #![allow(unused_must_use)]\nuse std::io::Write;\nlet mut w = Vec::new();\nwrite!(&amp;mut w, &quot;Hello {}!&quot;, &quot;world&quot;);\n</code></pre>\n<h3 id="cideprint"><a class="header" href="#cideprint"><cide>print!</code></a></h3>\n<p>This and <a href="https://docs.rs/alloc/*/std/macro.println.html"><cide>println!</code></a> emit their output to stdout. Similarly to the <a href="https://docs.rs/core/*/core/macro.write.html"><cide>write</code></a>\nmacro, the goal of these macros is to avoid intermediate allocations when\nprinting output. Example usage is:</p>\n<per><cide>print!(&quot;Hello {}!&quot;, &quot;world&quot;);\nprintln!(&quot;I have a newline {}&quot;, &quot;character at the end&quot;);\n</code></pre>\n<h3 id="cideeprint"><a class="header" href="#cideeprint"><cide>eprint!</code></a></h3>\n<p>The <a href="https://docs.rs/alloc/*/std/macro.eprint.html"><cide>eprint!</code></a> and <a href="https://docs.rs/alloc/*/std/macro.eprintln.html"><cide>eprintln!</code></a> macros are identical to\n<a href="https://docs.rs/alloc/*/std/macro.print.html"><cide>print!</code></a> and <a href="https://docs.rs/alloc/*/std/macro.println.html"><cide>println!</code></a>, respectively, except they emit their\noutput to stderr.</p>\n<h3 id="cideformat_args"><a class="header" href="#cideformat_args"><cide>format_args!</code></a></h3>\n<p>This is a curious macro used to safely pass around\nan opaque object describing the format string. This object\ndoes not require any heap allocations to create, and it only\nreferences information on the stack. Under the hood, all of\nthe related macros are implemented in terms of this. First\noff, some example usage is:</p>\n<per><cide># #![allow(unused_must_use)]\nuse std::fmt;\nuse std::io::{self, Write};\n\nlet mut some_writer = io::stdout();\nwrite!(&amp;mut some_writer, &quot;{}&quot;, format_args!(&quot;print with a {}&quot;, &quot;macro&quot;));\n\nfn my_fmt_fn(args: fmt::Arguments) {\n    write!(&amp;mut io::stdout(), &quot;{}&quot;, args);\n}\nmy_fmt_fn(format_args!(&quot;, or a {} too&quot;, &quot;function&quot;));\n</code></pre>\n<p>The result of the <a href="https://docs.rs/core/*/core/macro.format_args.html"><cide>format_args</code></a> macro is a value of type <a href="https://docs.rs/core/*/core/fmt/struct.Arguments.html"><cide>fmt::Arguments</code></a>.\nThis structure can then be passed to the <a href="https://docs.rs/core/*/core/macro.write.html"><cide>write</code></a> and <a href="https://docs.rs/alloc/*/alloc/macro.format.html"><cide>format</code></a> functions\ninside this module in order to process the format string.\nThe goal of this macro is to even further prevent intermediate allocations\nwhen dealing with formatting strings.</p>\n<p>For example, a logging library could use the standard formatting syntax, but\nit would internally pass around this structure until it has been determined\nwhere output should go to.</p>\n','<per><cide class="language-rust">core::fmt\n</code></pre>\n<per><cide class="language-rust">pub trait Display\n</code></pre>\n<hr />\n<p>Format trait for an empty format, <cide>{}</code>.</p>\n<p><cide>Display</code> is similar to <a href="https://docs.rs/core/*/core/fmt/trait.Debug.html"><cide>Debug</code></a>, but <cide>Display</code> is for user-facing\noutput, and so cannot be derived.</p>\n<p>For more information on formatters, see <a href="https://docs.rs/core/*/std/fmt/index.html">the module-level documentation</a>.</p>\n<h1 id="examples-5"><a class="header" href="#examples-5">Examples</a></h1>\n<p>Implementing <cide>Display</code> on a type:</p>\n<per><cide>use std::fmt;\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl fmt::Display for Point {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;#$%_&gt;) -&gt; fmt::Result {\n        write!(f, &quot;({}, {})&quot;, self.x, self.y)\n    }\n}\n\nlet origin = Point { x: 0, y: 0 };\n\nassert_eq!(format!(&quot;The origin is: {}&quot;, origin), &quot;The origin is: (0, 0)&quot;);\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">struct Pair&lt;T&gt;\n</code></pre>\n','<per><cide class="language-rust">playcrate::Pair\n</code></pre>\n<per><cide class="language-rust">x: T\n</code></pre>\n','<per><cide class="language-rust">playcrate::Pair\n</code></pre>\n<per><cide class="language-rust">y: T\n</code></pre>\n','<per><cide class="language-rust">playcrate::Pair\n</code></pre>\n<per><cide class="language-rust">fn new(x: T, y: T) -&gt; Self\n</code></pre>\n','<per><cide class="language-rust">x: T\n</code></pre>\n','<per><cide class="language-rust">y: T\n</code></pre>\n','<per><cide class="language-rust">T: Display + PartialOrd&lt;T&gt;\n</code></pre>\n','<per><cide class="language-rust">playcrate::Pair\n</code></pre>\n<per><cide class="language-rust">fn cmp_display(&amp;self)\n</code></pre>\n','<per><cide class="language-rust">self: &amp;Pair&lt;T&gt;\n</code></pre>\n','<per><cide class="language-rust">alloc::string\n</code></pre>\n<per><cide class="language-rust">pub trait ToString\n</code></pre>\n<hr />\n<p>A trait for converting a value to a <cide>String</code>.</p>\n<p>This trait is automatically implemented for any type which implements the\n<a href="https://docs.rs/core/*/core/fmt/trait.Display.html"><cide>Display</code></a> trait. As such, <cide>ToString</code> shouldn#$%t be implemented directly:\n<a href="https://docs.rs/core/*/core/fmt/trait.Display.html"><cide>Display</code></a> should be implemented instead, and you get the <cide>ToString</code>\nimplementation for free.</p>\n','<per><cide class="language-rust">let s: String\n</code></pre>\n','<per><cide class="language-rust">alloc::string::ToString\n</code></pre>\n<per><cide class="language-rust">pub fn to_string(&amp;self) -&gt; String\n</code></pre>\n<hr />\n<p>Converts the given value to a <cide>String</code>.</p>\n<h1 id="examples-6"><a class="header" href="#examples-6">Examples</a></h1>\n<p>Basic usage:</p>\n<per><cide>let i = 5;\nlet five = String::from(&quot;5&quot;);\n\nassert_eq!(five, i.to_string());\n</code></pre>\n',].map((x)=>x.replaceAll('#$%', "'").replaceAll('<per', '<pre').replaceAll('<cide', '<code'));
    window.onload = () => {
        console.log("hello");
        tippy('.ra', {
            content: (x) => {
                const div = document.createElement('div');
                div.innerHTML = hoverData[x.dataset.hover];
                div.className = 'hover-holder';
                div.querySelectorAll('code').forEach((y) => y.innerHTML = hljs.highlight('rust', y.innerText).value);
                return div;
            },
            allowHTML: true,
            delay: [200, 0],
            interactive: true,
            maxWidth: '80vw',
            appendTo: document.querySelector('.content'),
        });
    };
</script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="ch10-01-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="ch10-03-lifetime-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="ch10-01-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="ch10-03-lifetime-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="ferris.js"></script>
        
        
    </body>
</html>
