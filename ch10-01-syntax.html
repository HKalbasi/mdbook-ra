<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Generic Data Types - The Rust Programming Language</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="ferris.css">
                <link rel="stylesheet" href="theme/2018-edition.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References and Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> The Slice Type</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html" class="active"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> How to Write Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlling How Tests Are Run</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.inlay-hint, .inlay-hint * {
    border-radius: .4em;
}

.light .inlay-hint, .rust .inlay-hint {
    background-color: #dcc;
    color: #777;
}

.ayu .inlay-hint, .navy .inlay-hint, .coal .inlay-hint {
    background-color: #444;
    color: #999;
}

.inlay-hint {
    font-size: 0.8em;
    user-select: none;
}
.hover-holder {
    max-height: 40vh;
    overflow: auto;
}

.tippy-content {
    background-color: var(--bg);
    color: var(--fg);
}
</style>## Generic Data Types
<p>We can use generics to create definitions for items like function signatures or
structs, which we can then use with many different concrete data types. Let’s
first look at how to define functions, structs, enums, and methods using
generics. Then we’ll discuss how generics affect code performance.</p>
<h3 id="in-function-definitions"><a class="header" href="#in-function-definitions">In Function Definitions</a></h3>
<p>When defining a function that uses generics, we place the generics in the
signature of the function where we would usually specify the data types of the
parameters and return value. Doing so makes our code more flexible and provides
more functionality to callers of our function while preventing code duplication.</p>
<p>Continuing with our <code>largest</code> function, Listing 10-4 shows two functions that
both find the largest value in a slice.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn <span class="ra" data-hover="0">largest_i32</span>(<span class="ra" data-hover="1">list</span>: &amp;[<span class="ra" data-hover="2">i32</span>]) -&gt; <span class="ra" data-hover="2">i32</span> {
    let mut <span class="ra" data-hover="3">largest</span><span class="inlay-hint">: i32</span> = <span class="ra" data-hover="1">list</span>[0];

    for &amp;<span class="ra" data-hover="4">item</span><span class="inlay-hint">: i32</span> in <span class="ra" data-hover="1">list</span> {
        if <span class="ra" data-hover="4">item</span> &gt; <span class="ra" data-hover="3">largest</span> {
            <span class="ra" data-hover="3">largest</span> = <span class="ra" data-hover="4">item</span>;
        }
    }

    <span class="ra" data-hover="3">largest
}

fn <span class="ra" data-hover="5">largest_char</span>(<span class="ra" data-hover="6">list</span>: &amp;[<span class="ra" data-hover="7">char</span>]) -&gt; <span class="ra" data-hover="7">char</span> {
    let mut <span class="ra" data-hover="8">largest</span><span class="inlay-hint">: char</span> = <span class="ra" data-hover="6">list</span>[0];

    for &amp;<span class="ra" data-hover="9">item</span><span class="inlay-hint">: char</span> in <span class="ra" data-hover="6">list</span> {
        if <span class="ra" data-hover="9">item</span> &gt; <span class="ra" data-hover="8">largest</span> {
            <span class="ra" data-hover="8">largest</span> = <span class="ra" data-hover="9">item</span>;
        }
    }

    <span class="ra" data-hover="8">largest
}

fn <span class="ra" data-hover="10">main</span>() {
    let <span class="ra" data-hover="11">number_list</span><span class="inlay-hint">: Vec&lt;i32&gt;</span> = <span class="ra" data-hover="12">vec</span>![34, 50, 25, 100, 65];

    let <span class="ra" data-hover="13">result</span><span class="inlay-hint">: i32</span> = <span class="ra" data-hover="0">largest_i32</span>(&amp;<span class="ra" data-hover="11">number_list</span>);
    <span class="ra" data-hover="14">println</span>!("The largest number is {}", <span class="ra" data-hover="13">result</span>);
<span class="boring">    assert_eq!(result, 100);
</span>
    let <span class="ra" data-hover="16">char_list</span><span class="inlay-hint">: Vec&lt;char&gt;</span> = <span class="ra" data-hover="12">vec</span>!['y', 'm', 'a', 'q'];

    let <span class="ra" data-hover="17">result</span><span class="inlay-hint">: char</span> = <span class="ra" data-hover="5">largest_char</span>(&amp;<span class="ra" data-hover="16">char_list</span>);
    <span class="ra" data-hover="14">println</span>!("The largest char is {}", <span class="ra" data-hover="17">result</span>);
<span class="boring">    assert_eq!(result, 'y');
</span>}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-4: Two functions that differ only in their
names and the types in their signatures</span></p>
<p>The <code>largest_i32</code> function is the one we extracted in Listing 10-3 that finds
the largest <code>i32</code> in a slice. The <code>largest_char</code> function finds the largest
<code>char</code> in a slice. The function bodies have the same code, so let’s eliminate
the duplication by introducing a generic type parameter in a single function.</p>
<p>To parameterize the types in the new function we’ll define, we need to name the
type parameter, just as we do for the value parameters to a function. You can
use any identifier as a type parameter name. But we’ll use <code>T</code> because, by
convention, parameter names in Rust are short, often just a letter, and Rust’s
type-naming convention is CamelCase. Short for “type,” <code>T</code> is the default
choice of most Rust programmers.</p>
<p>When we use a parameter in the body of the function, we have to declare the
parameter name in the signature so the compiler knows what that name means.
Similarly, when we use a type parameter name in a function signature, we have
to declare the type parameter name before we use it. To define the generic
<code>largest</code> function, place type name declarations inside angle brackets, <code>&lt;&gt;</code>,
between the name of the function and the parameter list, like this:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn <span class="ra" data-hover="18">largest</span>&lt;<span class="ra" data-hover="19">T</span>&gt;(<span class="ra" data-hover="20">list</span>: &amp;[<span class="ra" data-hover="19">T</span>]) -&gt; <span class="ra" data-hover="19">T</span> {
<span class="boring">}
</span>
</code></pre></pre>
<p>We read this definition as: the function <code>largest</code> is generic over some type
<code>T</code>. This function has one parameter named <code>list</code>, which is a slice of values
of type <code>T</code>. The <code>largest</code> function will return a value of the
same type <code>T</code>.</p>
<p>Listing 10-5 shows the combined <code>largest</code> function definition using the generic
data type in its signature. The listing also shows how we can call the function
with either a slice of <code>i32</code> values or <code>char</code> values. Note that this code won’t
compile yet, but we’ll fix it later in this chapter.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn <span class="ra" data-hover="18">largest</span>&lt;<span class="ra" data-hover="19">T</span>&gt;(<span class="ra" data-hover="20">list</span>: &amp;[<span class="ra" data-hover="19">T</span>]) -&gt; <span class="ra" data-hover="19">T</span> {
    let mut <span class="ra" data-hover="21">largest</span><span class="inlay-hint">: T</span> = <span class="ra" data-hover="20">list</span>[0];

    for &amp;<span class="ra" data-hover="22">item</span><span class="inlay-hint">: T</span> in <span class="ra" data-hover="20">list</span> {
        if <span class="ra" data-hover="22">item</span> &gt; <span class="ra" data-hover="21">largest</span> {
            <span class="ra" data-hover="21">largest</span> = <span class="ra" data-hover="22">item</span>;
        }
    }

    <span class="ra" data-hover="21">largest
}

fn <span class="ra" data-hover="10">main</span>() {
    let <span class="ra" data-hover="11">number_list</span><span class="inlay-hint">: Vec&lt;i32&gt;</span> = <span class="ra" data-hover="12">vec</span>![34, 50, 25, 100, 65];

    let <span class="ra" data-hover="13">result</span><span class="inlay-hint">: i32</span> = <span class="ra" data-hover="18">largest</span>(&amp;<span class="ra" data-hover="11">number_list</span>);
    <span class="ra" data-hover="14">println</span>!("The largest number is {}", <span class="ra" data-hover="13">result</span>);

    let <span class="ra" data-hover="16">char_list</span><span class="inlay-hint">: Vec&lt;char&gt;</span> = <span class="ra" data-hover="12">vec</span>!['y', 'm', 'a', 'q'];

    let <span class="ra" data-hover="17">result</span><span class="inlay-hint">: char</span> = <span class="ra" data-hover="18">largest</span>(&amp;<span class="ra" data-hover="16">char_list</span>);
    <span class="ra" data-hover="14">println</span>!("The largest char is {}", <span class="ra" data-hover="17">result</span>);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-5: A definition of the <code>largest</code> function that
uses generic type parameters but doesn’t compile yet</span></p>
<p>If we compile this code right now, we’ll get this error:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {
  |             ^^^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>The note mentions <code>std::cmp::PartialOrd</code>, which is a <em>trait</em>. We’ll talk about
traits in the next section. For now, this error states that the body of
<code>largest</code> won’t work for all possible types that <code>T</code> could be. Because we want
to compare values of type <code>T</code> in the body, we can only use types whose values
can be ordered. To enable comparisons, the standard library has the
<code>std::cmp::PartialOrd</code> trait that you can implement on types (see Appendix C
for more on this trait). You’ll learn how to specify that a generic type has a
particular trait in the <a href="ch10-02-traits.html#traits-as-parameters">“Traits as Parameters”</a><!--
ignore --> section, but let’s first explore other ways of using generic type
parameters.</p>
<h3 id="in-struct-definitions"><a class="header" href="#in-struct-definitions">In Struct Definitions</a></h3>
<p>We can also define structs to use a generic type parameter in one or more
fields using the <code>&lt;&gt;</code> syntax. Listing 10-6 shows how to define a <code>Point&lt;T&gt;</code>
struct to hold <code>x</code> and <code>y</code> coordinate values of any type.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct <span class="ra" data-hover="23">Point</span>&lt;<span class="ra" data-hover="19">T</span>&gt; {
    <span class="ra" data-hover="24">x</span>: <span class="ra" data-hover="19">T</span>,
    <span class="ra" data-hover="25">y</span>: <span class="ra" data-hover="19">T</span>,
}

fn <span class="ra" data-hover="10">main</span>() {
    let <span class="ra" data-hover="26">integer</span><span class="inlay-hint">: Point&lt;i32&gt;</span> = <span class="ra" data-hover="23">Point</span> { <span class="ra" data-hover="24">x</span>: 5, <span class="ra" data-hover="25">y</span>: 10 };
    let <span class="ra" data-hover="27">float</span><span class="inlay-hint">: Point&lt;f64&gt;</span> = <span class="ra" data-hover="23">Point</span> { <span class="ra" data-hover="24">x</span>: 1.0, <span class="ra" data-hover="25">y</span>: 4.0 };
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-6: A <code>Point&lt;T&gt;</code> struct that holds <code>x</code> and <code>y</code>
values of type <code>T</code></span></p>
<p>The syntax for using generics in struct definitions is similar to that used in
function definitions. First, we declare the name of the type parameter inside
angle brackets just after the name of the struct. Then we can use the generic
type in the struct definition where we would otherwise specify concrete data
types.</p>
<p>Note that because we’ve used only one generic type to define <code>Point&lt;T&gt;</code>, this
definition says that the <code>Point&lt;T&gt;</code> struct is generic over some type <code>T</code>, and
the fields <code>x</code> and <code>y</code> are <em>both</em> that same type, whatever that type may be. If
we create an instance of a <code>Point&lt;T&gt;</code> that has values of different types, as in
Listing 10-7, our code won’t compile.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct <span class="ra" data-hover="23">Point</span>&lt;<span class="ra" data-hover="19">T</span>&gt; {
    <span class="ra" data-hover="24">x</span>: <span class="ra" data-hover="19">T</span>,
    <span class="ra" data-hover="25">y</span>: <span class="ra" data-hover="19">T</span>,
}

fn <span class="ra" data-hover="10">main</span>() {
    let <span class="ra" data-hover="28">wont_work</span><span class="inlay-hint">: Point&lt;i32&gt;</span> = <span class="ra" data-hover="23">Point</span> { <span class="ra" data-hover="24">x</span>: 5, <span class="ra" data-hover="25">y</span>: 4.0 };
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-7: The fields <code>x</code> and <code>y</code> must be the same
type because both have the same generic data type <code>T</code>.</span></p>
<p>In this example, when we assign the integer value 5 to <code>x</code>, we let the
compiler know that the generic type <code>T</code> will be an integer for this instance of
<code>Point&lt;T&gt;</code>. Then when we specify 4.0 for <code>y</code>, which we’ve defined to have the
same type as <code>x</code>, we’ll get a type mismatch error like this:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
</code></pre>
<p>To define a <code>Point</code> struct where <code>x</code> and <code>y</code> are both generics but could have
different types, we can use multiple generic type parameters. For example, in
Listing 10-8, we can change the definition of <code>Point</code> to be generic over types
<code>T</code> and <code>U</code> where <code>x</code> is of type <code>T</code> and <code>y</code> is of type <code>U</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct <span class="ra" data-hover="29">Point</span>&lt;<span class="ra" data-hover="19">T</span>, <span class="ra" data-hover="30">U</span>&gt; {
    <span class="ra" data-hover="24">x</span>: <span class="ra" data-hover="19">T</span>,
    <span class="ra" data-hover="31">y</span>: <span class="ra" data-hover="30">U</span>,
}

fn <span class="ra" data-hover="10">main</span>() {
    let <span class="ra" data-hover="32">both_integer</span><span class="inlay-hint">: Point&lt;i32, i32&gt;</span> = <span class="ra" data-hover="29">Point</span> { <span class="ra" data-hover="24">x</span>: 5, <span class="ra" data-hover="31">y</span>: 10 };
    let <span class="ra" data-hover="33">both_float</span><span class="inlay-hint">: Point&lt;f64, f64&gt;</span> = <span class="ra" data-hover="29">Point</span> { <span class="ra" data-hover="24">x</span>: 1.0, <span class="ra" data-hover="31">y</span>: 4.0 };
    let <span class="ra" data-hover="34">integer_and_float</span><span class="inlay-hint">: Point&lt;i32, f64&gt;</span> = <span class="ra" data-hover="29">Point</span> { <span class="ra" data-hover="24">x</span>: 5, <span class="ra" data-hover="31">y</span>: 4.0 };
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-8: A <code>Point&lt;T, U&gt;</code> generic over two types so
that <code>x</code> and <code>y</code> can be values of different types</span></p>
<p>Now all the instances of <code>Point</code> shown are allowed! You can use as many generic
type parameters in a definition as you want, but using more than a few makes
your code hard to read. When you need lots of generic types in your code, it
could indicate that your code needs restructuring into smaller pieces.</p>
<h3 id="in-enum-definitions"><a class="header" href="#in-enum-definitions">In Enum Definitions</a></h3>
<p>As we did with structs, we can define enums to hold generic data types in their
variants. Let’s take another look at the <code>Option&lt;T&gt;</code> enum that the standard
library provides, which we used in Chapter 6:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum <span class="ra" data-hover="35">Option</span>&lt;<span class="ra" data-hover="19">T</span>&gt; {
    <span class="ra" data-hover="36">Some</span>(<span class="ra" data-hover="19">T</span>),
    <span class="ra" data-hover="37">None</span>,
}
<span class="boring">}
</span>
</code></pre></pre>
<p>This definition should now make more sense to you. As you can see, <code>Option&lt;T&gt;</code>
is an enum that is generic over type <code>T</code> and has two variants: <code>Some</code>, which
holds one value of type <code>T</code>, and a <code>None</code> variant that doesn’t hold any value.
By using the <code>Option&lt;T&gt;</code> enum, we can express the abstract concept of having an
optional value, and because <code>Option&lt;T&gt;</code> is generic, we can use this abstraction
no matter what the type of the optional value is.</p>
<p>Enums can use multiple generic types as well. The definition of the <code>Result</code>
enum that we used in Chapter 9 is one example:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum <span class="ra" data-hover="38">Result</span>&lt;<span class="ra" data-hover="19">T</span>, <span class="ra" data-hover="39">E</span>&gt; {
    <span class="ra" data-hover="40">Ok</span>(<span class="ra" data-hover="19">T</span>),
    <span class="ra" data-hover="41">Err</span>(<span class="ra" data-hover="39">E</span>),
}
<span class="boring">}
</span>
</code></pre></pre>
<p>The <code>Result</code> enum is generic over two types, <code>T</code> and <code>E</code>, and has two variants:
<code>Ok</code>, which holds a value of type <code>T</code>, and <code>Err</code>, which holds a value of type
<code>E</code>. This definition makes it convenient to use the <code>Result</code> enum anywhere we
have an operation that might succeed (return a value of some type <code>T</code>) or fail
(return an error of some type <code>E</code>). In fact, this is what we used to open a
file in Listing 9-3, where <code>T</code> was filled in with the type <code>std::fs::File</code> when
the file was opened successfully and <code>E</code> was filled in with the type
<code>std::io::Error</code> when there were problems opening the file.</p>
<p>When you recognize situations in your code with multiple struct or enum
definitions that differ only in the types of the values they hold, you can
avoid duplication by using generic types instead.</p>
<h3 id="in-method-definitions"><a class="header" href="#in-method-definitions">In Method Definitions</a></h3>
<p>We can implement methods on structs and enums (as we did in Chapter 5) and use
generic types in their definitions, too. Listing 10-9 shows the <code>Point&lt;T&gt;</code>
struct we defined in Listing 10-6 with a method named <code>x</code> implemented on it.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct <span class="ra" data-hover="23">Point</span>&lt;<span class="ra" data-hover="19">T</span>&gt; {
    <span class="ra" data-hover="24">x</span>: <span class="ra" data-hover="19">T</span>,
    <span class="ra" data-hover="25">y</span>: <span class="ra" data-hover="19">T</span>,
}

impl&lt;<span class="ra" data-hover="19">T</span>&gt; <span class="ra" data-hover="23">Point</span>&lt;<span class="ra" data-hover="19">T</span>&gt; {
    fn <span class="ra" data-hover="42">x</span>(&amp;<span class="ra" data-hover="43">self</span>) -&gt; &amp;<span class="ra" data-hover="19">T</span> {
        &amp;<span class="ra" data-hover="43">self</span>.<span class="ra" data-hover="24">x
    }
}

fn <span class="ra" data-hover="10">main</span>() {
    let <span class="ra" data-hover="44">p</span><span class="inlay-hint">: Point&lt;i32&gt;</span> = <span class="ra" data-hover="23">Point</span> { <span class="ra" data-hover="24">x</span>: 5, <span class="ra" data-hover="25">y</span>: 10 };

    <span class="ra" data-hover="14">println</span>!("p.x = {}", <span class="ra" data-hover="44">p</span>.<span class="ra" data-hover="42">x</span>());
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-9: Implementing a method named <code>x</code> on the
<code>Point&lt;T&gt;</code> struct that will return a reference to the <code>x</code> field of type
<code>T</code></span></p>
<p>Here, we’ve defined a method named <code>x</code> on <code>Point&lt;T&gt;</code> that returns a reference
to the data in the field <code>x</code>.</p>
<p>Note that we have to declare <code>T</code> just after <code>impl</code> so we can use it to specify
that we’re implementing methods on the type <code>Point&lt;T&gt;</code>.  By declaring <code>T</code> as a
generic type after <code>impl</code>, Rust can identify that the type in the angle
brackets in <code>Point</code> is a generic type rather than a concrete type.</p>
<p>We could, for example, implement methods only on <code>Point&lt;f32&gt;</code> instances rather
than on <code>Point&lt;T&gt;</code> instances with any generic type. In Listing 10-10 we use the
concrete type <code>f32</code>, meaning we don’t declare any types after <code>impl</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">struct Point<T> {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl<T> Point<T> {
</span><span class="boring">    fn x(&self) -> &T {
</span><span class="boring">        &self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl <span class="ra" data-hover="23">Point</span>&lt;<span class="ra" data-hover="45">f32</span>&gt; {
    fn <span class="ra" data-hover="46">distance_from_origin</span>(&amp;<span class="ra" data-hover="47">self</span>) -&gt; <span class="ra" data-hover="45">f32</span> {
        (<span class="ra" data-hover="47">self</span>.<span class="ra" data-hover="24">x</span>.<span class="ra" data-hover="48">powi</span>(2) + <span class="ra" data-hover="47">self</span>.<span class="ra" data-hover="25">y</span>.<span class="ra" data-hover="48">powi</span>(2)).<span class="ra" data-hover="49">sqrt</span>()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!("p.x = {}", p.x());
</span><span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 10-10: An <code>impl</code> block that only applies to a
struct with a particular concrete type for the generic type parameter <code>T</code></span></p>
<p>This code means the type <code>Point&lt;f32&gt;</code> will have a method named
<code>distance_from_origin</code> and other instances of <code>Point&lt;T&gt;</code> where <code>T</code> is not of
type <code>f32</code> will not have this method defined. The method measures how far our
point is from the point at coordinates (0.0, 0.0) and uses mathematical
operations that are available only for floating point types.</p>
<p>Generic type parameters in a struct definition aren’t always the same as those
you use in that struct’s method signatures. For example, Listing 10-11 defines
the method <code>mixup</code> on the <code>Point&lt;T, U&gt;</code> struct from Listing 10-8. The method
takes another <code>Point</code> as a parameter, which might have different types from the
<code>self</code> <code>Point</code> we’re calling <code>mixup</code> on. The method creates a new <code>Point</code>
instance with the <code>x</code> value from the <code>self</code> <code>Point</code> (of type <code>T</code>) and the <code>y</code>
value from the passed-in <code>Point</code> (of type <code>W</code>).</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct <span class="ra" data-hover="29">Point</span>&lt;<span class="ra" data-hover="19">T</span>, <span class="ra" data-hover="30">U</span>&gt; {
    <span class="ra" data-hover="24">x</span>: <span class="ra" data-hover="19">T</span>,
    <span class="ra" data-hover="31">y</span>: <span class="ra" data-hover="30">U</span>,
}

impl&lt;<span class="ra" data-hover="19">T</span>, <span class="ra" data-hover="30">U</span>&gt; <span class="ra" data-hover="29">Point</span>&lt;<span class="ra" data-hover="19">T</span>, <span class="ra" data-hover="30">U</span>&gt; {
    fn <span class="ra" data-hover="50">mixup</span>&lt;<span class="ra" data-hover="51">V</span>, <span class="ra" data-hover="52">W</span>&gt;(<span class="ra" data-hover="53">self</span>, <span class="ra" data-hover="54">other</span>: <span class="ra" data-hover="29">Point</span>&lt;<span class="ra" data-hover="51">V</span>, <span class="ra" data-hover="52">W</span>&gt;) -&gt; <span class="ra" data-hover="29">Point</span>&lt;<span class="ra" data-hover="19">T</span>, <span class="ra" data-hover="52">W</span>&gt; {
        <span class="ra" data-hover="29">Point</span> {
            <span class="ra" data-hover="24">x</span>: <span class="ra" data-hover="53">self</span>.<span class="ra" data-hover="24">x</span>,
            <span class="ra" data-hover="31">y</span>: <span class="ra" data-hover="54">other</span>.<span class="ra" data-hover="31">y</span>,
        }
    }
}

fn <span class="ra" data-hover="10">main</span>() {
    let <span class="ra" data-hover="55">p1</span><span class="inlay-hint">: Point&lt;i32, f64&gt;</span> = <span class="ra" data-hover="29">Point</span> { <span class="ra" data-hover="24">x</span>: 5, <span class="ra" data-hover="31">y</span>: 10.4 };
    let <span class="ra" data-hover="56">p2</span><span class="inlay-hint">: Point&lt;&amp;str, char&gt;</span> = <span class="ra" data-hover="29">Point</span> { <span class="ra" data-hover="24">x</span>: "Hello", <span class="ra" data-hover="31">y</span>: 'c' };

    let <span class="ra" data-hover="57">p3</span><span class="inlay-hint">: Point&lt;i32, char&gt;</span> = <span class="ra" data-hover="55">p1</span>.<span class="ra" data-hover="50">mixup</span>(<span class="ra" data-hover="56">p2</span>);

    <span class="ra" data-hover="14">println</span>!("p3.x = {}, p3.y = {}", <span class="ra" data-hover="57">p3</span>.<span class="ra" data-hover="24">x</span>, <span class="ra" data-hover="57">p3</span>.<span class="ra" data-hover="31">y</span>);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-11: A method that uses different generic types
from its struct’s definition</span></p>
<p>In <code>main</code>, we’ve defined a <code>Point</code> that has an <code>i32</code> for <code>x</code> (with value <code>5</code>)
and an <code>f64</code> for <code>y</code> (with value <code>10.4</code>). The <code>p2</code> variable is a <code>Point</code> struct
that has a string slice for <code>x</code> (with value <code>&quot;Hello&quot;</code>) and a <code>char</code> for <code>y</code>
(with value <code>c</code>). Calling <code>mixup</code> on <code>p1</code> with the argument <code>p2</code> gives us <code>p3</code>,
which will have an <code>i32</code> for <code>x</code>, because <code>x</code> came from <code>p1</code>. The <code>p3</code> variable
will have a <code>char</code> for <code>y</code>, because <code>y</code> came from <code>p2</code>. The <code>println!</code> macro
call will print <code>p3.x = 5, p3.y = c</code>.</p>
<p>The purpose of this example is to demonstrate a situation in which some generic
parameters are declared with <code>impl</code> and some are declared with the method
definition. Here, the generic parameters <code>T</code> and <code>U</code> are declared after <code>impl</code>,
because they go with the struct definition. The generic parameters <code>V</code> and <code>W</code>
are declared after <code>fn mixup</code>, because they’re only relevant to the method.</p>
<h3 id="performance-of-code-using-generics"><a class="header" href="#performance-of-code-using-generics">Performance of Code Using Generics</a></h3>
<p>You might be wondering whether there is a runtime cost when you’re using
generic type parameters. The good news is that Rust implements generics in such
a way that your code doesn’t run any slower using generic types than it would
with concrete types.</p>
<p>Rust accomplishes this by performing monomorphization of the code that is using
generics at compile time. <em>Monomorphization</em> is the process of turning generic
code into specific code by filling in the concrete types that are used when
compiled.</p>
<p>In this process, the compiler does the opposite of the steps we used to create
the generic function in Listing 10-5: the compiler looks at all the places
where generic code is called and generates code for the concrete types the
generic code is called with.</p>
<p>Let’s look at how this works with an example that uses the standard library’s
<code>Option&lt;T&gt;</code> enum:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let <span class="ra" data-hover="58">integer</span><span class="inlay-hint">: Option&lt;i32&gt;</span> = <span class="ra" data-hover="59">Some</span>(5);
let <span class="ra" data-hover="60">float</span><span class="inlay-hint">: Option&lt;f64&gt;</span> = <span class="ra" data-hover="59">Some</span>(5.0);
<span class="boring">}
</span>
</code></pre></pre>
<p>When Rust compiles this code, it performs monomorphization. During that
process, the compiler reads the values that have been used in <code>Option&lt;T&gt;</code>
instances and identifies two kinds of <code>Option&lt;T&gt;</code>: one is <code>i32</code> and the other
is <code>f64</code>. As such, it expands the generic definition of <code>Option&lt;T&gt;</code> into
<code>Option_i32</code> and <code>Option_f64</code>, thereby replacing the generic definition with
the specific ones.</p>
<p>The monomorphized version of the code looks like the following. The generic
<code>Option&lt;T&gt;</code> is replaced with the specific definitions created by the compiler:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum <span class="ra" data-hover="61">Option_i32</span> {
    <span class="ra" data-hover="62">Some</span>(<span class="ra" data-hover="2">i32</span>),
    <span class="ra" data-hover="63">None</span>,
}

enum <span class="ra" data-hover="64">Option_f64</span> {
    <span class="ra" data-hover="65">Some</span>(<span class="ra" data-hover="66">f64</span>),
    <span class="ra" data-hover="67">None</span>,
}

fn <span class="ra" data-hover="10">main</span>() {
    let <span class="ra" data-hover="68">integer</span><span class="inlay-hint">: Option_i32</span> = <span class="ra" data-hover="61">Option_i32</span>::<span class="ra" data-hover="62">Some</span>(5);
    let <span class="ra" data-hover="69">float</span><span class="inlay-hint">: Option_f64</span> = <span class="ra" data-hover="64">Option_f64</span>::<span class="ra" data-hover="65">Some</span>(5.0);
}
<span class="boring">}
</span></code></pre></pre>
<p>Because Rust compiles generic code into code that specifies the type in each
instance, we pay no runtime cost for using generics. When the code runs, it
performs just as it would if we had duplicated each definition by hand. The
process of monomorphization makes Rust’s generics extremely efficient at
runtime.</p>
<script src="https://unpkg.com/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
<script src="https://unpkg.com/tippy.js@6.3.2/dist/tippy-bundle.umd.min.js" integrity="sha384-vApKv6LkBdPwmt/fNiQrBCVCZvuniXpG0b5UZhVrGAq1zXdZRSsPcWjGdVxkZJtX" crossorigin="anonymous"></script>
<script>
    const hoverData = ['<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; i32\n</code></pre>\n','<per><cide class="language-rust">list: &amp;[i32]\n</code></pre>\n','<per><cide class="language-rust">i32\n</code></pre>\n<hr />\n<p>The 32-bit signed integer type.</p>\n','<per><cide class="language-rust">let mut largest: i32\n</code></pre>\n','<per><cide class="language-rust">item: i32\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn largest_char(list: &amp;[char]) -&gt; char\n</code></pre>\n','<per><cide class="language-rust">list: &amp;[char]\n</code></pre>\n','<per><cide class="language-rust">char\n</code></pre>\n<hr />\n<p>A character type.</p>\n<p>The <cide>char</code> type represents a single character. More specifically, since\n#$%character#$% isn#$%t a well-defined concept in Unicode, <cide>char</code> is a #$%<a href="https://www.unicode.org/glossary/#unicode_scalar_value">Unicode\nscalar value</a>#$%, which is similar to, but not the same as, a #$%<a href="https://www.unicode.org/glossary/#code_point">Unicode code\npoint</a>#$%.</p>\n<p>This documentation describes a number of methods and trait implementations on the\n<cide>char</code> type. For technical reasons, there is additional, separate\ndocumentation in <a href="char/index.html">the <cide>std::char</code> module</a> as well.</p>\n<h1 id="representation"><a class="header" href="#representation">Representation</a></h1>\n<p><cide>char</code> is always four bytes in size. This is a different representation than\na given character would have as part of a <a href="string/struct.String.html"><cide>String</code></a>. For example:</p>\n<per><cide>let v = vec![#$%h#$%, #$%e#$%, #$%l#$%, #$%l#$%, #$%o#$%];\n\n// five elements times four bytes for each element\nassert_eq!(20, v.len() * std::mem::size_of::&lt;char&gt;());\n\nlet s = String::from(&quot;hello&quot;);\n\n// five elements times one byte per element\nassert_eq!(5, s.len() * std::mem::size_of::&lt;u8&gt;());\n</code></pre>\n<p>As always, remember that a human intuition for #$%character#$% may not map to\nUnicode#$%s definitions. For example, despite looking similar, the #$%é#$%\ncharacter is one Unicode code point while #$%é#$% is two Unicode code points:</p>\n<per><cide>let mut chars = &quot;é&quot;.chars();\n// U+00e9: #$%latin small letter e with acute#$%\nassert_eq!(Some(#$%\u{00e9}#$%), chars.next());\nassert_eq!(None, chars.next());\n\nlet mut chars = &quot;é&quot;.chars();\n// U+0065: #$%latin small letter e#$%\nassert_eq!(Some(#$%\u{0065}#$%), chars.next());\n// U+0301: #$%combining acute accent#$%\nassert_eq!(Some(#$%\u{0301}#$%), chars.next());\nassert_eq!(None, chars.next());\n</code></pre>\n<p>This means that the contents of the first string above <em>will</em> fit into a\n<cide>char</code> while the contents of the second string <em>will not</em>. Trying to create\na <cide>char</code> literal with the contents of the second string gives an error:</p>\n<per><cide class="language-text">error: character literal may only contain one codepoint: #$%é#$%\nlet c = #$%é#$%;\n        ^^^\n</code></pre>\n<p>Another implication of the 4-byte fixed size of a <cide>char</code> is that\nper-<cide>char</code> processing can end up using a lot more memory:</p>\n<per><cide>let s = String::from(&quot;love: ❤️&quot;);\nlet v: Vec&lt;char&gt; = s.chars().collect();\n\nassert_eq!(12, std::mem::size_of_val(&amp;s[..]));\nassert_eq!(32, std::mem::size_of_val(&amp;v[..]));\n</code></pre>\n','<per><cide class="language-rust">let mut largest: char\n</code></pre>\n','<per><cide class="language-rust">item: char\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn main()\n</code></pre>\n','<per><cide class="language-rust">let number_list: Vec&lt;i32, Global&gt;\n</code></pre>\n','<per><cide class="language-rust">alloc\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! vec\n</code></pre>\n<hr />\n<p>Creates a <a href="crate::vec::Vec"><cide>Vec</code></a> containing the arguments.</p>\n<p><cide>vec!</code> allows <cide>Vec</code>s to be defined with the same syntax as array expressions.\nThere are two forms of this macro:</p>\n<ul>\n<li>Create a <a href="crate::vec::Vec"><cide>Vec</code></a> containing a given list of elements:</li>\n</ul>\n<per><cide>let v = vec![1, 2, 3];\nassert_eq!(v[0], 1);\nassert_eq!(v[1], 2);\nassert_eq!(v[2], 3);\n</code></pre>\n<ul>\n<li>Create a <a href="crate::vec::Vec"><cide>Vec</code></a> from a given element and size:</li>\n</ul>\n<per><cide>let v = vec![1; 3];\nassert_eq!(v, [1, 1, 1]);\n</code></pre>\n<p>Note that unlike array expressions this syntax supports all elements\nwhich implement <a href="%60Clone%60"><cide>Clone</code></a> and the number of elements doesn#$%t have to be\na constant.</p>\n<p>This will use <cide>clone</code> to duplicate an expression, so one should be careful\nusing this with types having a nonstandard <cide>Clone</code> implementation. For\nexample, <cide>vec![Rc::new(1); 5]</code> will create a vector of five references\nto the same boxed integer value, not five references pointing to independently\nboxed integers.</p>\n<p>Also, note that <cide>vec![expr; 0]</code> is allowed, and produces an empty vector.\nThis will still evaluate <cide>expr</code>, however, and immediately drop the resulting value, so\nbe mindful of side effects.</p>\n','<per><cide class="language-rust">let result: i32\n</code></pre>\n','<per><cide class="language-rust">std\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! println\n</code></pre>\n<hr />\n<p>Prints to the standard output, with a newline.</p>\n<p>On all platforms, the newline is the LINE FEED character (<cide>\n</code>/<cide>U+000A</code>) alone\n(no additional CARRIAGE RETURN (<cide>\r</code>/<cide>U+000D</code>)).</p>\n<p>Use the <a href="%60format!%60"><cide>format!</code></a> syntax to write data to the standard output.\nSee <a href="crate::fmt"><cide>std::fmt</code></a> for more information.</p>\n<p>Use <cide>println!</code> only for the primary output of your program. Use\n<a href="%60eprintln!%60"><cide>eprintln!</code></a> instead to print error and progress messages.</p>\n<h1 id="panics"><a class="header" href="#panics">Panics</a></h1>\n<p>Panics if writing to <a href="crate::io::stdout"><cide>io::stdout</code></a> fails.</p>\n<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>\n<per><cide>println!(); // prints just a newline\nprintln!(&quot;hello there!&quot;);\nprintln!(&quot;format {} arguments&quot;, &quot;some&quot;);\n</code></pre>\n','<per><cide class="language-rust">core\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! assert_eq\n</code></pre>\n<hr />\n<p>Asserts that two expressions are equal to each other (using <a href="%60PartialEq%60"><cide>PartialEq</code></a>).</p>\n<p>On panic, this macro will print the values of the expressions with their\ndebug representations.</p>\n<p>Like <a href="%60assert!%60"><cide>assert!</code></a>, this macro has a second form, where a custom\npanic message can be provided.</p>\n<h1 id="examples-1"><a class="header" href="#examples-1">Examples</a></h1>\n<per><cide>let a = 3;\nlet b = 1 + 2;\nassert_eq!(a, b);\n\nassert_eq!(a, b, &quot;we are testing addition with {} and {}&quot;, a, b);\n</code></pre>\n','<per><cide class="language-rust">let char_list: Vec&lt;char, Global&gt;\n</code></pre>\n','<per><cide class="language-rust">let result: char\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T\n</code></pre>\n','<per><cide class="language-rust">T\n</code></pre>\n','<per><cide class="language-rust">list: &amp;[T]\n</code></pre>\n','<per><cide class="language-rust">let mut largest: T\n</code></pre>\n','<per><cide class="language-rust">item: T\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">struct Point&lt;T&gt;\n</code></pre>\n','<per><cide class="language-rust">playcrate::Point\n</code></pre>\n<per><cide class="language-rust">x: T\n</code></pre>\n','<per><cide class="language-rust">playcrate::Point\n</code></pre>\n<per><cide class="language-rust">y: T\n</code></pre>\n','<per><cide class="language-rust">let integer: Point&lt;i32&gt;\n</code></pre>\n','<per><cide class="language-rust">let float: Point&lt;f64&gt;\n</code></pre>\n','<per><cide class="language-rust">let wont_work: Point&lt;i32&gt;\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">struct Point&lt;T, U&gt;\n</code></pre>\n','<per><cide class="language-rust">U\n</code></pre>\n','<per><cide class="language-rust">playcrate::Point\n</code></pre>\n<per><cide class="language-rust">y: U\n</code></pre>\n','<per><cide class="language-rust">let both_integer: Point&lt;i32, i32&gt;\n</code></pre>\n','<per><cide class="language-rust">let both_float: Point&lt;f64, f64&gt;\n</code></pre>\n','<per><cide class="language-rust">let integer_and_float: Point&lt;i32, f64&gt;\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">enum Option&lt;T&gt;\n</code></pre>\n','<per><cide class="language-rust">playcrate::Option\n</code></pre>\n<per><cide class="language-rust">Some(T)\n</code></pre>\n','<per><cide class="language-rust">playcrate::Option\n</code></pre>\n<per><cide class="language-rust">None\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">enum Result&lt;T, E&gt;\n</code></pre>\n','<per><cide class="language-rust">E\n</code></pre>\n','<per><cide class="language-rust">playcrate::Result\n</code></pre>\n<per><cide class="language-rust">Ok(T)\n</code></pre>\n','<per><cide class="language-rust">playcrate::Result\n</code></pre>\n<per><cide class="language-rust">Err(E)\n</code></pre>\n','<per><cide class="language-rust">playcrate::Point\n</code></pre>\n<per><cide class="language-rust">fn x(&amp;self) -&gt; &amp;T\n</code></pre>\n','<per><cide class="language-rust">self: &amp;Point&lt;T&gt;\n</code></pre>\n','<per><cide class="language-rust">let p: Point&lt;i32&gt;\n</code></pre>\n','<per><cide class="language-rust">f32\n</code></pre>\n<hr />\n<p>A 32-bit floating point type (specifically, the &quot;binary32&quot; type defined in IEEE 754-2008).</p>\n<p>This type can represent a wide range of decimal numbers, like <cide>3.5</code>, <cide>27</code>,\n<cide>-113.75</code>, <cide>0.0078125</code>, <cide>34359738368</code>, <cide>0</code>, <cide>-1</code>. So unlike integer types\n(such as <cide>i32</code>), floating point types can represent non-integer numbers,\ntoo.</p>\n<p>However, being able to represent this wide range of numbers comes at the\ncost of precision: floats can only represent some of the real numbers and\ncalculation with floats round to a nearby representable number. For example,\n<cide>5.0</code> and <cide>1.0</code> can be exactly represented as <cide>f32</code>, but <cide>1.0 / 5.0</code> results\nin <cide>0.20000000298023223876953125</code> since <cide>0.2</code> cannot be exactly represented\nas <cide>f32</code>. Note, however, that printing floats with <cide>println</code> and friends will\noften discard insignificant digits: <cide>println!(&quot;{}&quot;, 1.0f32 / 5.0f32)</code> will\nprint <cide>0.2</code>.</p>\n<p>Additionally, <cide>f32</code> can represent some special values:</p>\n<ul>\n<li>−0.0: IEEE 754 floating point numbers have a bit that indicates their sign, so −0.0 is a\npossible value. For comparison −0.0 = +0.0, but floating point operations can carry\nthe sign bit through arithmetic operations. This means −0.0 × +0.0 produces −0.0 and\na negative number rounded to a value smaller than a float can represent also produces −0.0.</li>\n<li><a href="#associatedconstant.INFINITY">∞</a> and\n<a href="#associatedconstant.NEG_INFINITY">−∞</a>: these result from calculations\nlike <cide>1.0 / 0.0</code>.</li>\n<li><a href="#associatedconstant.NAN">NaN (not a number)</a>: this value results from\ncalculations like <cide>(-1.0).sqrt()</code>. NaN has some potentially unexpected\nbehavior: it is unequal to any float, including itself! It is also neither\nsmaller nor greater than any float, making it impossible to sort. Lastly,\nit is considered infectious as almost all calculations where one of the\noperands is NaN will also result in NaN.</li>\n</ul>\n<p>For more information on floating point numbers, see <a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">Wikipedia</a>.</p>\n<p><em><a href="crate::f32::consts">See also the <cide>std::f32::consts</code> module</a>.</em></p>\n','<per><cide class="language-rust">playcrate::Point\n</code></pre>\n<per><cide class="language-rust">fn distance_from_origin(&amp;self) -&gt; f32\n</code></pre>\n','<per><cide class="language-rust">self: &amp;Point&lt;f32&gt;\n</code></pre>\n','<per><cide class="language-rust">std::f32\n</code></pre>\n<per><cide class="language-rust">pub fn powi(self, n: i32) -&gt; f32\n</code></pre>\n<hr />\n<p>Raises a number to an integer power.</p>\n<p>Using this function is generally faster than using <cide>powf</code></p>\n<h1 id="examples-2"><a class="header" href="#examples-2">Examples</a></h1>\n<per><cide>let x = 2.0_f32;\nlet abs_difference = (x.powi(2) - (x * x)).abs();\n\nassert!(abs_difference &lt;= f32::EPSILON);\n</code></pre>\n','<per><cide class="language-rust">std::f32\n</code></pre>\n<per><cide class="language-rust">pub fn sqrt(self) -&gt; f32\n</code></pre>\n<hr />\n<p>Returns the square root of a number.</p>\n<p>Returns NaN if <cide>self</code> is a negative number other than <cide>-0.0</code>.</p>\n<h1 id="examples-3"><a class="header" href="#examples-3">Examples</a></h1>\n<per><cide>let positive = 4.0_f32;\nlet negative = -4.0_f32;\nlet negative_zero = -0.0_f32;\n\nlet abs_difference = (positive.sqrt() - 2.0).abs();\n\nassert!(abs_difference &lt;= f32::EPSILON);\nassert!(negative.sqrt().is_nan());\nassert!(negative_zero.sqrt() == negative_zero);\n</code></pre>\n','<per><cide class="language-rust">playcrate::Point\n</code></pre>\n<per><cide class="language-rust">fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt;\n</code></pre>\n','<per><cide class="language-rust">V\n</code></pre>\n','<per><cide class="language-rust">W\n</code></pre>\n','<per><cide class="language-rust">self: Point&lt;T, U&gt;\n</code></pre>\n','<per><cide class="language-rust">other: Point&lt;V, W&gt;\n</code></pre>\n','<per><cide class="language-rust">let p1: Point&lt;i32, f64&gt;\n</code></pre>\n','<per><cide class="language-rust">let p2: Point&lt;&amp;str, char&gt;\n</code></pre>\n','<per><cide class="language-rust">let p3: Point&lt;i32, char&gt;\n</code></pre>\n','<per><cide class="language-rust">let integer: Option&lt;i32&gt;\n</code></pre>\n','<per><cide class="language-rust">core::option::Option\n</code></pre>\n<per><cide class="language-rust">Some(T)\n</code></pre>\n<hr />\n<p>Some value <cide>T</code></p>\n','<per><cide class="language-rust">let float: Option&lt;f64&gt;\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">enum Option_i32\n</code></pre>\n','<per><cide class="language-rust">playcrate::Option_i32\n</code></pre>\n<per><cide class="language-rust">Some(i32)\n</code></pre>\n','<per><cide class="language-rust">playcrate::Option_i32\n</code></pre>\n<per><cide class="language-rust">None\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">enum Option_f64\n</code></pre>\n','<per><cide class="language-rust">playcrate::Option_f64\n</code></pre>\n<per><cide class="language-rust">Some(f64)\n</code></pre>\n','<per><cide class="language-rust">f64\n</code></pre>\n<hr />\n<p>A 64-bit floating point type (specifically, the &quot;binary64&quot; type defined in IEEE 754-2008).</p>\n<p>This type is very similar to <a href="prim@f32"><cide>f32</code></a>, but has increased\nprecision by using twice as many bits. Please see <a href="prim@f32">the documentation for\n<cide>f32</code></a> or <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">Wikipedia on double precision\nvalues</a> for more information.</p>\n<p><em><a href="crate::f64::consts">See also the <cide>std::f64::consts</code> module</a>.</em></p>\n','<per><cide class="language-rust">playcrate::Option_f64\n</code></pre>\n<per><cide class="language-rust">None\n</code></pre>\n','<per><cide class="language-rust">let integer: Option_i32\n</code></pre>\n','<per><cide class="language-rust">let float: Option_f64\n</code></pre>\n',].map((x)=>x.replaceAll('#$%', "'").replaceAll('<per', '<pre').replaceAll('<cide', '<code'));
    window.onload = () => {
        console.log("hello");
        tippy('.ra', {
            content: (x) => {
                const div = document.createElement('div');
                div.innerHTML = hoverData[x.dataset.hover];
                div.className = 'hover-holder';
                div.querySelectorAll('code').forEach((y) => y.innerHTML = hljs.highlight('rust', y.innerText).value);
                return div;
            },
            allowHTML: true,
            delay: [200, 0],
            interactive: true,
            maxWidth: '80vw',
            appendTo: document.querySelector('.content'),
        });
    };
</script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="ch10-00-generics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="ch10-02-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="ch10-00-generics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="ch10-02-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="ferris.js"></script>
        
        
    </body>
</html>
