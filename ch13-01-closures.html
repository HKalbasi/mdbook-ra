<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Closures: Anonymous Functions that Can Capture Their Environment - The Rust Programming Language</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="ferris.css">
                <link rel="stylesheet" href="theme/2018-edition.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References and Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> The Slice Type</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> How to Write Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlling How Tests Are Run</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html" class="active"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.inlay-hint, .inlay-hint * {
    border-radius: .4em;
}

.light .inlay-hint, .rust .inlay-hint {
    background-color: #dcc;
    color: #777;
}

.ayu .inlay-hint, .navy .inlay-hint, .coal .inlay-hint {
    background-color: #444;
    color: #999;
}

.inlay-hint {
    font-size: 0.8em;
    user-select: none;
}
.hover-holder {
    max-height: 40vh;
    overflow: auto;
}

.tippy-content {
    background-color: var(--bg);
    color: var(--fg);
}
</style>## Closures: Anonymous Functions that Can Capture Their Environment
<p>Rust’s closures are anonymous functions you can save in a variable or pass as
arguments to other functions. You can create the closure in one place and then
call the closure to evaluate it in a different context. Unlike functions,
closures can capture values from the scope in which they’re defined. We’ll
demonstrate how these closure features allow for code reuse and behavior
customization.</p>
<h3 id="creating-an-abstraction-of-behavior-with-closures"><a class="header" href="#creating-an-abstraction-of-behavior-with-closures">Creating an Abstraction of Behavior with Closures</a></h3>
<p>Let’s work on an example of a situation in which it’s useful to store a closure
to be executed later. Along the way, we’ll talk about the syntax of closures,
type inference, and traits.</p>
<p>Consider this hypothetical situation: we work at a startup that’s making an app
to generate custom exercise workout plans. The backend is written in Rust, and
the algorithm that generates the workout plan takes into account many factors,
such as the app user’s age, body mass index, exercise preferences, recent
workouts, and an intensity number they specify. The actual algorithm used isn’t
important in this example; what’s important is that this calculation takes a
few seconds. We want to call this algorithm only when we need to and only call
it once so we don’t make the user wait more than necessary.</p>
<p>We’ll simulate calling this hypothetical algorithm with the function
<code>simulated_expensive_calculation</code> shown in Listing 13-1, which will print
<code>calculating slowly...</code>, wait for two seconds, and then return whatever number
we passed in.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">use <span class="ra" data-hover="0">std</span>::<span class="ra" data-hover="1">thread</span>;
use <span class="ra" data-hover="0">std</span>::<span class="ra" data-hover="2">time</span>::<span class="ra" data-hover="3">Duration</span>;

fn <span class="ra" data-hover="4">simulated_expensive_calculation</span>(<span class="ra" data-hover="5">intensity</span>: <span class="ra" data-hover="6">u32</span>) -&gt; <span class="ra" data-hover="6">u32</span> {
    <span class="ra" data-hover="7">println</span>!("calculating slowly...");
    <span class="ra" data-hover="1">thread</span>::<span class="ra" data-hover="8">sleep</span>(<span class="ra" data-hover="3"><span class="inlay-hint">dur: </span>Duration</span>::<span class="ra" data-hover="9">from_secs</span>(2));
    <span class="ra" data-hover="5">intensity
}
<span class="boring">
</span><span class="boring">fn main() {}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-1: A function to stand in for a hypothetical
calculation that takes about 2 seconds to run</span></p>
<p>Next is the <code>main</code> function, which contains the parts of the workout app
important for this example. This function represents the code that the app will
call when a user asks for a workout plan. Because the interaction with the
app’s frontend isn’t relevant to the use of closures, we’ll hardcode values
representing inputs to our program and print the outputs.</p>
<p>The required inputs are these:</p>
<ul>
<li>An intensity number from the user, which is specified when they request
a workout to indicate whether they want a low-intensity workout or a
high-intensity workout</li>
<li>A random number that will generate some variety in the workout plans</li>
</ul>
<p>The output will be the recommended workout plan. Listing 13-2 shows the <code>main</code>
function we’ll use.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(intensity: u32) -> u32 {
</span><span class="boring">    println!("calculating slowly...");
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    intensity
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {}
</span><span class="boring">
</span>fn <span class="ra" data-hover="10">main</span>() {
    let <span class="ra" data-hover="13">simulated_user_specified_value</span><span class="inlay-hint">: u32</span> = 10;
    let <span class="ra" data-hover="14">simulated_random_number</span><span class="inlay-hint">: u32</span> = 7;

    <span class="ra" data-hover="11">generate_workout</span>(<span class="ra" data-hover="13"><span class="inlay-hint">intensity: </span>simulated_user_specified_value</span>, <span class="ra" data-hover="14">simulated_random_number</span>);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-2: A <code>main</code> function with hardcoded values to
simulate user input and random number generation</span></p>
<p>We’ve hardcoded the variable <code>simulated_user_specified_value</code> as 10 and the
variable <code>simulated_random_number</code> as 7 for simplicity’s sake; in an actual
program, we’d get the intensity number from the app frontend, and we’d use the
<code>rand</code> crate to generate a random number, as we did in the Guessing Game
example in Chapter 2. The <code>main</code> function calls a <code>generate_workout</code> function
with the simulated input values.</p>
<p>Now that we have the context, let’s get to the algorithm. The function
<code>generate_workout</code> in Listing 13-3 contains the business logic of the
app that we’re most concerned with in this example. The rest of the code
changes in this example will be made to this function.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(intensity: u32) -> u32 {
</span><span class="boring">    println!("calculating slowly...");
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    intensity
</span><span class="boring">}
</span><span class="boring">
</span>fn <span class="ra" data-hover="11">generate_workout</span>(<span class="ra" data-hover="5">intensity</span>: <span class="ra" data-hover="6">u32</span>, <span class="ra" data-hover="12">random_number</span>: <span class="ra" data-hover="6">u32</span>) {
    if <span class="ra" data-hover="5">intensity</span> &lt; 25 {
        <span class="ra" data-hover="7">println</span>!(
            "Today, do {} pushups!",
            <span class="ra" data-hover="4">simulated_expensive_calculation</span>(<span class="ra" data-hover="5">intensity</span>)
        );
        <span class="ra" data-hover="7">println</span>!(
            "Next, do {} situps!",
            <span class="ra" data-hover="4">simulated_expensive_calculation</span>(<span class="ra" data-hover="5">intensity</span>)
        );
    } else {
        if <span class="ra" data-hover="12">random_number</span> == 3 {
            <span class="ra" data-hover="7">println</span>!("Take a break today! Remember to stay hydrated!");
        } else {
            <span class="ra" data-hover="7">println</span>!(
                "Today, run for {} minutes!",
                <span class="ra" data-hover="4">simulated_expensive_calculation</span>(<span class="ra" data-hover="5">intensity</span>)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-3: The business logic that prints the workout
plans based on the inputs and calls to the <code>simulated_expensive_calculation</code>
function</span></p>
<p>The code in Listing 13-3 has multiple calls to the slow calculation function.
The first <code>if</code> block calls <code>simulated_expensive_calculation</code> twice, the <code>if</code>
inside the outer <code>else</code> doesn’t call it at all, and the code inside the
second <code>else</code> case calls it once.</p>
<p>The desired behavior of the <code>generate_workout</code> function is to first check
whether the user wants a low-intensity workout (indicated by a number less than
25) or a high-intensity workout (a number of 25 or greater).</p>
<p>Low-intensity workout plans will recommend a number of push-ups and sit-ups
based on the complex algorithm we’re simulating.</p>
<p>If the user wants a high-intensity workout, there’s some additional logic: if
the value of the random number generated by the app happens to be 3, the app
will recommend a break and hydration. If not, the user will get a number of
minutes of running based on the complex algorithm.</p>
<p>This code works the way the business wants it to now, but let’s say the data
science team decides that we need to make some changes to the way we call the
<code>simulated_expensive_calculation</code> function in the future. To simplify the
update when those changes happen, we want to refactor this code so it calls the
<code>simulated_expensive_calculation</code> function only once. We also want to cut the
place where we’re currently unnecessarily calling the function twice without
adding any other calls to that function in the process. That is, we don’t want
to call it if the result isn’t needed, and we still want to call it only once.</p>
<h4 id="refactoring-using-functions"><a class="header" href="#refactoring-using-functions">Refactoring Using Functions</a></h4>
<p>We could restructure the workout program in many ways. First, we’ll try
extracting the duplicated call to the <code>simulated_expensive_calculation</code>
function into a variable, as shown in Listing 13-4.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(intensity: u32) -> u32 {
</span><span class="boring">    println!("calculating slowly...");
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    intensity
</span><span class="boring">}
</span><span class="boring">
</span>fn <span class="ra" data-hover="11">generate_workout</span>(<span class="ra" data-hover="5">intensity</span>: <span class="ra" data-hover="6">u32</span>, <span class="ra" data-hover="12">random_number</span>: <span class="ra" data-hover="6">u32</span>) {
    let <span class="ra" data-hover="15">expensive_result</span><span class="inlay-hint">: u32</span> = <span class="ra" data-hover="4">simulated_expensive_calculation</span>(<span class="ra" data-hover="5">intensity</span>);

    if <span class="ra" data-hover="5">intensity</span> &lt; 25 {
        <span class="ra" data-hover="7">println</span>!("Today, do {} pushups!", <span class="ra" data-hover="15">expensive_result</span>);
        <span class="ra" data-hover="7">println</span>!("Next, do {} situps!", <span class="ra" data-hover="15">expensive_result</span>);
    } else {
        if <span class="ra" data-hover="12">random_number</span> == 3 {
            <span class="ra" data-hover="7">println</span>!("Take a break today! Remember to stay hydrated!");
        } else {
            <span class="ra" data-hover="7">println</span>!("Today, run for {} minutes!", <span class="ra" data-hover="15">expensive_result</span>);
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-4: Extracting the calls to
<code>simulated_expensive_calculation</code> to one place and storing the result in the
<code>expensive_result</code> variable</span></p>
<p>This change unifies all the calls to <code>simulated_expensive_calculation</code> and
solves the problem of the first <code>if</code> block unnecessarily calling the function
twice. Unfortunately, we’re now calling this function and waiting for the
result in all cases, which includes the inner <code>if</code> block that doesn’t use the
result value at all.</p>
<p>We want to refer to <code>simulated_expensive_calculation</code> only once in
<code>generate_workout</code>, but defer the expensive calculation to only where
we actually need the result. This is a use case for closures!</p>
<h4 id="refactoring-with-closures-to-store-code"><a class="header" href="#refactoring-with-closures-to-store-code">Refactoring with Closures to Store Code</a></h4>
<p>Instead of always calling the <code>simulated_expensive_calculation</code> function before
the <code>if</code> blocks, we can define a closure and store the <em>closure</em> in a variable
rather than storing the result of the function call, as shown in Listing 13-5.
We can actually move the whole body of <code>simulated_expensive_calculation</code> within
the closure we’re introducing here.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let <span class="ra" data-hover="16">expensive_closure</span><span class="inlay-hint">: |…| -&gt; u32</span> = |<span class="ra" data-hover="17">num</span><span class="inlay-hint">: u32</span>| {
        <span class="ra" data-hover="7">println</span>!("calculating slowly...");
        <span class="ra" data-hover="1">thread</span>::<span class="ra" data-hover="8">sleep</span>(<span class="ra" data-hover="3"><span class="inlay-hint">dur: </span>Duration</span>::<span class="ra" data-hover="9">from_secs</span>(2));
        <span class="ra" data-hover="17">num
    };
<span class="boring">
</span><span class="boring">    if intensity < 25 {
</span><span class="boring">        println!("Today, do {} pushups!", expensive_closure(intensity));
</span><span class="boring">        println!("Next, do {} situps!", expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!("Take a break today! Remember to stay hydrated!");
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                "Today, run for {} minutes!",
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-5: Defining a closure and storing it in the
<code>expensive_closure</code> variable</span></p>
<p>The closure definition comes after the <code>=</code> to assign it to the variable
<code>expensive_closure</code>. To define a closure, we start with a pair of vertical
pipes (<code>|</code>), inside which we specify the parameters to the closure; this syntax
was chosen because of its similarity to closure definitions in Smalltalk and
Ruby. This closure has one parameter named <code>num</code>: if we had more than one
parameter, we would separate them with commas, like <code>|param1, param2|</code>.</p>
<p>After the parameters, we place curly brackets that hold the body of the
closure—these are optional if the closure body is a single expression. The end
of the closure, after the curly brackets, needs a semicolon to complete the
<code>let</code> statement. The value returned from the last line in the closure body
(<code>num</code>) will be the value returned from the closure when it’s called, because
that line doesn’t end in a semicolon; just as in function bodies.</p>
<p>Note that this <code>let</code> statement means <code>expensive_closure</code> contains the
<em>definition</em> of an anonymous function, not the <em>resulting value</em> of calling the
anonymous function. Recall that we’re using a closure because we want to define
the code to call at one point, store that code, and call it at a later point;
the code we want to call is now stored in <code>expensive_closure</code>.</p>
<p>With the closure defined, we can change the code in the <code>if</code> blocks to call the
closure to execute the code and get the resulting value. We call a closure like
we do a function: we specify the variable name that holds the closure
definition and follow it with parentheses containing the argument values we
want to use, as shown in Listing 13-6.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn <span class="ra" data-hover="11">generate_workout</span>(<span class="ra" data-hover="5">intensity</span>: <span class="ra" data-hover="6">u32</span>, <span class="ra" data-hover="12">random_number</span>: <span class="ra" data-hover="6">u32</span>) {
    let <span class="ra" data-hover="16">expensive_closure</span><span class="inlay-hint">: |…| -&gt; u32</span> = |<span class="ra" data-hover="17">num</span><span class="inlay-hint">: u32</span>| {
        <span class="ra" data-hover="7">println</span>!("calculating slowly...");
        <span class="ra" data-hover="1">thread</span>::<span class="ra" data-hover="8">sleep</span>(<span class="ra" data-hover="3"><span class="inlay-hint">dur: </span>Duration</span>::<span class="ra" data-hover="9">from_secs</span>(2));
        <span class="ra" data-hover="17">num
    };

    if <span class="ra" data-hover="5">intensity</span> &lt; 25 {
        <span class="ra" data-hover="7">println</span>!("Today, do {} pushups!", <span class="ra" data-hover="16">expensive_closure</span>(<span class="ra" data-hover="5">intensity</span>));
        <span class="ra" data-hover="7">println</span>!("Next, do {} situps!", <span class="ra" data-hover="16">expensive_closure</span>(<span class="ra" data-hover="5">intensity</span>));
    } else {
        if <span class="ra" data-hover="12">random_number</span> == 3 {
            <span class="ra" data-hover="7">println</span>!("Take a break today! Remember to stay hydrated!");
        } else {
            <span class="ra" data-hover="7">println</span>!(
                "Today, run for {} minutes!",
                <span class="ra" data-hover="16">expensive_closure</span>(<span class="ra" data-hover="5">intensity</span>)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-6: Calling the <code>expensive_closure</code> we’ve
defined</span></p>
<p>Now how to perform the expensive calculation is defined in only one
place, and we’re only executing that code where we need the results.</p>
<p>However, we’ve reintroduced one of the problems from Listing 13-3: we’re still
calling the closure twice in the first <code>if</code> block, which will call the
expensive code twice and make the user wait twice as long as they need to. We
could fix this problem by creating a variable local to that <code>if</code> block to hold
the result of calling the closure, but closures provide us with another
solution. We’ll talk about that solution in a bit. But first let’s talk about
why there aren’t type annotations in the closure definition and the traits
involved with closures.</p>
<h3 id="closure-type-inference-and-annotation"><a class="header" href="#closure-type-inference-and-annotation">Closure Type Inference and Annotation</a></h3>
<p>Closures don’t require you to annotate the types of the parameters or the
return value like <code>fn</code> functions do. Type annotations are required on functions
because they’re part of an explicit interface exposed to your users. Defining
this interface rigidly is important for ensuring that everyone agrees on what
types of values a function uses and returns. But closures aren’t used in an
exposed interface like this: they’re stored in variables and used without
naming them and exposing them to users of our library.</p>
<p>Closures are usually short and relevant only within a narrow context rather
than in any arbitrary scenario. Within these limited contexts, the compiler is
reliably able to infer the types of the parameters and the return type, similar
to how it’s able to infer the types of most variables.</p>
<p>Making programmers annotate the types in these small, anonymous functions would
be annoying and largely redundant with the information the compiler already has
available.</p>
<p>As with variables, we can add type annotations if we want to increase
explicitness and clarity at the cost of being more verbose than is strictly
necessary. Annotating the types for the closure we defined in Listing 13-5
would look like the definition shown in Listing 13-7.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let <span class="ra" data-hover="16">expensive_closure</span><span class="inlay-hint">: |…| -&gt; u32</span> = |<span class="ra" data-hover="17">num</span>: <span class="ra" data-hover="6">u32</span>| -&gt; <span class="ra" data-hover="6">u32</span> {
        <span class="ra" data-hover="7">println</span>!("calculating slowly...");
        <span class="ra" data-hover="1">thread</span>::<span class="ra" data-hover="8">sleep</span>(<span class="ra" data-hover="3"><span class="inlay-hint">dur: </span>Duration</span>::<span class="ra" data-hover="9">from_secs</span>(2));
        <span class="ra" data-hover="17">num
    };
<span class="boring">
</span><span class="boring">    if intensity < 25 {
</span><span class="boring">        println!("Today, do {} pushups!", expensive_closure(intensity));
</span><span class="boring">        println!("Next, do {} situps!", expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!("Take a break today! Remember to stay hydrated!");
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                "Today, run for {} minutes!",
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-7: Adding optional type annotations of the
parameter and return value types in the closure</span></p>
<p>With type annotations added, the syntax of closures looks more similar to the
syntax of functions. The following is a vertical comparison of the syntax for
the definition of a function that adds 1 to its parameter and a closure that
has the same behavior. We’ve added some spaces to line up the relevant parts.
This illustrates how closure syntax is similar to function syntax except for
the use of pipes and the amount of syntax that is optional:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn  <span class="ra" data-hover="18">add_one_v1</span>   (<span class="ra" data-hover="19">x</span>: <span class="ra" data-hover="6">u32</span>) -&gt; <span class="ra" data-hover="6">u32</span> { <span class="ra" data-hover="19">x</span> + 1 }
let <span class="ra" data-hover="20">add_one_v2</span><span class="inlay-hint">: |…| -&gt; u32</span> = |<span class="ra" data-hover="19">x</span>: <span class="ra" data-hover="6">u32</span>| -&gt; <span class="ra" data-hover="6">u32</span> { <span class="ra" data-hover="19">x</span> + 1 };
let <span class="ra" data-hover="21">add_one_v3</span><span class="inlay-hint">: |…| -&gt; {unknown}</span> = |<span class="ra" data-hover="22">x</span>|             { <span class="ra" data-hover="22">x</span> + 1 };
let <span class="ra" data-hover="23">add_one_v4</span><span class="inlay-hint">: |…| -&gt; {unknown}</span> = |<span class="ra" data-hover="22">x</span>|               <span class="ra" data-hover="22">x</span> + 1  ;
<span class="boring">}
</span>
</code></pre></pre>
<p>The first line shows a function definition, and the second line shows a fully
annotated closure definition. The third line removes the type annotations from
the closure definition, and the fourth line removes the brackets, which are
optional because the closure body has only one expression. These are all valid
definitions that will produce the same behavior when they’re called. Calling
the closures is required for <code>add_one_v3</code> and <code>add_one_v4</code> to be able to
compile because the types will be inferred from their usage.</p>
<p>Closure definitions will have one concrete type inferred for each of their
parameters and for their return value. For instance, Listing 13-8 shows the
definition of a short closure that just returns the value it receives as a
parameter. This closure isn’t very useful except for the purposes of this
example. Note that we haven’t added any type annotations to the definition: if
we then try to call the closure twice, using a <code>String</code> as an argument the
first time and a <code>u32</code> the second time, we’ll get an error.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">fn main() {
</span>    let <span class="ra" data-hover="24">example_closure</span><span class="inlay-hint">: |…| -&gt; String</span> = |<span class="ra" data-hover="25">x</span><span class="inlay-hint">: String</span>| <span class="ra" data-hover="25">x</span>;

    let <span class="ra" data-hover="26">s</span><span class="inlay-hint">: String</span> = <span class="ra" data-hover="24">example_closure</span>(<span class="ra" data-hover="27">String</span>::<span class="ra" data-hover="28">from</span>("hello"));
    let <span class="ra" data-hover="29">n</span><span class="inlay-hint">: String</span> = <span class="ra" data-hover="24">example_closure</span>(5);
<span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-8: Attempting to call a closure whose types
are inferred with two different types</span></p>
<p>The compiler gives us this error:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |                             ^
  |                             |
  |                             expected struct `String`, found integer
  |                             help: try using a conversion method: `5.to_string()`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` due to previous error
</code></pre>
<p>The first time we call <code>example_closure</code> with the <code>String</code> value, the compiler
infers the type of <code>x</code> and the return type of the closure to be <code>String</code>. Those
types are then locked into the closure in <code>example_closure</code>, and we get a type
error if we try to use a different type with the same closure.</p>
<h3 id="storing-closures-using-generic-parameters-and-the-fn-traits"><a class="header" href="#storing-closures-using-generic-parameters-and-the-fn-traits">Storing Closures Using Generic Parameters and the <code>Fn</code> Traits</a></h3>
<p>Let’s return to our workout generation app. In Listing 13-6, our code was still
calling the expensive calculation closure more times than it needed to. One
option to solve this issue is to save the result of the expensive closure in a
variable for reuse and use the variable in each place we need the result,
instead of calling the closure again. However, this method could result in a
lot of repeated code.</p>
<p>Fortunately, another solution is available to us. We can create a struct that
will hold the closure and the resulting value of calling the closure. The
struct will execute the closure only if we need the resulting value, and it
will cache the resulting value so the rest of our code doesn’t have to be
responsible for saving and reusing the result. You may know this pattern as
<em>memoization</em> or <em>lazy evaluation</em>.</p>
<p>To make a struct that holds a closure, we need to specify the type of the
closure, because a struct definition needs to know the types of each of its
fields. Each closure instance has its own unique anonymous type: that is, even
if two closures have the same signature, their types are still considered
different. To define structs, enums, or function parameters that use closures,
we use generics and trait bounds, as we discussed in Chapter 10.</p>
<p>The <code>Fn</code> traits are provided by the standard library. All closures implement at
least one of the traits: <code>Fn</code>, <code>FnMut</code>, or <code>FnOnce</code>. We’ll discuss the
difference between these traits in the <a href="#capturing-the-environment-with-closures">“Capturing the Environment with
Closures”</a><!-- ignore --> section; in
this example, we can use the <code>Fn</code> trait.</p>
<p>We add types to the <code>Fn</code> trait bound to represent the types of the parameters
and return values the closures must have to match this trait bound. In this
case, our closure has a parameter of type <code>u32</code> and returns a <code>u32</code>, so the
trait bound we specify is <code>Fn(u32) -&gt; u32</code>.</p>
<p>Listing 13-9 shows the definition of the <code>Cacher</code> struct that holds a closure
and an optional result value.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">struct <span class="ra" data-hover="30">Cacher</span>&lt;<span class="ra" data-hover="31">T</span>&gt;
where
    <span class="ra" data-hover="31">T</span>: <span class="ra" data-hover="32">Fn</span>(<span class="ra" data-hover="6">u32</span>) -&gt; <span class="ra" data-hover="6">u32</span>,
{
    <span class="ra" data-hover="33">calculation</span>: <span class="ra" data-hover="31">T</span>,
    <span class="ra" data-hover="34">value</span>: <span class="ra" data-hover="35">Option</span>&lt;<span class="ra" data-hover="6">u32</span>&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-9: Defining a <code>Cacher</code> struct that holds a
closure in <code>calculation</code> and an optional result in <code>value</code></span></p>
<p>The <code>Cacher</code> struct has a <code>calculation</code> field of the generic type <code>T</code>. The
trait bounds on <code>T</code> specify that it’s a closure by using the <code>Fn</code> trait. Any
closure we want to store in the <code>calculation</code> field must have one <code>u32</code>
parameter (specified within the parentheses after <code>Fn</code>) and must return a
<code>u32</code> (specified after the <code>-&gt;</code>).</p>
<blockquote>
<p>Note: Functions can implement all three of the <code>Fn</code> traits too. If what we
want to do doesn’t require capturing a value from the environment, we can use
a function rather than a closure where we need something that implements an
<code>Fn</code> trait.</p>
</blockquote>
<p>The <code>value</code> field is of type <code>Option&lt;u32&gt;</code>. Before we execute the closure,
<code>value</code> will be <code>None</code>. When code using a <code>Cacher</code> asks for the <em>result</em> of the
closure, the <code>Cacher</code> will execute the closure at that time and store the
result within a <code>Some</code> variant in the <code>value</code> field. Then if the code asks for
the result of the closure again, instead of executing the closure again, the
<code>Cacher</code> will return the result held in the <code>Some</code> variant.</p>
<p>The logic around the <code>value</code> field we’ve just described is defined in Listing
13-10.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">struct Cacher<T>
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -> u32,
</span><span class="boring">{
</span><span class="boring">    calculation: T,
</span><span class="boring">    value: Option<u32>,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;<span class="ra" data-hover="31">T</span>&gt; <span class="ra" data-hover="30">Cacher</span>&lt;<span class="ra" data-hover="31">T</span>&gt;
where
    <span class="ra" data-hover="31">T</span>: <span class="ra" data-hover="32">Fn</span>(<span class="ra" data-hover="6">u32</span>) -&gt; <span class="ra" data-hover="6">u32</span>,
{
    fn <span class="ra" data-hover="36">new</span>(<span class="ra" data-hover="37">calculation</span>: <span class="ra" data-hover="31">T</span>) -&gt; <span class="ra" data-hover="30">Cacher</span>&lt;<span class="ra" data-hover="31">T</span>&gt; {
        <span class="ra" data-hover="30">Cacher</span> {
            calculation,
            <span class="ra" data-hover="34">value</span>: <span class="ra" data-hover="38">None</span>,
        }
    }

    fn <span class="ra" data-hover="39">value</span>(&amp;mut <span class="ra" data-hover="40">self</span>, <span class="ra" data-hover="41">arg</span>: <span class="ra" data-hover="6">u32</span>) -&gt; <span class="ra" data-hover="6">u32</span> {
        match <span class="ra" data-hover="40">self</span>.<span class="ra" data-hover="34">value</span> {
            <span class="ra" data-hover="42">Some</span>(<span class="ra" data-hover="43">v</span><span class="inlay-hint">: u32</span>) =&gt; <span class="ra" data-hover="43">v</span>,
            <span class="ra" data-hover="38">None</span> =&gt; {
                let <span class="ra" data-hover="44">v</span><span class="inlay-hint">: u32</span> = (<span class="ra" data-hover="40">self</span>.<span class="ra" data-hover="33">calculation</span>)(<span class="ra" data-hover="41">arg</span>);
                <span class="ra" data-hover="40">self</span>.<span class="ra" data-hover="34">value</span> = <span class="ra" data-hover="42">Some</span>(<span class="ra" data-hover="44">v</span>);
                <span class="ra" data-hover="44">v
            }
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-10: The caching logic of <code>Cacher</code></span></p>
<p>We want <code>Cacher</code> to manage the struct fields’ values rather than letting the
calling code potentially change the values in these fields directly, so these
fields are private.</p>
<p>The <code>Cacher::new</code> function takes a generic parameter <code>T</code>, which we’ve defined
as having the same trait bound as the <code>Cacher</code> struct. Then <code>Cacher::new</code>
returns a <code>Cacher</code> instance that holds the closure specified in the
<code>calculation</code> field and a <code>None</code> value in the <code>value</code> field, because we haven’t
executed the closure yet.</p>
<p>When the calling code needs the result of evaluating the closure, instead of
calling the closure directly, it will call the <code>value</code> method. This method
checks whether we already have a resulting value in <code>self.value</code> in a <code>Some</code>;
if we do, it returns the value within the <code>Some</code> without executing the closure
again.</p>
<p>If <code>self.value</code> is <code>None</code>, the code calls the closure stored in
<code>self.calculation</code>, saves the result in <code>self.value</code> for future use, and
returns the value as well.</p>
<p>Listing 13-11 shows how we can use this <code>Cacher</code> struct in the function
<code>generate_workout</code> from Listing 13-6.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">struct Cacher<T>
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -> u32,
</span><span class="boring">{
</span><span class="boring">    calculation: T,
</span><span class="boring">    value: Option<u32>,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl<T> Cacher<T>
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -> u32,
</span><span class="boring">{
</span><span class="boring">    fn new(calculation: T) -> Cacher<T> {
</span><span class="boring">        Cacher {
</span><span class="boring">            calculation,
</span><span class="boring">            value: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn value(&mut self, arg: u32) -> u32 {
</span><span class="boring">        match self.value {
</span><span class="boring">            Some(v) => v,
</span><span class="boring">            None => {
</span><span class="boring">                let v = (self.calculation)(arg);
</span><span class="boring">                self.value = Some(v);
</span><span class="boring">                v
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn <span class="ra" data-hover="11">generate_workout</span>(<span class="ra" data-hover="5">intensity</span>: <span class="ra" data-hover="6">u32</span>, <span class="ra" data-hover="12">random_number</span>: <span class="ra" data-hover="6">u32</span>) {
    let mut <span class="ra" data-hover="45">expensive_result</span><span class="inlay-hint">: Cacher&lt;|…| -&gt; u32&gt;</span> = <span class="ra" data-hover="30">Cacher</span>::<span class="ra" data-hover="36">new</span>(<span class="inlay-hint">calculation: </span>|<span class="ra" data-hover="17">num</span><span class="inlay-hint">: u32</span>| {
        <span class="ra" data-hover="7">println</span>!("calculating slowly...");
        <span class="ra" data-hover="1">thread</span>::<span class="ra" data-hover="8">sleep</span>(<span class="ra" data-hover="3"><span class="inlay-hint">dur: </span>Duration</span>::<span class="ra" data-hover="9">from_secs</span>(2));
        <span class="ra" data-hover="17">num
    });

    if <span class="ra" data-hover="5">intensity</span> &lt; 25 {
        <span class="ra" data-hover="7">println</span>!("Today, do {} pushups!", <span class="ra" data-hover="45">expensive_result</span>.<span class="ra" data-hover="39">value</span>(<span class="ra" data-hover="5">intensity</span>));
        <span class="ra" data-hover="7">println</span>!("Next, do {} situps!", <span class="ra" data-hover="45">expensive_result</span>.<span class="ra" data-hover="39">value</span>(<span class="ra" data-hover="5">intensity</span>));
    } else {
        if <span class="ra" data-hover="12">random_number</span> == 3 {
            <span class="ra" data-hover="7">println</span>!("Take a break today! Remember to stay hydrated!");
        } else {
            <span class="ra" data-hover="7">println</span>!(
                "Today, run for {} minutes!",
                <span class="ra" data-hover="45">expensive_result</span>.<span class="ra" data-hover="39">value</span>(<span class="ra" data-hover="5">intensity</span>)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span>
</code></pre></pre>
<p><span class="caption">Listing 13-11: Using <code>Cacher</code> in the <code>generate_workout</code>
function to abstract away the caching logic</span></p>
<p>Instead of saving the closure in a variable directly, we save a new instance of
<code>Cacher</code> that holds the closure. Then, in each place we want the result, we
call the <code>value</code> method on the <code>Cacher</code> instance. We can call the <code>value</code>
method as many times as we want, or not call it at all, and the expensive
calculation will be run a maximum of once.</p>
<p>Try running this program with the <code>main</code> function from Listing 13-2. Change the
values in the <code>simulated_user_specified_value</code> and <code>simulated_random_number</code>
variables to verify that in all the cases in the various <code>if</code> and <code>else</code>
blocks, <code>calculating slowly...</code> appears only once and only when needed. The
<code>Cacher</code> takes care of the logic necessary to ensure we aren’t calling the
expensive calculation more than we need to so <code>generate_workout</code> can focus on
the business logic.</p>
<h3 id="limitations-of-the-cacher-implementation"><a class="header" href="#limitations-of-the-cacher-implementation">Limitations of the <code>Cacher</code> Implementation</a></h3>
<p>Caching values is a generally useful behavior that we might want to use in
other parts of our code with different closures. However, there are two
problems with the current implementation of <code>Cacher</code> that would make reusing it
in different contexts difficult.</p>
<p>The first problem is that a <code>Cacher</code> instance assumes it will always get the
same value for the parameter <code>arg</code> to the <code>value</code> method. That is, this test of
<code>Cacher</code> will fail:</p>
<pre><pre class="playground"><code class="language-rust hljs"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Cacher<T>
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -> u32,
</span><span class="boring">{
</span><span class="boring">    calculation: T,
</span><span class="boring">    value: Option<u32>,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl<T> Cacher<T>
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -> u32,
</span><span class="boring">{
</span><span class="boring">    fn new(calculation: T) -> Cacher<T> {
</span><span class="boring">        Cacher {
</span><span class="boring">            calculation,
</span><span class="boring">            value: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn value(&mut self, arg: u32) -> u32 {
</span><span class="boring">        match self.value {
</span><span class="boring">            Some(v) => v,
</span><span class="boring">            None => {
</span><span class="boring">                let v = (self.calculation)(arg);
</span><span class="boring">                self.value = Some(v);
</span><span class="boring">                v
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[<span class="ra" data-hover="46">test</span>]
    fn <span class="ra" data-hover="47">call_with_different_values</span>() {
        let mut <span class="ra" data-hover="48">c</span> = <span class="ra" data-hover="30">Cacher</span>::new(|<span class="ra" data-hover="49">a</span>| <span class="ra" data-hover="49">a</span>);

        let <span class="ra" data-hover="50">v1</span> = <span class="ra" data-hover="48">c</span>.value(1);
        let <span class="ra" data-hover="51">v2</span> = <span class="ra" data-hover="48">c</span>.value(2);

        <span class="ra" data-hover="52">assert_eq</span>!(<span class="ra" data-hover="51">v2</span>, 2);
    }
<span class="boring">}
</span><span class="boring">}
</span>
</code></pre></pre>
<p>This test creates a new <code>Cacher</code> instance with a closure that returns the value
passed into it. We call the <code>value</code> method on this <code>Cacher</code> instance with an
<code>arg</code> value of 1 and then an <code>arg</code> value of 2, and we expect the call to
<code>value</code> with the <code>arg</code> value of 2 to return 2.</p>
<p>Run this test with the <code>Cacher</code> implementation in Listing 13-9 and Listing
13-10, and the test will fail on the <code>assert_eq!</code> with this message:</p>
<pre><code class="language-console">$ cargo test
   Compiling cacher v0.1.0 (file:///projects/cacher)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running unittests (target/debug/deps/cacher-074d7c200c000afa)

running 1 test
test tests::call_with_different_values ... FAILED

failures:

---- tests::call_with_different_values stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/lib.rs:43:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::call_with_different_values

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>The problem is that the first time we called <code>c.value</code> with 1, the <code>Cacher</code>
instance saved <code>Some(1)</code> in <code>self.value</code>. Thereafter, no matter what we pass into
the <code>value</code> method, it will always return 1.</p>
<p>Try modifying <code>Cacher</code> to hold a hash map rather than a single value. The keys
of the hash map will be the <code>arg</code> values that are passed in, and the values of
the hash map will be the result of calling the closure on that key. Instead of
looking at whether <code>self.value</code> directly has a <code>Some</code> or a <code>None</code> value, the
<code>value</code> function will look up the <code>arg</code> in the hash map and return the value if
it’s present. If it’s not present, the <code>Cacher</code> will call the closure and save
the resulting value in the hash map associated with its <code>arg</code> value.</p>
<p>The second problem with the current <code>Cacher</code> implementation is that it only
accepts closures that take one parameter of type <code>u32</code> and return a <code>u32</code>. We
might want to cache the results of closures that take a string slice and return
<code>usize</code> values, for example. To fix this issue, try introducing more generic
parameters to increase the flexibility of the <code>Cacher</code> functionality.</p>
<h3 id="capturing-the-environment-with-closures"><a class="header" href="#capturing-the-environment-with-closures">Capturing the Environment with Closures</a></h3>
<p>In the workout generator example, we only used closures as inline anonymous
functions. However, closures have an additional capability that functions don’t
have: they can capture their environment and access variables from the scope in
which they’re defined.</p>
<p>Listing 13-12 has an example of a closure stored in the <code>equal_to_x</code> variable
that uses the <code>x</code> variable from the closure’s surrounding environment.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn <span class="ra" data-hover="10">main</span>() {
    let <span class="ra" data-hover="53">x</span><span class="inlay-hint">: i32</span> = 4;

    let <span class="ra" data-hover="54">equal_to_x</span><span class="inlay-hint">: |…| -&gt; bool</span> = |<span class="ra" data-hover="55">z</span><span class="inlay-hint">: i32</span>| <span class="ra" data-hover="55">z</span> == <span class="ra" data-hover="53">x</span>;

    let <span class="ra" data-hover="56">y</span><span class="inlay-hint">: i32</span> = 4;

    <span class="ra" data-hover="57">assert</span>!(<span class="ra" data-hover="54">equal_to_x</span>(<span class="ra" data-hover="56">y</span>));
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-12: Example of a closure that refers to a
variable in its enclosing scope</span></p>
<p>Here, even though <code>x</code> is not one of the parameters of <code>equal_to_x</code>, the
<code>equal_to_x</code> closure is allowed to use the <code>x</code> variable that’s defined in the
same scope that <code>equal_to_x</code> is defined in.</p>
<p>We can’t do the same with functions; if we try with the following example, our
code won’t compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn <span class="ra" data-hover="10">main</span>() {
    let <span class="ra" data-hover="53">x</span><span class="inlay-hint">: i32</span> = 4;

    fn <span class="ra" data-hover="58">equal_to_x</span>(<span class="ra" data-hover="55">z</span>: <span class="ra" data-hover="59">i32</span>) -&gt; <span class="ra" data-hover="60">bool</span> {
        <span class="ra" data-hover="55">z</span> == x
    }

    let <span class="ra" data-hover="56">y</span><span class="inlay-hint">: i32</span> = 4;

    <span class="ra" data-hover="57">assert</span>!(<span class="ra" data-hover="58">equal_to_x</span>(<span class="ra" data-hover="56">y</span>));
}
<span class="boring">}
</span></code></pre></pre>
<p>We get an error:</p>
<pre><code class="language-console">$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0434]: can't capture dynamic environment in a fn item
 --&gt; src/main.rs:5:14
  |
5 |         z == x
  |              ^
  |
  = help: use the `|| { ... }` closure form instead

For more information about this error, try `rustc --explain E0434`.
error: could not compile `equal-to-x` due to previous error
</code></pre>
<p>The compiler even reminds us that this only works with closures!</p>
<p>When a closure captures a value from its environment, it uses memory to store
the values for use in the closure body. This use of memory is overhead that we
don’t want to pay in more common cases where we want to execute code that
doesn’t capture its environment. Because functions are never allowed to capture
their environment, defining and using functions will never incur this overhead.</p>
<p>Closures can capture values from their environment in three ways, which
directly map to the three ways a function can take a parameter: taking
ownership, borrowing mutably, and borrowing immutably. These are encoded in the
three <code>Fn</code> traits as follows:</p>
<ul>
<li><code>FnOnce</code> consumes the variables it captures from its enclosing scope, known
as the closure’s <em>environment</em>. To consume the captured variables, the
closure must take ownership of these variables and move them into the closure
when it is defined. The <code>Once</code> part of the name represents the fact that the
closure can’t take ownership of the same variables more than once, so it can
be called only once.</li>
<li><code>FnMut</code> can change the environment because it mutably borrows values.</li>
<li><code>Fn</code> borrows values from the environment immutably.</li>
</ul>
<p>When you create a closure, Rust infers which trait to use based on how the
closure uses the values from the environment. All closures implement <code>FnOnce</code>
because they can all be called at least once. Closures that don’t move the
captured variables also implement <code>FnMut</code>, and closures that don’t need mutable
access to the captured variables also implement <code>Fn</code>. In Listing 13-12, the
<code>equal_to_x</code> closure borrows <code>x</code> immutably (so <code>equal_to_x</code> has the <code>Fn</code> trait)
because the body of the closure only needs to read the value in <code>x</code>.</p>
<p>If you want to force the closure to take ownership of the values it uses in the
environment, you can use the <code>move</code> keyword before the parameter list. This
technique is mostly useful when passing a closure to a new thread to move the
data so it’s owned by the new thread.</p>
<blockquote>
<p>Note: <code>move</code> closures may still implement <code>Fn</code> or <code>FnMut</code>, even though
they capture variables by move. This is because the traits implemented by a
closure type are determined by what the closure does with captured values,
not how it captures them. The <code>move</code> keyword only specifies the latter.</p>
</blockquote>
<p>We’ll have more examples of <code>move</code> closures in Chapter 16 when we talk about
concurrency. For now, here’s the code from Listing 13-12 with the <code>move</code>
keyword added to the closure definition and using vectors instead of integers,
because integers can be copied rather than moved; note that this code will not
yet compile.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust hljs">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn <span class="ra" data-hover="10">main</span>() {
    let <span class="ra" data-hover="61">x</span><span class="inlay-hint">: Vec&lt;i32&gt;</span> = <span class="ra" data-hover="62">vec</span>![1, 2, 3];

    let <span class="ra" data-hover="63">equal_to_x</span><span class="inlay-hint">: |…| -&gt; bool</span> = move |<span class="ra" data-hover="64">z</span><span class="inlay-hint">: Vec&lt;i32&gt;</span>| <span class="ra" data-hover="64">z</span> == <span class="ra" data-hover="61">x</span>;

    <span class="ra" data-hover="7">println</span>!("can't use x here: {:?}", <span class="ra" data-hover="61">x</span>);

    let <span class="ra" data-hover="65">y</span><span class="inlay-hint">: Vec&lt;i32&gt;</span> = <span class="ra" data-hover="62">vec</span>![1, 2, 3];

    <span class="ra" data-hover="57">assert</span>!(<span class="ra" data-hover="63">equal_to_x</span>(<span class="ra" data-hover="65">y</span>));
}
<span class="boring">}
</span></code></pre></pre>
<p>We receive the following error:</p>
<pre><code class="language-console">$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0382]: borrow of moved value: `x`
 --&gt; src/main.rs:6:40
  |
2 |     let x = vec![1, 2, 3];
  |         - move occurs because `x` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
3 | 
4 |     let equal_to_x = move |z| z == x;
  |                      --------      - variable moved due to use in closure
  |                      |
  |                      value moved into closure here
5 | 
6 |     println!(&quot;can't use x here: {:?}&quot;, x);
  |                                        ^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `equal-to-x` due to previous error
</code></pre>
<p>The <code>x</code> value is moved into the closure when the closure is defined, because we
added the <code>move</code> keyword. The closure then has ownership of <code>x</code>, and <code>main</code>
isn’t allowed to use <code>x</code> anymore in the <code>println!</code> statement. Removing
<code>println!</code> will fix this example.</p>
<p>Most of the time when specifying one of the <code>Fn</code> trait bounds, you can start
with <code>Fn</code> and the compiler will tell you if you need <code>FnMut</code> or <code>FnOnce</code> based
on what happens in the closure body.</p>
<p>To illustrate situations where closures that can capture their environment are
useful as function parameters, let’s move on to our next topic: iterators.</p>
<script src="https://unpkg.com/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
<script src="https://unpkg.com/tippy.js@6.3.2/dist/tippy-bundle.umd.min.js" integrity="sha384-vApKv6LkBdPwmt/fNiQrBCVCZvuniXpG0b5UZhVrGAq1zXdZRSsPcWjGdVxkZJtX" crossorigin="anonymous"></script>
<script>
    const hoverData = ['<per><cide class="language-rust">extern crate std\n</code></pre>\n<hr />\n<h1 id="the-rust-standard-library"><a class="header" href="#the-rust-standard-library">The Rust Standard Library</a></h1>\n<p>The Rust Standard Library is the foundation of portable Rust software, a\nset of minimal and battle-tested shared abstractions for the <a href="https://crates.io">broader Rust\necosystem</a>. It offers core types, like <a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a> and\n<a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>Option&lt;T&gt;</code></a>, library-defined <a href="https://docs.rs/std/*/std/index.html#primitives">operations on language\nprimitives</a>, <a href="https://docs.rs/std/*/std/index.html#macros">standard macros</a>, <a href="https://docs.rs/std/*/std/io/index.html">I/O</a> and\n<a href="https://docs.rs/std/*/std/thread/index.html">multithreading</a>, among <a href="https://docs.rs/std/*/std/index.html#what-is-in-the-standard-library-documentation">many other things</a>.</p>\n<p><cide>std</code> is available to all Rust crates by default. Therefore, the\nstandard library can be accessed in <a href="https://docs.rs/std/*/book/ch07-02-defining-modules-to-control-scope-and-privacy.html"><cide>use</code></a> statements through the path\n<cide>std</code>, as in <a href="https://docs.rs/std/*/std/env/index.html"><cide>use std::env</code></a>.</p>\n<h1 id="how-to-read-this-documentation"><a class="header" href="#how-to-read-this-documentation">How to read this documentation</a></h1>\n<p>If you already know the name of what you are looking for, the fastest way to\nfind it is to use the <!-- raw HTML omitted -->search\nbar<!-- raw HTML omitted --> at the top of the page.</p>\n<p>Otherwise, you may want to jump to one of these useful sections:</p>\n<ul>\n<li><a href="https://docs.rs/std/*/std/index.html#modules"><cide>std::*</code> modules</a></li>\n<li><a href="https://docs.rs/std/*/std/index.html#primitives">Primitive types</a></li>\n<li><a href="https://docs.rs/std/*/std/index.html#macros">Standard macros</a></li>\n<li><a href="https://docs.rs/std/*/std/prelude/index.html">The Rust Prelude</a></li>\n</ul>\n<p>If this is your first time, the documentation for the standard library is\nwritten to be casually perused. Clicking on interesting things should\ngenerally lead you to interesting places. Still, there are important bits\nyou don#$%t want to miss, so read on for a tour of the standard library and\nits documentation!</p>\n<p>Once you are familiar with the contents of the standard library you may\nbegin to find the verbosity of the prose distracting. At this stage in your\ndevelopment you may want to press the <cide>[-]</code> button near the top of the\npage to collapse it into a more skimmable view.</p>\n<p>While you are looking at that <cide>[-]</code> button also notice the <cide>[src]</code>\nbutton. Rust#$%s API documentation comes with the source code and you are\nencouraged to read it. The standard library source is generally high\nquality and a peek behind the curtains is often enlightening.</p>\n<h1 id="what-is-in-the-standard-library-documentation"><a class="header" href="#what-is-in-the-standard-library-documentation">What is in the standard library documentation?</a></h1>\n<p>First of all, The Rust Standard Library is divided into a number of focused\nmodules, <a href="https://docs.rs/std/*/std/index.html#modules">all listed further down this page</a>. These modules are\nthe bedrock upon which all of Rust is forged, and they have mighty names\nlike <a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>std::slice</code></a> and <a href="https://docs.rs/core/*/core/cmp/index.html"><cide>std::cmp</code></a>. Modules#$% documentation typically\nincludes an overview of the module along with examples, and are a smart\nplace to start familiarizing yourself with the library.</p>\n<p>Second, implicit methods on <a href="https://docs.rs/std/*/book/ch03-02-data-types.html">primitive types</a> are documented here. This can\nbe a source of confusion for two reasons:</p>\n<ol>\n<li>While primitives are implemented by the compiler, the standard library\nimplements methods directly on the primitive types (and it is the only\nlibrary that does so), which are <a href="https://docs.rs/std/*/std/index.html#primitives">documented in the section on\nprimitives</a>.</li>\n<li>The standard library exports many modules <em>with the same name as\nprimitive types</em>. These define additional items related to the primitive\ntype, but not the all-important methods.</li>\n</ol>\n<p>So for example there is a <a href="primitive::i32">page for the primitive type\n<cide>i32</code></a> that lists all the methods that can be called on\n32-bit integers (very useful), and there is a <a href="https://docs.rs/core/*/core/i32/index.html">page for the module\n<cide>std::i32</code></a> that documents the constant values <a href="https://docs.rs/core/*/core/i32/const.MIN.html"><cide>MIN</code></a> and <a href="https://docs.rs/core/*/core/i32/const.MAX.html"><cide>MAX</code></a> (rarely\nuseful).</p>\n<p>Note the documentation for the primitives <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a> and <a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>[T]</code></a> (also\ncalled #$%slice#$%). Many method calls on <a href="https://docs.rs/alloc/*/alloc/string/struct.String.html"><cide>String</code></a> and <a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a> are actually\ncalls to methods on <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a> and <a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>[T]</code></a> respectively, via <a href="https://docs.rs/std/*/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods">deref\ncoercions</a>.</p>\n<p>Third, the standard library defines <a href="https://docs.rs/std/*/std/prelude/index.html">The Rust Prelude</a>, a small collection\nof items - mostly traits - that are imported into every module of every\ncrate. The traits in the prelude are pervasive, making the prelude\ndocumentation a good entry point to learning about the library.</p>\n<p>And finally, the standard library exports a number of standard macros, and\n<a href="https://docs.rs/std/*/std/index.html#macros">lists them on this page</a> (technically, not all of the standard\nmacros are defined by the standard library - some are defined by the\ncompiler - but they are documented here the same). Like the prelude, the\nstandard macros are imported by default into all crates.</p>\n<h1 id="contributing-changes-to-the-documentation"><a class="header" href="#contributing-changes-to-the-documentation">Contributing changes to the documentation</a></h1>\n<p>Check out the rust contribution guidelines <a href="https://rustc-dev-guide.rust-lang.org/contributing.html#writing-documentation">here</a>.\nThe source for this documentation can be found on\n<a href="https://github.com/rust-lang/rust">GitHub</a>.\nTo contribute changes, make sure you read the guidelines first, then submit\npull-requests for your suggested changes.</p>\n<p>Contributions are appreciated! If you see a part of the docs that can be\nimproved, submit a PR, or chat with us first on <a href="https://discord.gg/rust-lang">Discord</a>\n#docs.</p>\n<h1 id="a-tour-of-the-rust-standard-library"><a class="header" href="#a-tour-of-the-rust-standard-library">A Tour of The Rust Standard Library</a></h1>\n<p>The rest of this crate documentation is dedicated to pointing out notable\nfeatures of The Rust Standard Library.</p>\n<h2 id="containers-and-collections"><a class="header" href="#containers-and-collections">Containers and collections</a></h2>\n<p>The <a href="https://docs.rs/core/*/core/option/index.html"><cide>option</code></a> and <a href="https://docs.rs/core/*/core/result/index.html"><cide>result</code></a> modules define optional and error-handling\ntypes, <a href="https://docs.rs/core/*/core/option/enum.Option.html"><cide>Option&lt;T&gt;</code></a> and <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Result&lt;T, E&gt;</code></a>. The <a href="https://docs.rs/core/*/core/iter/index.html"><cide>iter</code></a> module defines\nRust#$%s iterator trait, <a href="https://docs.rs/core/*/core/iter/traits/iterator/trait.Iterator.html"><cide>Iterator</code></a>, which works with the <a href="https://docs.rs/std/*/book/ch03-05-control-flow.html#looping-through-a-collection-with-for"><cide>for</code></a> loop to\naccess collections.</p>\n<p>The standard library exposes three common ways to deal with contiguous\nregions of memory:</p>\n<ul>\n<li><a href="https://docs.rs/alloc/*/alloc/vec/struct.Vec.html"><cide>Vec&lt;T&gt;</code></a> - A heap-allocated <em>vector</em> that is resizable at runtime.</li>\n<li><a href="https://docs.rs/core/*/core/array/index.html"><cide>[T; N]</code></a> - An inline <em>array</em> with a fixed size at compile time.</li>\n<li><a href="https://docs.rs/alloc/*/alloc/slice/index.html"><cide>[T]</code></a> - A dynamically sized <em>slice</em> into any other kind of contiguous\nstorage, whether heap-allocated or not.</li>\n</ul>\n<p>Slices can only be handled through some kind of <em>pointer</em>, and as such come\nin many flavors such as:</p>\n<ul>\n<li><cide>&amp;[T]</code> - <em>shared slice</em></li>\n<li><cide>&amp;mut [T]</code> - <em>mutable slice</em></li>\n<li><a href="https://docs.rs/alloc/*/alloc/boxed/index.html"><cide>Box&lt;[T]&gt;</code></a> - <em>owned slice</em></li>\n</ul>\n<p><a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>, a UTF-8 string slice, is a primitive type, and the standard library\ndefines many methods for it. Rust <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>s are typically accessed as\nimmutable references: <cide>&amp;str</code>. Use the owned <a href="https://docs.rs/alloc/*/alloc/string/struct.String.html"><cide>String</code></a> for building and\nmutating strings.</p>\n<p>For converting to strings use the <a href="https://docs.rs/alloc/*/alloc/macro.format.html"><cide>format</code></a> macro, and for converting from\nstrings use the <a href="https://docs.rs/core/*/core/str/traits/trait.FromStr.html"><cide>FromStr</code></a> trait.</p>\n<p>Data may be shared by placing it in a reference-counted box or the <a href="https://docs.rs/alloc/*/alloc/rc/struct.Rc.html"><cide>Rc</code></a>\ntype, and if further contained in a <a href="https://docs.rs/core/*/core/cell/struct.Cell.html"><cide>Cell</code></a> or <a href="https://docs.rs/core/*/core/cell/struct.RefCell.html"><cide>RefCell</code></a>, may be mutated\nas well as shared. Likewise, in a concurrent setting it is common to pair an\natomically-reference-counted box, <a href="https://docs.rs/alloc/*/alloc/sync/struct.Arc.html"><cide>Arc</code></a>, with a <a href="https://docs.rs/std/*/std/sync/mutex/struct.Mutex.html"><cide>Mutex</code></a> to get the same\neffect.</p>\n<p>The <a href="https://docs.rs/std/*/std/collections/index.html"><cide>collections</code></a> module defines maps, sets, linked lists and other\ntypical collection types, including the common <a href="https://docs.rs/std/*/std/collections/hash/map/struct.HashMap.html"><cide>HashMap&lt;K, V&gt;</code></a>.</p>\n<h2 id="platform-abstractions-and-io"><a class="header" href="#platform-abstractions-and-io">Platform abstractions and I/O</a></h2>\n<p>Besides basic data types, the standard library is largely concerned with\nabstracting over differences in common platforms, most notably Windows and\nUnix derivatives.</p>\n<p>Common types of I/O, including <a href="https://docs.rs/std/*/std/fs/struct.File.html">files</a>, <a href="https://docs.rs/std/*/std/net/tcp/struct.TcpStream.html">TCP</a>, <a href="https://docs.rs/std/*/std/net/udp/struct.UdpSocket.html">UDP</a>, are defined in the\n<a href="https://docs.rs/std/*/std/io/index.html"><cide>io</code></a>, <a href="https://docs.rs/std/*/std/fs/index.html"><cide>fs</code></a>, and <a href="https://docs.rs/std/*/std/net/index.html"><cide>net</code></a> modules.</p>\n<p>The <a href="https://docs.rs/std/*/std/thread/index.html"><cide>thread</code></a> module contains Rust#$%s threading abstractions. <a href="https://docs.rs/std/*/std/sync/index.html"><cide>sync</code></a>\ncontains further primitive shared memory types, including <a href="https://docs.rs/core/*/core/sync/atomic/index.html"><cide>atomic</code></a> and\n<a href="https://docs.rs/std/*/std/sync/mpsc/index.html"><cide>mpsc</code></a>, which contains the channel types for message passing.</p>\n','<per><cide class="language-rust">std\n</code></pre>\n<per><cide class="language-rust">mod thread\n</code></pre>\n<hr />\n<p>Native threads.</p>\n<h2 id="the-threading-model"><a class="header" href="#the-threading-model">The threading model</a></h2>\n<p>An executing Rust program consists of a collection of native OS threads,\neach with their own stack and local state. Threads can be named, and\nprovide some built-in support for low-level synchronization.</p>\n<p>Communication between threads can be done through\n<a href="https://docs.rs/std/*/std/sync/mpsc/index.html">channels</a>, Rust#$%s message-passing types, along with <a href="https://docs.rs/std/*/std/sync/index.html">other forms of thread\nsynchronization</a> and shared-memory data\nstructures. In particular, types that are guaranteed to be\nthreadsafe are easily shared between threads using the\natomically-reference-counted container, <a href="https://docs.rs/alloc/*/alloc/sync/struct.Arc.html"><cide>Arc</code></a>.</p>\n<p>Fatal logic errors in Rust cause <em>thread panic</em>, during which\na thread will unwind the stack, running destructors and freeing\nowned resources. While not meant as a #$%try/catch#$% mechanism, panics\nin Rust can nonetheless be caught (unless compiling with <cide>panic=abort</code>) with\n<a href="https://docs.rs/std/*/std/panic/fn.catch_unwind.html"><cide>catch_unwind</code></a> and recovered\nfrom, or alternatively be resumed with\n<a href="https://docs.rs/std/*/std/panic/fn.resume_unwind.html"><cide>resume_unwind</code></a>. If the panic\nis not caught the thread will exit, but the panic may optionally be\ndetected from a different thread with <a href="JoinHandle::join"><cide>join</code></a>. If the main thread panics\nwithout the panic being caught, the application will exit with a\nnon-zero exit code.</p>\n<p>When the main thread of a Rust program terminates, the entire program shuts\ndown, even if other threads are still running. However, this module provides\nconvenient facilities for automatically waiting for the termination of a\nchild thread (i.e., join).</p>\n<h2 id="spawning-a-thread"><a class="header" href="#spawning-a-thread">Spawning a thread</a></h2>\n<p>A new thread can be spawned using the <a href="https://docs.rs/std/*/std/thread/fn.spawn.html"><cide>thread::spawn</code></a> function:</p>\n<per><cide class="language-rust">use std::thread;\n\nthread::spawn(move || {\n    // some work here\n});\n</code></pre>\n<p>In this example, the spawned thread is &quot;detached&quot; from the current\nthread. This means that it can outlive its parent (the thread that spawned\nit), unless this parent is the main thread.</p>\n<p>The parent thread can also wait on the completion of the child\nthread; a call to <a href="https://docs.rs/std/*/std/thread/fn.spawn.html"><cide>spawn</code></a> produces a <a href="https://docs.rs/std/*/std/thread/struct.JoinHandle.html"><cide>JoinHandle</code></a>, which provides\na <cide>join</code> method for waiting:</p>\n<per><cide class="language-rust">use std::thread;\n\nlet child = thread::spawn(move || {\n    // some work here\n});\n// some work here\nlet res = child.join();\n</code></pre>\n<p>The <a href="JoinHandle::join"><cide>join</code></a> method returns a <a href="https://docs.rs/std/*/std/thread/type.Result.html"><cide>thread::Result</code></a> containing <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Ok</code></a> of the final\nvalue produced by the child thread, or <a href="https://docs.rs/core/*/core/result/enum.Result.html"><cide>Err</code></a> of the value given to\na call to <a href="https://docs.rs/core/*/core/macro.panic.html"><cide>panic</code></a> if the child panicked.</p>\n<h2 id="configuring-threads"><a class="header" href="#configuring-threads">Configuring threads</a></h2>\n<p>A new thread can be configured before it is spawned via the <a href="https://docs.rs/std/*/std/thread/struct.Builder.html"><cide>Builder</code></a> type,\nwhich currently allows you to set the name and stack size for the child thread:</p>\n<per><cide class="language-rust"># #![allow(unused_must_use)]\nuse std::thread;\n\nthread::Builder::new().name(&quot;child1&quot;.to_string()).spawn(move || {\n    println!(&quot;Hello, world!&quot;);\n});\n</code></pre>\n<h2 id="the-cidethread-type"><a class="header" href="#the-cidethread-type">The <cide>Thread</code> type</a></h2>\n<p>Threads are represented via the <a href="https://docs.rs/std/*/std/thread/struct.Thread.html"><cide>Thread</code></a> type, which you can get in one of\ntwo ways:</p>\n<ul>\n<li>By spawning a new thread, e.g., using the <a href="https://docs.rs/std/*/std/thread/fn.spawn.html"><cide>thread::spawn</code></a>\nfunction, and calling <a href="%60JoinHandle::thread%60"><cide>thread</code></a> on the <a href="https://docs.rs/std/*/std/thread/struct.JoinHandle.html"><cide>JoinHandle</code></a>.</li>\n<li>By requesting the current thread, using the <a href="https://docs.rs/std/*/std/thread/fn.current.html"><cide>thread::current</code></a> function.</li>\n</ul>\n<p>The <a href="https://docs.rs/std/*/std/thread/fn.current.html"><cide>thread::current</code></a> function is available even for threads not spawned\nby the APIs of this module.</p>\n<h2 id="thread-local-storage"><a class="header" href="#thread-local-storage">Thread-local storage</a></h2>\n<p>This module also provides an implementation of thread-local storage for Rust\nprograms. Thread-local storage is a method of storing data into a global\nvariable that each thread in the program will have its own copy of.\nThreads do not share this data, so accesses do not need to be synchronized.</p>\n<p>A thread-local key owns the value it contains and will destroy the value when the\nthread exits. It is created with the <a href="https://docs.rs/std/*/std/macro.thread_local.html"><cide>thread_local</code></a> macro and can contain any\nvalue that is <cide>#$%static</code> (no borrowed pointers). It provides an accessor function,\n<a href="LocalKey::with"><cide>with</code></a>, that yields a shared reference to the value to the specified\nclosure. Thread-local keys allow only shared access to values, as there would be no\nway to guarantee uniqueness if mutable borrows were allowed. Most values\nwill want to make use of some form of <strong>interior mutability</strong> through the\n<a href="https://docs.rs/core/*/core/cell/struct.Cell.html"><cide>Cell</code></a> or <a href="https://docs.rs/core/*/core/cell/struct.RefCell.html"><cide>RefCell</code></a> types.</p>\n<h2 id="naming-threads"><a class="header" href="#naming-threads">Naming threads</a></h2>\n<p>Threads are able to have associated names for identification purposes. By default, spawned\nthreads are unnamed. To specify a name for a thread, build the thread with <a href="https://docs.rs/std/*/std/thread/struct.Builder.html"><cide>Builder</code></a> and pass\nthe desired thread name to <a href="%60Builder::name%60"><cide>Builder::name</code></a>. To retrieve the thread name from within the\nthread, use <a href="%60Thread::name%60"><cide>Thread::name</code></a>. A couple examples of where the name of a thread gets used:</p>\n<ul>\n<li>If a panic occurs in a named thread, the thread name will be printed in the panic message.</li>\n<li>The thread name is provided to the OS where applicable (e.g., <cide>pthread_setname_np</code> in\nunix-like platforms).</li>\n</ul>\n<h2 id="stack-size"><a class="header" href="#stack-size">Stack size</a></h2>\n<p>The default stack size for spawned threads is 2 MiB, though this particular stack size is\nsubject to change in the future. There are two ways to manually specify the stack size for\nspawned threads:</p>\n<ul>\n<li>Build the thread with <a href="https://docs.rs/std/*/std/thread/struct.Builder.html"><cide>Builder</code></a> and pass the desired stack size to <a href="%60Builder::stack_size%60"><cide>Builder::stack_size</code></a>.</li>\n<li>Set the <cide>RUST_MIN_STACK</code> environment variable to an integer representing the desired stack\nsize (in bytes). Note that setting <a href="%60Builder::stack_size%60"><cide>Builder::stack_size</code></a> will override this.</li>\n</ul>\n<p>Note that the stack size of the main thread is <em>not</em> determined by Rust.</p>\n','<per><cide class="language-rust">std\n</code></pre>\n<per><cide class="language-rust">mod time\n</code></pre>\n<hr />\n<p>Temporal quantification.</p>\n<p>Example:</p>\n<per><cide>use std::time::Duration;\n\nlet five_seconds = Duration::new(5, 0);\n// both declarations are equivalent\nassert_eq!(Duration::new(5, 0), Duration::from_secs(5));\n</code></pre>\n','<per><cide class="language-rust">core::time\n</code></pre>\n<per><cide class="language-rust">pub struct Duration\n</code></pre>\n<hr />\n<p>A <cide>Duration</code> type to represent a span of time, typically used for system\ntimeouts.</p>\n<p>Each <cide>Duration</code> is composed of a whole number of seconds and a fractional part\nrepresented in nanoseconds. If the underlying system does not support\nnanosecond-level precision, APIs binding a system timeout will typically round up\nthe number of nanoseconds.</p>\n<p><a href="https://docs.rs/core/*/core/time/struct.Duration.html"><cide>Duration</code></a>s implement many common traits, including <a href="https://docs.rs/core/*/core/ops/arith/trait.Add.html"><cide>Add</code></a>, <a href="https://docs.rs/core/*/core/ops/arith/trait.Sub.html"><cide>Sub</code></a>, and other\n<a href="https://docs.rs/core/*/core/ops/index.html"><cide>ops</code></a> traits. It implements <a href="https://docs.rs/core/*/core/default/trait.Default.html"><cide>Default</code></a> by returning a zero-length <cide>Duration</code>.</p>\n<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>\n<per><cide>use std::time::Duration;\n\nlet five_seconds = Duration::new(5, 0);\nlet five_seconds_and_five_nanos = five_seconds + Duration::new(0, 5);\n\nassert_eq!(five_seconds_and_five_nanos.as_secs(), 5);\nassert_eq!(five_seconds_and_five_nanos.subsec_nanos(), 5);\n\nlet ten_millis = Duration::from_millis(10);\n</code></pre>\n<h1 id="formatting-cideduration-values"><a class="header" href="#formatting-cideduration-values">Formatting <cide>Duration</code> values</a></h1>\n<p><cide>Duration</code> intentionally does not have a <cide>Display</code> impl, as there are a\nvariety of ways to format spans of time for human readability. <cide>Duration</code>\nprovides a <cide>Debug</code> impl that shows the full precision of the value.</p>\n<p>The <cide>Debug</code> output uses the non-ASCII &quot;µs&quot; suffix for microseconds. If your\nprogram output may appear in contexts that cannot rely on full Unicode\ncompatibility, you may wish to format <cide>Duration</code> objects yourself or use a\ncrate to do so.</p>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn simulated_expensive_calculation(intensity: u32) -&gt; u32\n</code></pre>\n','<per><cide class="language-rust">intensity: u32\n</code></pre>\n','<per><cide class="language-rust">u32\n</code></pre>\n<hr />\n<p>The 32-bit unsigned integer type.</p>\n','<per><cide class="language-rust">std\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! println\n</code></pre>\n<hr />\n<p>Prints to the standard output, with a newline.</p>\n<p>On all platforms, the newline is the LINE FEED character (<cide>\n</code>/<cide>U+000A</code>) alone\n(no additional CARRIAGE RETURN (<cide>\r</code>/<cide>U+000D</code>)).</p>\n<p>Use the <a href="%60format!%60"><cide>format!</code></a> syntax to write data to the standard output.\nSee <a href="crate::fmt"><cide>std::fmt</code></a> for more information.</p>\n<p>Use <cide>println!</code> only for the primary output of your program. Use\n<a href="%60eprintln!%60"><cide>eprintln!</code></a> instead to print error and progress messages.</p>\n<h1 id="panics"><a class="header" href="#panics">Panics</a></h1>\n<p>Panics if writing to <a href="crate::io::stdout"><cide>io::stdout</code></a> fails.</p>\n<h1 id="examples-1"><a class="header" href="#examples-1">Examples</a></h1>\n<per><cide>println!(); // prints just a newline\nprintln!(&quot;hello there!&quot;);\nprintln!(&quot;format {} arguments&quot;, &quot;some&quot;);\n</code></pre>\n','<per><cide class="language-rust">std::thread\n</code></pre>\n<per><cide class="language-rust">pub fn sleep(dur: Duration)\n</code></pre>\n<hr />\n<p>Puts the current thread to sleep for at least the specified amount of time.</p>\n<p>The thread may sleep longer than the duration specified due to scheduling\nspecifics or platform-dependent functionality. It will never sleep less.</p>\n<p>This function is blocking, and should not be used in <cide>async</code> functions.</p>\n<h1 id="platform-specific-behavior"><a class="header" href="#platform-specific-behavior">Platform-specific behavior</a></h1>\n<p>On Unix platforms, the underlying syscall may be interrupted by a\nspurious wakeup or signal handler. To ensure the sleep occurs for at least\nthe specified duration, this function may invoke that system call multiple\ntimes.\nPlatforms which do not support nanosecond precision for sleeping will\nhave <cide>dur</code> rounded up to the nearest granularity of time they can sleep for.</p>\n<p>Currently, specifying a zero duration on Unix platforms returns immediately\nwithout invoking the underlying <a href="https://linux.die.net/man/2/nanosleep"><cide>nanosleep</code></a> syscall, whereas on Windows\nplatforms the underlying <a href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep"><cide>Sleep</code></a> syscall is always invoked.\nIf the intention is to yield the current time-slice you may want to use\n<a href="https://docs.rs/std/*/std/thread/fn.yield_now.html"><cide>yield_now</code></a> instead.</p>\n<h1 id="examples-2"><a class="header" href="#examples-2">Examples</a></h1>\n<per><cide class="language-no_run">use std::{thread, time};\n\nlet ten_millis = time::Duration::from_millis(10);\nlet now = time::Instant::now();\n\nthread::sleep(ten_millis);\n\nassert!(now.elapsed() &gt;= ten_millis);\n</code></pre>\n','<per><cide class="language-rust">core::time::Duration\n</code></pre>\n<per><cide class="language-rust">pub const fn from_secs(secs: u64) -&gt; Duration\n</code></pre>\n<hr />\n<p>Creates a new <cide>Duration</code> from the specified number of whole seconds.</p>\n<h1 id="examples-3"><a class="header" href="#examples-3">Examples</a></h1>\n<per><cide>use std::time::Duration;\n\nlet duration = Duration::from_secs(5);\n\nassert_eq!(5, duration.as_secs());\nassert_eq!(0, duration.subsec_nanos());\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn main()\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn generate_workout(intensity: u32, random_number: u32)\n</code></pre>\n','<per><cide class="language-rust">random_number: u32\n</code></pre>\n','<per><cide class="language-rust">let simulated_user_specified_value: u32\n</code></pre>\n','<per><cide class="language-rust">let simulated_random_number: u32\n</code></pre>\n','<per><cide class="language-rust">let expensive_result: u32\n</code></pre>\n','<per><cide class="language-rust">let expensive_closure: |u32| -&gt; u32\n</code></pre>\n','<per><cide class="language-rust">num: u32\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn add_one_v1(x: u32) -&gt; u32\n</code></pre>\n','<per><cide class="language-rust">x: u32\n</code></pre>\n','<per><cide class="language-rust">let add_one_v2: |u32| -&gt; u32\n</code></pre>\n','<per><cide class="language-rust">let add_one_v3: |{unknown}| -&gt; {unknown}\n</code></pre>\n','<per><cide class="language-rust">x: {unknown}\n</code></pre>\n','<per><cide class="language-rust">let add_one_v4: |{unknown}| -&gt; {unknown}\n</code></pre>\n','<per><cide class="language-rust">let example_closure: |String| -&gt; String\n</code></pre>\n','<per><cide class="language-rust">x: String\n</code></pre>\n','<per><cide class="language-rust">let s: String\n</code></pre>\n','<per><cide class="language-rust">alloc::string\n</code></pre>\n<per><cide class="language-rust">pub struct String\n</code></pre>\n<hr />\n<p>A UTF-8–encoded, growable string.</p>\n<p>The <cide>String</code> type is the most common string type that has ownership over the\ncontents of the string. It has a close relationship with its borrowed\ncounterpart, the primitive <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>.</p>\n<h1 id="examples-4"><a class="header" href="#examples-4">Examples</a></h1>\n<p>You can create a <cide>String</code> from <a href="https://docs.rs/alloc/*/alloc/str/index.html">a literal string</a> with <a href="https://docs.rs/core/*/core/convert/trait.From.html#tymethod.from"><cide>String::from</code></a>:</p>\n<per><cide>let hello = String::from(&quot;Hello, world!&quot;);\n</code></pre>\n<p>You can append a <a href="%60char%60"><cide>char</code></a> to a <cide>String</code> with the <a href="String::push"><cide>push</code></a> method, and\nappend a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a> with the <a href="String::push_str"><cide>push_str</code></a> method:</p>\n<per><cide>let mut hello = String::from(&quot;Hello, &quot;);\n\nhello.push(#$%w#$%);\nhello.push_str(&quot;orld!&quot;);\n</code></pre>\n<p>If you have a vector of UTF-8 bytes, you can create a <cide>String</code> from it with\nthe <a href="String::from_utf8"><cide>from_utf8</code></a> method:</p>\n<per><cide>// some bytes, in a vector\nlet sparkle_heart = vec![240, 159, 146, 150];\n\n// We know these bytes are valid, so we#$%ll use `unwrap()`.\nlet sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n\nassert_eq!(&quot;💖&quot;, sparkle_heart);\n</code></pre>\n<h1 id="utf-8"><a class="header" href="#utf-8">UTF-8</a></h1>\n<p><cide>String</code>s are always valid UTF-8. This has a few implications, the first of\nwhich is that if you need a non-UTF-8 string, consider <a href="https://docs.rs/alloc/*/std/ffi/struct.OsString.html"><cide>OsString</code></a>. It is\nsimilar, but without the UTF-8 constraint. The second implication is that\nyou cannot index into a <cide>String</code>:</p>\n<per><cide class="language-compile_fail,E0277">let s = &quot;hello&quot;;\n\nprintln!(&quot;The first letter of s is {}&quot;, s[0]); // ERROR!!!\n</code></pre>\n<p>Indexing is intended to be a constant-time operation, but UTF-8 encoding\ndoes not allow us to do this. Furthermore, it#$%s not clear what sort of\nthing the index should return: a byte, a codepoint, or a grapheme cluster.\nThe <a href="str::bytes"><cide>bytes</code></a> and <a href="str::chars"><cide>chars</code></a> methods return iterators over the first\ntwo, respectively.</p>\n<h1 id="deref"><a class="header" href="#deref">Deref</a></h1>\n<p><cide>String</code>s implement <a href="https://docs.rs/core/*/core/ops/deref/trait.Deref.html"><cide>Deref</code></a><cide>&lt;Target=str&gt;</code>, and so inherit all of <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>#$%s\nmethods. In addition, this means that you can pass a <cide>String</code> to a\nfunction which takes a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a> by using an ampersand (<cide>&amp;</code>):</p>\n<per><cide>fn takes_str(s: &amp;str) { }\n\nlet s = String::from(&quot;Hello&quot;);\n\ntakes_str(&amp;s);\n</code></pre>\n<p>This will create a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a> from the <cide>String</code> and pass it in. This\nconversion is very inexpensive, and so generally, functions will accept\n<a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a>s as arguments unless they need a <cide>String</code> for some specific\nreason.</p>\n<p>In certain cases Rust doesn#$%t have enough information to make this\nconversion, known as <a href="https://docs.rs/core/*/core/ops/deref/trait.Deref.html"><cide>Deref</code></a> coercion. In the following example a string\nslice <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;#$%a str</code></a> implements the trait <cide>TraitExample</code>, and the function\n<cide>example_func</code> takes anything that implements the trait. In this case Rust\nwould need to make two implicit conversions, which Rust doesn#$%t have the\nmeans to do. For that reason, the following example will not compile.</p>\n<per><cide class="language-compile_fail,E0277">trait TraitExample {}\n\nimpl&lt;#$%a&gt; TraitExample for &amp;#$%a str {}\n\nfn example_func&lt;A: TraitExample&gt;(example_arg: A) {}\n\nlet example_string = String::from(&quot;example_string&quot;);\nexample_func(&amp;example_string);\n</code></pre>\n<p>There are two options that would work instead. The first would be to\nchange the line <cide>example_func(&amp;example_string);</code> to\n<cide>example_func(example_string.as_str());</code>, using the method <a href="String::as_str"><cide>as_str()</code></a>\nto explicitly extract the string slice containing the string. The second\nway changes <cide>example_func(&amp;example_string);</code> to\n<cide>example_func(&amp;*example_string);</code>. In this case we are dereferencing a\n<cide>String</code> to a <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a>, then referencing the <a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>str</code></a> back to\n<a href="https://docs.rs/alloc/*/alloc/str/index.html"><cide>&amp;str</code></a>. The second way is more idiomatic, however both work to do the\nconversion explicitly rather than relying on the implicit conversion.</p>\n<h1 id="representation"><a class="header" href="#representation">Representation</a></h1>\n<p>A <cide>String</code> is made up of three components: a pointer to some bytes, a\nlength, and a capacity. The pointer points to an internal buffer <cide>String</code>\nuses to store its data. The length is the number of bytes currently stored\nin the buffer, and the capacity is the size of the buffer in bytes. As such,\nthe length will always be less than or equal to the capacity.</p>\n<p>This buffer is always stored on the heap.</p>\n<p>You can look at these with the <a href="str::as_ptr"><cide>as_ptr</code></a>, <a href="String::len"><cide>len</code></a>, and <a href="String::capacity"><cide>capacity</code></a>\nmethods:</p>\n<per><cide>use std::mem;\n\nlet story = String::from(&quot;Once upon a time...&quot;);\n\n// Prevent automatically dropping the String#$%s data\nlet mut story = mem::ManuallyDrop::new(story);\n\nlet ptr = story.as_mut_ptr();\nlet len = story.len();\nlet capacity = story.capacity();\n\n// story has nineteen bytes\nassert_eq!(19, len);\n\n// We can re-build a String out of ptr, len, and capacity. This is all\n// unsafe because we are responsible for making sure the components are\n// valid:\nlet s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;\n\nassert_eq!(String::from(&quot;Once upon a time...&quot;), s);\n</code></pre>\n<p>If a <cide>String</code> has enough capacity, adding elements to it will not\nre-allocate. For example, consider this program:</p>\n<per><cide>let mut s = String::new();\n\nprintln!(&quot;{}&quot;, s.capacity());\n\nfor _ in 0..5 {\n    s.push_str(&quot;hello&quot;);\n    println!(&quot;{}&quot;, s.capacity());\n}\n</code></pre>\n<p>This will output the following:</p>\n<per><cide class="language-text">0\n5\n10\n20\n20\n40\n</code></pre>\n<p>At first, we have no memory allocated at all, but as we append to the\nstring, it increases its capacity appropriately. If we instead use the\n<a href="String::with_capacity"><cide>with_capacity</code></a> method to allocate the correct capacity initially:</p>\n<per><cide>let mut s = String::with_capacity(25);\n\nprintln!(&quot;{}&quot;, s.capacity());\n\nfor _ in 0..5 {\n    s.push_str(&quot;hello&quot;);\n    println!(&quot;{}&quot;, s.capacity());\n}\n</code></pre>\n<p>We end up with a different output:</p>\n<per><cide class="language-text">25\n25\n25\n25\n25\n25\n</code></pre>\n<p>Here, there#$%s no need to allocate more memory inside the loop.</p>\n','<per><cide class="language-rust">core::convert::From\n</code></pre>\n<per><cide class="language-rust">pub fn from(_: T) -&gt; Self\n</code></pre>\n<hr />\n<p>Performs the conversion.</p>\n','<per><cide class="language-rust">let n: String\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">struct Cacher&lt;T&gt;\nwhere\n    T: Fn&lt;(u32,), Output = u32&gt;,\n</code></pre>\n','<per><cide class="language-rust">T: Fn(u32)\n</code></pre>\n','<per><cide class="language-rust">core::ops::function\n</code></pre>\n<per><cide class="language-rust">pub trait Fn&lt;Args&gt;\nwhere\n    Self: FnMut&lt;Args&gt;,\n</code></pre>\n<hr />\n<p>The version of the call operator that takes an immutable receiver.</p>\n<p>Instances of <cide>Fn</code> can be called repeatedly without mutating state.</p>\n<p><em>This trait (<cide>Fn</code>) is not to be confused with <a href="fn">function pointers</a>\n(<cide>fn</code>).</em></p>\n<p><cide>Fn</code> is implemented automatically by closures which only take immutable\nreferences to captured variables or don#$%t capture anything at all, as well\nas (safe) <a href="fn">function pointers</a> (with some caveats, see their documentation\nfor more details). Additionally, for any type <cide>F</code> that implements <cide>Fn</code>, <cide>&amp;F</code>\nimplements <cide>Fn</code>, too.</p>\n<p>Since both <a href="https://docs.rs/core/*/core/ops/function/trait.FnMut.html"><cide>FnMut</code></a> and <a href="https://docs.rs/core/*/core/ops/function/trait.FnOnce.html"><cide>FnOnce</code></a> are supertraits of <cide>Fn</code>, any\ninstance of <cide>Fn</code> can be used as a parameter where a <a href="https://docs.rs/core/*/core/ops/function/trait.FnMut.html"><cide>FnMut</code></a> or <a href="https://docs.rs/core/*/core/ops/function/trait.FnOnce.html"><cide>FnOnce</code></a>\nis expected.</p>\n<p>Use <cide>Fn</code> as a bound when you want to accept a parameter of function-like\ntype and need to call it repeatedly and without mutating state (e.g., when\ncalling it concurrently). If you do not need such strict requirements, use\n<a href="https://docs.rs/core/*/core/ops/function/trait.FnMut.html"><cide>FnMut</code></a> or <a href="https://docs.rs/core/*/core/ops/function/trait.FnOnce.html"><cide>FnOnce</code></a> as bounds.</p>\n<p>See the <a href="https://docs.rs/core/*/core/book/ch13-01-closures.html">chapter on closures in <em>The Rust Programming Language</em></a> for\nsome more information on this topic.</p>\n<p>Also of note is the special syntax for <cide>Fn</code> traits (e.g.\n<cide>Fn(usize, bool) -&gt; usize</code>). Those interested in the technical details of\nthis can refer to <a href="https://docs.rs/core/*/core/nomicon/hrtb.html">the relevant section in the <em>Rustonomicon</em></a>.</p>\n<h1 id="examples-5"><a class="header" href="#examples-5">Examples</a></h1>\n<h2 id="calling-a-closure"><a class="header" href="#calling-a-closure">Calling a closure</a></h2>\n<per><cide>let square = |x| x * x;\nassert_eq!(square(5), 25);\n</code></pre>\n<h2 id="using-a-cidefn-parameter"><a class="header" href="#using-a-cidefn-parameter">Using a <cide>Fn</code> parameter</a></h2>\n<per><cide>fn call_with_one&lt;F&gt;(func: F) -&gt; usize\n    where F: Fn(usize) -&gt; usize {\n    func(1)\n}\n\nlet double = |x| x * 2;\nassert_eq!(call_with_one(double), 2);\n</code></pre>\n','<per><cide class="language-rust">playcrate::Cacher\n</code></pre>\n<per><cide class="language-rust">calculation: T\n</code></pre>\n','<per><cide class="language-rust">playcrate::Cacher\n</code></pre>\n<per><cide class="language-rust">value: Option&lt;u32&gt;\n</code></pre>\n','<per><cide class="language-rust">core::option\n</code></pre>\n<per><cide class="language-rust">pub enum Option&lt;T&gt;\n</code></pre>\n<hr />\n<p>The <cide>Option</code> type. See <a href="https://docs.rs/core/*/core/option/index.html">the module level documentation</a> for more.</p>\n','<per><cide class="language-rust">playcrate::Cacher\n</code></pre>\n<per><cide class="language-rust">fn new(calculation: T) -&gt; Cacher&lt;T&gt;\n</code></pre>\n','<per><cide class="language-rust">calculation: T\n</code></pre>\n','<per><cide class="language-rust">core::option::Option\n</code></pre>\n<per><cide class="language-rust">None\n</code></pre>\n<hr />\n<p>No value</p>\n','<per><cide class="language-rust">playcrate::Cacher\n</code></pre>\n<per><cide class="language-rust">fn value(&amp;mut self, arg: u32) -&gt; u32\n</code></pre>\n','<per><cide class="language-rust">self: &amp;mut Cacher&lt;T&gt;\n</code></pre>\n','<per><cide class="language-rust">arg: u32\n</code></pre>\n','<per><cide class="language-rust">core::option::Option\n</code></pre>\n<per><cide class="language-rust">Some(T)\n</code></pre>\n<hr />\n<p>Some value <cide>T</code></p>\n','<per><cide class="language-rust">v: u32\n</code></pre>\n','<per><cide class="language-rust">let v: u32\n</code></pre>\n','<per><cide class="language-rust">let mut expensive_result: Cacher&lt;|u32| -&gt; u32&gt;\n</code></pre>\n','<per><cide class="language-rust">core\n</code></pre>\n<per><cide class="language-rust">pub macro test\n</code></pre>\n<hr />\n<p>Attribute macro applied to a function to turn it into a unit test.</p>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn call_with_different_values()\n</code></pre>\n','<per><cide class="language-rust">let mut c: {unknown}\n</code></pre>\n','<per><cide class="language-rust">a: {unknown}\n</code></pre>\n','<per><cide class="language-rust">let v1: {unknown}\n</code></pre>\n','<per><cide class="language-rust">let v2: {unknown}\n</code></pre>\n','<per><cide class="language-rust">core\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! assert_eq\n</code></pre>\n<hr />\n<p>Asserts that two expressions are equal to each other (using <a href="%60PartialEq%60"><cide>PartialEq</code></a>).</p>\n<p>On panic, this macro will print the values of the expressions with their\ndebug representations.</p>\n<p>Like <a href="%60assert!%60"><cide>assert!</code></a>, this macro has a second form, where a custom\npanic message can be provided.</p>\n<h1 id="examples-6"><a class="header" href="#examples-6">Examples</a></h1>\n<per><cide>let a = 3;\nlet b = 1 + 2;\nassert_eq!(a, b);\n\nassert_eq!(a, b, &quot;we are testing addition with {} and {}&quot;, a, b);\n</code></pre>\n','<per><cide class="language-rust">let x: i32\n</code></pre>\n','<per><cide class="language-rust">let equal_to_x: |i32| -&gt; bool\n</code></pre>\n','<per><cide class="language-rust">z: i32\n</code></pre>\n','<per><cide class="language-rust">let y: i32\n</code></pre>\n','<per><cide class="language-rust">core\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! assert\n</code></pre>\n<hr />\n<p>Asserts that a boolean expression is <cide>true</code> at runtime.</p>\n<p>This will invoke the <a href="%60panic!%60"><cide>panic!</code></a> macro if the provided expression cannot be\nevaluated to <cide>true</code> at runtime.</p>\n<h1 id="uses"><a class="header" href="#uses">Uses</a></h1>\n<p>Assertions are always checked in both debug and release builds, and cannot\nbe disabled. See <a href="%60debug_assert!%60"><cide>debug_assert!</code></a> for assertions that are not enabled in\nrelease builds by default.</p>\n<p>Unsafe code may rely on <cide>assert!</code> to enforce run-time invariants that, if\nviolated could lead to unsafety.</p>\n<p>Other use-cases of <cide>assert!</code> include testing and enforcing run-time\ninvariants in safe code (whose violation cannot result in unsafety).</p>\n<h1 id="custom-messages"><a class="header" href="#custom-messages">Custom Messages</a></h1>\n<p>This macro has a second form, where a custom panic message can\nbe provided with or without arguments for formatting. See <a href="../std/fmt/index.html"><cide>std::fmt</code></a>\nfor syntax for this form. Expressions used as format arguments will only\nbe evaluated if the assertion fails.</p>\n<h1 id="examples-7"><a class="header" href="#examples-7">Examples</a></h1>\n<per><cide>// the panic message for these assertions is the stringified value of the\n// expression given.\nassert!(true);\n\nfn some_computation() -&gt; bool { true } // a very simple function\n\nassert!(some_computation());\n\n// assert with a custom message\nlet x = true;\nassert!(x, &quot;x wasn#$%t true!&quot;);\n\nlet a = 3; let b = 27;\nassert!(a + b == 30, &quot;a = {}, b = {}&quot;, a, b);\n</code></pre>\n','<per><cide class="language-rust">playcrate\n</code></pre>\n<per><cide class="language-rust">fn equal_to_x(z: i32) -&gt; bool\n</code></pre>\n','<per><cide class="language-rust">i32\n</code></pre>\n<hr />\n<p>The 32-bit signed integer type.</p>\n','<per><cide class="language-rust">bool\n</code></pre>\n<hr />\n<p>The boolean type.</p>\n<p>The <cide>bool</code> represents a value, which could only be either <cide>true</code> or <cide>false</code>. If you cast\na <cide>bool</code> into an integer, <cide>true</code> will be 1 and <cide>false</code> will be 0.</p>\n<h1 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h1>\n<p><cide>bool</code> implements various traits, such as <a href="ops::BitAnd"><cide>BitAnd</code></a>, <a href="ops::BitOr"><cide>BitOr</code></a>, <a href="ops::Not"><cide>Not</code></a>, etc.,\nwhich allow us to perform boolean operations using <cide>&amp;</code>, <cide>|</code> and <cide>!</code>.</p>\n<p><cide>if</code> requires a <cide>bool</code> value as its conditional. <a href="%60assert!%60"><cide>assert!</code></a>, which is an\nimportant macro in testing, checks whether an expression is <cide>true</code> and panics\nif it isn#$%t.</p>\n<per><cide>let bool_val = true &amp; false | false;\nassert!(!bool_val);\n</code></pre>\n<h1 id="examples-8"><a class="header" href="#examples-8">Examples</a></h1>\n<p>A trivial example of the usage of <cide>bool</code>:</p>\n<per><cide>let praise_the_borrow_checker = true;\n\n// using the `if` conditional\nif praise_the_borrow_checker {\n    println!(&quot;oh, yeah!&quot;);\n} else {\n    println!(&quot;what?!!&quot;);\n}\n\n// ... or, a match pattern\nmatch praise_the_borrow_checker {\n    true =&gt; println!(&quot;keep praising!&quot;),\n    false =&gt; println!(&quot;you should praise!&quot;),\n}\n</code></pre>\n<p>Also, since <cide>bool</code> implements the <a href="%60Copy%60"><cide>Copy</code></a> trait, we don#$%t\nhave to worry about the move semantics (just like the integer and float primitives).</p>\n<p>Now an example of <cide>bool</code> cast to integer type:</p>\n<per><cide>assert_eq!(true as i32, 1);\nassert_eq!(false as i32, 0);\n</code></pre>\n','<per><cide class="language-rust">let x: Vec&lt;i32, Global&gt;\n</code></pre>\n','<per><cide class="language-rust">alloc\n</code></pre>\n<per><cide class="language-rust">#[macro_export] macro_rules! vec\n</code></pre>\n<hr />\n<p>Creates a <a href="crate::vec::Vec"><cide>Vec</code></a> containing the arguments.</p>\n<p><cide>vec!</code> allows <cide>Vec</code>s to be defined with the same syntax as array expressions.\nThere are two forms of this macro:</p>\n<ul>\n<li>Create a <a href="crate::vec::Vec"><cide>Vec</code></a> containing a given list of elements:</li>\n</ul>\n<per><cide>let v = vec![1, 2, 3];\nassert_eq!(v[0], 1);\nassert_eq!(v[1], 2);\nassert_eq!(v[2], 3);\n</code></pre>\n<ul>\n<li>Create a <a href="crate::vec::Vec"><cide>Vec</code></a> from a given element and size:</li>\n</ul>\n<per><cide>let v = vec![1; 3];\nassert_eq!(v, [1, 1, 1]);\n</code></pre>\n<p>Note that unlike array expressions this syntax supports all elements\nwhich implement <a href="%60Clone%60"><cide>Clone</code></a> and the number of elements doesn#$%t have to be\na constant.</p>\n<p>This will use <cide>clone</code> to duplicate an expression, so one should be careful\nusing this with types having a nonstandard <cide>Clone</code> implementation. For\nexample, <cide>vec![Rc::new(1); 5]</code> will create a vector of five references\nto the same boxed integer value, not five references pointing to independently\nboxed integers.</p>\n<p>Also, note that <cide>vec![expr; 0]</code> is allowed, and produces an empty vector.\nThis will still evaluate <cide>expr</code>, however, and immediately drop the resulting value, so\nbe mindful of side effects.</p>\n','<per><cide class="language-rust">let equal_to_x: |Vec&lt;i32, Global&gt;| -&gt; bool\n</code></pre>\n','<per><cide class="language-rust">z: Vec&lt;i32, Global&gt;\n</code></pre>\n','<per><cide class="language-rust">let y: Vec&lt;i32, Global&gt;\n</code></pre>\n',].map((x)=>x.replaceAll('#$%', "'").replaceAll('<per', '<pre').replaceAll('<cide', '<code'));
    window.onload = () => {
        console.log("hello");
        tippy('.ra', {
            content: (x) => {
                const div = document.createElement('div');
                div.innerHTML = hoverData[x.dataset.hover];
                div.className = 'hover-holder';
                div.querySelectorAll('code').forEach((y) => y.innerHTML = hljs.highlight('rust', y.innerText).value);
                return div;
            },
            allowHTML: true,
            delay: [200, 0],
            interactive: true,
            maxWidth: '80vw',
            appendTo: document.querySelector('.content'),
        });
    };
</script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="ch13-00-functional-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="ch13-02-iterators.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="ch13-00-functional-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="ch13-02-iterators.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="ferris.js"></script>
        
        
    </body>
</html>
